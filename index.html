<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transpot Nomad</title>
    <script src="https://js.api.here.com/v3/3.1/mapsjs-core.js"></script>
    <script src="https://js.api.here.com/v3/3.1/mapsjs-service.js"></script>
    <script src="https://js.api.here.com/v3/3.1/mapsjs-ui.js"></script>
    <script src="https://js.api.here.com/v3/3.1/mapsjs-mapevents.js"></script>
    <link rel="stylesheet" href="https://js.api.here.com/v3/3.1/mapsjs-ui.css"/>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            display: flex;
            height: 100vh;
        }

        #sidebar {
            position: relative;
            width: 300px;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.95);
            border-right: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 16px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            height: 100vh;
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        /* Delikatniejszy scrollbar */
        #sidebar::-webkit-scrollbar {
            display: none;
        }

        #map-container {
            flex: 1;
            height: 100%;
        }

        .waypoint-number {
            position: absolute;
            left: -8px;
            /* Zmieniamy top i transform aby centrować względem pola adresu */
            top: 19px; /* Połowa wysokości waypoint-box (który ma padding 8px góra i dół) */
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            background: white;
            color: #0066CC;
            border: 1.5px solid #0066CC;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            cursor: grab;
            user-select: none;
            z-index: 10;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .waypoint-number:hover {
            background: #f0f5ff;
            box-shadow: 0 2px 8px rgba(0, 102, 204, 0.15);
        }

        .waypoint-number:active {
            cursor: grabbing;
            background: #e5efff;
            transform: translateY(-50%) scale(0.95);
        }

        /* Dodajemy specjalny styl dla stanu przeciągania */
        .waypoint-container.dragging .waypoint-number {
            background: #0066CC;
            color: white;
            box-shadow: 0 4px 12px rgba(0, 102, 204, 0.25);
        }

        .waypoint-box:hover {
            border-color: #0066CC;
            box-shadow: 0 2px 8px rgba(0, 102, 204, 0.15);
        }

        .waypoint-number:active {
            cursor: grabbing;
        }

        .waypoint-container.dragging {
            position: fixed;
            z-index: 1000;
            transform: translateY(var(--y));
            width: var(--width);
        }

        .waypoint-container.shift-down {
            transform: translateY(40px);
        }


        .waypoint-box {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            background: white;
            position: relative; /* Dodaj to */
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }


        .waypoint {
            width: 100%;
            border: none;
            font-size: 14px;
            background: transparent;
            margin-bottom: 2px;
            color: #323130;
        }

        .waypoint:focus {
            outline: none;
        }

        .suggestions-container {
            position: absolute;
            top: 75%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .suggestion-item {
            padding: 8px 12px;
            cursor: pointer;
        }

        .suggestion-item:hover {
            background-color: #f0f0f0;
        }

        .suggestion-item.selected {
            background-color: #e6e6e6;
        }

        #route-info {
            position: relative;
            margin-top: 16px;
            padding: 16px;
            background-color: white;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05); /* Dodajemy ten sam cień co mają pola adresowe */
        }

        /* Możemy też dodać hover efekt, tak jak mają pola adresowe */
        #route-info:hover {
            border-color: #0066CC;
            box-shadow: 0 2px 8px rgba(0, 102, 204, 0.15);
        }

        .route-info-label {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: white;
            padding: 0 8px;
            font-size: 13px;
            color: #666;
        }

        .remove-waypoint {
            position: absolute;
            right: -18px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #ff4444;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            padding: 2px;
            z-index: 1;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .remove-waypoint:hover {
            color: #cc0000;
        }

        .error-message {
            color: #ff4444;
            font-size: 12px;
            margin-top: 4px;
        }

        .route-settings {
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            background-color: rgba(249, 249, 249, 0.9);
            padding: 24px 20px;
            margin: 0 -20px;
        }

        .route-settings .row {
            margin-bottom: 12px;  /* zmniejszony margines między rzędami */
        }

        .route-settings p {
            margin-bottom: 4px;  /* mniejszy odstęp między nagłówkiem a przyciskami */
            font-size: 13px;
            color: #323130;
        }

        .route-settings .button-group {
            display: flex;
            gap: 4px;  /* mniejszy odstęp między przyciskami */
            flex-wrap: wrap;
        }

        .route-settings button {
        padding: 6px 4px; /* zmniejszamy padding poziomy */
        border: 1px solid rgba(0, 0, 0, 0.1);
        background-color: white;
        color: #323130;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px; /* domyślny rozmiar czcionki */
        transition: all 0.2s ease;
        flex: 1 1 0;
        text-align: center;
        font-weight: 500;
        white-space: nowrap;
        overflow: visible; /* pozwalamy na widoczność całego tekstu */
        }
        .route-settings button:hover {
            background-color: #f3f2f1;
            border-color: rgba(0, 0, 0, 0.15);
        }


        .route-settings button.active {
            background-color: #0066CC;
            color: white;
            border-color: transparent;
            box-shadow: 0 2px 4px rgba(0, 102, 204, 0.25);
        }

        #excluded-areas button.active {
            background-color: #dc3545;
            border-color: #dc3545;
            color: white;
        }

        .select-group {
            display: flex;
            gap: 8px;  /* mniejszy odstęp między selectami */
        }

        .select-container {
            flex: 1;
        }

        .route-settings select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            background-color: white;
            font-size: 13px;
            color: #323130;
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 6px 8px;  /* mniejszy padding */
            font-size: 12px;  /* mniejsza czcionka */
        }

        /* Specjalne style dla przycisków wykluczonych obszarów */
        #excluded-areas.button-group {
            gap: 8px;  /* większy odstęp dla tych konkretnych przycisków */
        }

        #excluded-areas button {
            flex: 0 1 calc(50% - 4px);  /* każdy przycisk zajmuje połowę szerokości */
        }

        .route-settings select:hover {
            border-color: #0066CC;
        }


        .route-settings select:focus {
            outline: none;
            border-color: #0066CC;
            box-shadow: 0 0 0 2px rgba(0, 102, 204, 0.1);
        }
        #restart-button {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 6px 12px;
            background-color: white;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: #323130;
            transition: all 0.2s ease;
            z-index: 1;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            font-weight: 500;
        }

        #restart-button:hover {
            background-color: #f3f2f1;
            border-color: rgba(0, 0, 0, 0.15);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        #restart-button:active {
            background-color: #edebe9;
            transform: scale(0.98);
        }

        #map-container {
            flex: 1;
            height: 100%;
            position: relative;  /* dodajemy, żeby przycisk był względem map-container */
        }
        .toll-summary {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toll-details-toggle {
            background: none;
            border: none;
            padding: 0 4px;
            cursor: pointer;
            color: #0066CC;
            font-size: 12px;
        }

        .toll-details {
            margin-top: 8px;
            padding-left: 12px;
            border-left: 2px solid #eee;
        }

        .country-toll {
            margin: 4px 0;
            color: #666;
        }
        .route-bubble {
            position: absolute;
            background: white;
            border: 1px solid #666;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            white-space: nowrap;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .alternative-route {
            cursor: pointer;
        }
        /* InfoBubble styles */
        .H_ib {
            padding: 0 !important;
            margin: 0 !important;
            box-shadow: none !important;
            background: white !important;
            border: 1px solid #666 !important;
            border-radius: 4px !important;
            min-width: 0 !important;
            max-width: none !important;
        }

        .H_ib_body {
            padding: 4px 6px !important;
            margin: 0 !important;
            min-width: 0 !important;
            max-width: none !important;
        }

        .H_ib_content {
            margin: 0 !important;
            padding: 0 !important;
            font-size: 12px !important;
            white-space: nowrap !important;
            color: black !important;
            line-height: 1.5 !important;
            min-width: 0 !important;
            max-width: none !important;
            display: inline !important;
        }

        .H_ib_close {
            display: none !important;
        }
        .H_ib_tail {
            display: none !important;
        }

        .route-stat {
            display: flex;
            flex-direction: column;
        }

        .route-stat:last-child {
            margin-bottom: 0; /* Usuwa dolny margines z ostatniego elementu */
        }

        .stat-label {
            font-size: 13px; /* Zwiększone z 11px */
            color: #666;
            margin-bottom: 3px; /* Zwiększony margin */
        }

        .stat-value {
            font-size: 16px; /* Zwiększone z 14px */
            color: #323130;
            font-weight: 500;
        }

        .route-stats-container {
            display: flex;
            gap: 20px; /* Zwiększony gap */
            margin-bottom: 16px; /* Zwiększony margin */
        }

        /* Dostosowanie rozmiaru tekstu w szczegółach opłat */
        .country-toll {
            font-size: 14px; /* Zwiększone */
            margin: 6px 0; /* Zwiększony margin */
        }

        /* Dostosowanie przycisku szczegółów */
        .toll-details-toggle {
            font-size: 14px; /* Zwiększone */
            padding: 0 6px; /* Zwiększony padding */
        }

        /* Dostosowanie kontenerów dla promów */
        .ferry-item {
            font-size: 14px; /* Zwiększone */
            margin-top: 4px;
        }
        
        /* odległości między punktami */
        .distance-indicator {
            text-align: left;
            color: #666;
            font-size: 11px;
            padding: 4px 0;
            margin: -3px 0;
            visibility: hidden;
        }

        .distance-indicator.visible {
            visibility: visible;
        }

        .waypoint-container {
            position: relative;
            padding-left: 18px;
            margin-bottom: 0; /* Zmień z 10px na 0 */
        }
        #vehicle-selection {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            margin-bottom: 12px;
            justify-content: flex-start;
        }

        #vehicle-selection button {
            width: 60px; /* zmniejszamy z 70px na 60px */
            flex: 0 0 60px;
            padding: 4px 2px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 2px;
            align-items: center;
        }

        .vehicle-name {
            font-size: 12px;
            font-weight: 500;
            margin-bottom: 1px;
        }

        .vehicle-details {
            display: flex;
            flex-direction: column;
            gap: 1px;
            align-items: center;
            font-size: 9px;
            opacity: 0.8;
            width: 100%;
        }

        .vehicle-details span {
            background: rgba(0, 0, 0, 0.05);
            padding: 1px 3px;
            border-radius: 2px;
            white-space: nowrap;
            width: 90%;
            text-align: center;
        }

        #vehicle-selection button.active {
            background-color: #0066CC;
            color: white;
            border-color: #0066CC;
            box-shadow: 0 2px 4px rgba(0, 102, 204, 0.15);
        }

        #vehicle-selection button.active .vehicle-details span {
            background: rgba(255, 255, 255, 0.15);
            color: white;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <div id="waypoints-container"></div>
        <div id="route-info">
            <div class="route-info-label" data-translation="routeInfo">Route information:</div>
            <div class="route-stats-container">
                <div class="route-stat">
                    <div class="stat-label" data-translation="distance">Distance</div>
                    <div class="stat-value">--</div>
                </div>
                <div class="route-stat">
                    <div class="stat-label" data-translation="time">Time</div>
                    <div class="stat-value">--</div>
                </div>
            </div>
            <div class="route-stat">
                <div class="stat-label" data-translation="roadCharges">Road Charges</div>
                <div class="stat-value">--</div>
            </div>
            <div class="route-stat">
                <div class="stat-label" data-translation="fuelCosts">Fuel costs</div>
                <div class="stat-value">--</div>
            </div>
        </div>
        <!-- Panel ustawień trasy - dodaj przed zamknięciem diva "sidebar" -->
        <div id="route-settings" class="route-settings" style="margin-top: auto; padding: 20px;">
            <h3 style="margin-bottom: 15px; font-size: 16px;" id="settings-title"></h3>
            
            <div class="row">
                <p>Wybierz pojazd:</p>
                <div class="button-group" id="vehicle-selection">
                    <!-- Przyciski będą generowane przez JavaScript -->
                </div>
            </div>

            <!-- Fifth Row: Excluded Areas -->
            <div class="row">
                <p id="excluded-areas-text"></p>
                <div class="button-group" id="excluded-areas">
                    <button data-value="CH">CH</button>
                    <button data-value="Fussen">Füssen</button>
                </div>
            </div>
        </div>
    </div>
    <div id="map-container">
        <button id="restart-button">Restart [CTRL+I]</button>
    </div>
	<script>
        let geocodedPoints = new Map();

        function getPreferredLanguage() {
            const supportedLanguages = ['de', 'fr', 'it', 'es', 'pl'];
            let browserLang = navigator.language.slice(0, 2).toLowerCase();
            return supportedLanguages.includes(browserLang) ? browserLang : 'en';
        }

        function getUITranslations(lang) {
            const translations = {
                en: {
                    inputPlaceholder: 'Enter address or GPS coordinates',
                    routeInfo: 'Route information:',
                    distance: 'Distance',
                    time: 'Time',
                    minutes: 'minutes',
                    routeError: 'An error occurred while calculating the route',
                    addressNotFound: 'Address not found',
                    geocodingError: 'Geocoding error',
                    addStartPoint: 'Add start point',
                    addViaPoint: 'Add via point',
                    addEndPoint: 'Add end point',
                    coordinates: 'Coordinates',
                    addStartFirst: 'Add start point first',
                    routeSettings: 'Route Settings',
                    defaultSettings: 'Default Settings',
                    largeVehicle: 'Large Vehicle',
                    mediumVehicle: 'Medium Vehicle',
                    smallVehicle: 'Small Vehicle',
                    vehicleWeight: 'Vehicle Weight (t)',
                    axleCount: 'Number of Axles',
                    euroClass: 'EUR Class',
                    co2Class: 'CO2 Class',
                    excludedAreas: 'Excluded Areas',
                    roadCharges: 'Road Charges',
                    noRoadCharges: 'No Road Charges',
                    withoutFerryTrainKm: 'without ferry/train km',
                    fuelCosts: 'Fuel costs',
                    consumption: 'Consumption',
                    totalFuelNeeded: 'Total fuel needed',
                    globalPrice: 'global price',
                    costPerKm: '/km',
                    fuelConsumption: 'Consumption',
                    fuelInCountry: 'Fuel in country',
                    fuel: 'Fuel',
                    selectVehicle: 'Select vehicle',
                    lowestPrice: 'Lowest price'
                },
                de: {
                    inputPlaceholder: 'Adresse oder GPS-Koordinaten eingeben',
                    routeInfo: 'Routeninformation:',
                    distance: 'Entfernung',
                    time: 'Zeit',
                    minutes: 'Minuten',
                    routeError: 'Bei der Routenberechnung ist ein Fehler aufgetreten',
                    addressNotFound: 'Adresse nicht gefunden',
                    geocodingError: 'Geokodierungsfehler',
                    addStartPoint: 'Startpunkt hinzufügen',
                    addViaPoint: 'Viapunkt hinzufügen',
                    addEndPoint: 'Endpunkt hinzufügen',
                    coordinates: 'Koordinaten',
                    addStartFirst: 'Fügen Sie zuerst den Startpunkt hinzu',
                    routeSettings: 'Routeneinstellungen',
                    defaultSettings: 'Standardeinstellungen',
                    largeVehicle: 'Großes Fahrzeug',
                    mediumVehicle: 'Mittleres Fahrzeug',
                    smallVehicle: 'Kleines Fahrzeug',
                    vehicleWeight: 'Fahrzeuggewicht (t)',
                    axleCount: 'Anzahl der Achsen',
                    euroClass: 'EUR-Klasse',
                    co2Class: 'CO2-Klasse',
                    excludedAreas: 'Ausgeschlossene Gebiete',
                    roadCharges: 'Straßengebühren',
                    noRoadCharges: 'Keine Straßengebühren',
                    withoutFerryTrainKm: 'ohne Fähre/Zug km',
                    fuelCosts: 'Kraftstoffkosten',
                    consumption: 'Verbrauch',
                    totalFuelNeeded: 'Gesamter Kraftstoffbedarf',
                    globalPrice: 'Globalpreis',
                    costPerKm: '/km',
                    fuelConsumption: 'Verbrauch',
                    fuelInCountry: 'Kraftstoff im Land',
                    fuel: 'Kraftstoff',
                    selectVehicle: 'Fahrzeug auswählen',
                    lowestPrice: 'Niedrigster Preis'
                },
                fr: {
                    inputPlaceholder: 'Entrez l\'adresse ou les coordonnées GPS',
                    routeInfo: 'Informations sur l\'itinéraire :',
                    distance: 'Distance',
                    time: 'Temps',
                    minutes: 'minutes',
                    routeError: 'Une erreur s\'est produite lors du calcul de l\'itinéraire',
                    addressNotFound: 'Adresse introuvable',
                    geocodingError: 'Erreur de géocodage',
                    addStartPoint: 'Ajouter le point de départ',
                    addViaPoint: 'Ajouter un point intermédiaire',
                    addEndPoint: 'Ajouter le point d\'arrivée',
                    coordinates: 'Coordonnées',
                    addStartFirst: 'Ajoutez d\'abord le point de départ',
                    routeSettings: 'Paramètres d\'itinéraire',
                    defaultSettings: 'Paramètres par défaut',
                    largeVehicle: 'Grand véhicule',
                    mediumVehicle: 'Véhicule moyen',
                    smallVehicle: 'Petit véhicule',
                    vehicleWeight: 'Poids du véhicule (t)',
                    axleCount: 'Nombre d\'essieux',
                    euroClass: 'Classe EUR',
                    co2Class: 'Classe CO2',
                    excludedAreas: 'Zones exclues',
                    roadCharges: 'Péages routiers',
                    noRoadCharges: 'Pas de péages',
                    withoutFerryTrainKm: 'sans km ferry/train',
                    fuelCosts: 'Coûts de carburant',
                    consumption: 'Consommation',
                    totalFuelNeeded: 'Carburant total nécessaire',
                    globalPrice: 'prix global',
                    costPerKm: '/km',
                    fuelConsumption: 'Consommation',
                    fuelInCountry: 'Carburant dans le pays',
                    fuel: 'Carburant',
                    selectVehicle: 'Sélectionner le véhicule',
                    lowestPrice: 'Prix le plus bas'
                },
                it: {
                    inputPlaceholder: 'Inserisci indirizzo o coordinate GPS',
                    routeInfo: 'Informazioni sul percorso:',
                    distance: 'Distanza',
                    time: 'Tempo',
                    minutes: 'minuti',
                    routeError: 'Si è verificato un errore durante il calcolo del percorso',
                    addressNotFound: 'Indirizzo non trovato',
                    geocodingError: 'Errore di geocodifica',
                    addStartPoint: 'Aggiungi punto di partenza',
                    addViaPoint: 'Aggiungi punto intermedio',
                    addEndPoint: 'Aggiungi punto di arrivo',
                    coordinates: 'Coordinate',
                    addStartFirst: 'Aggiungi prima il punto di partenza',
                    routeSettings: 'Impostazioni percorso',
                    defaultSettings: 'Impostazioni predefinite',
                    largeVehicle: 'Veicolo grande',
                    mediumVehicle: 'Veicolo medio',
                    smallVehicle: 'Veicolo piccolo',
                    vehicleWeight: 'Peso del veicolo (t)',
                    axleCount: 'Numero di assi',
                    euroClass: 'Classe EUR',
                    co2Class: 'Classe CO2',
                    excludedAreas: 'Aree escluse',
                    roadCharges: 'Pedaggi stradali',
                    noRoadCharges: 'Nessun pedaggio',
                    withoutFerryTrainKm: 'senza km nave/treno',
                    fuelCosts: 'Costi carburante',
                    consumption: 'Consumo',
                    totalFuelNeeded: 'Carburante totale necessario',
                    globalPrice: 'prezzo globale',
                    costPerKm: '/km',
                    fuelConsumption: 'Consumo',
                    fuelInCountry: 'Carburante nel paese',
                    fuel: 'Carburante',
                    selectVehicle: 'Seleziona veicolo',
                    lowestPrice: 'Prezzo più basso'
                },
                es: {
                    inputPlaceholder: 'Introduce la dirección o coordenadas GPS',
                    routeInfo: 'Información de la ruta:',
                    distance: 'Distancia',
                    time: 'Tiempo',
                    minutes: 'minutos',
                    routeError: 'Se produjo un error al calcular la ruta',
                    addressNotFound: 'Dirección no encontrada',
                    geocodingError: 'Error de geocodificación', 
                    addStartPoint: 'Añadir punto de inicio',
                    addViaPoint: 'Añadir punto intermedio',
                    addEndPoint: 'Añadir punto final',
                    coordinates: 'Coordenadas',
                    addStartFirst: 'Añade primero el punto de inicio',
                    routeSettings: 'Configuración de ruta',
                    defaultSettings: 'Configuración predeterminada',
                    largeVehicle: 'Vehículo grande',
                    mediumVehicle: 'Vehículo mediano',
                    smallVehicle: 'Vehículo pequeño',
                    vehicleWeight: 'Peso del vehículo (t)',
                    axleCount: 'Número de ejes',
                    euroClass: 'Clase EUR',
                    co2Class: 'Clase CO2',
                    excludedAreas: 'Áreas excluidas',
                    roadCharges: 'Peajes',
                    noRoadCharges: 'Sin peajes',
                    withoutFerryTrainKm: 'sin km de ferry/tren',
                    fuelCosts: 'Costes de combustible',
                    consumption: 'Consumo',
                    totalFuelNeeded: 'Combustible total necesario',
                    globalPrice: 'precio global',
                    costPerKm: '/km',
                    fuelConsumption: 'Consumo',
                    fuelInCountry: 'Combustible en el país',
                    fuel: 'Combustible',
                    selectVehicle: 'Seleccionar vehículo',
                    lowestPrice: 'Precio más bajo'
                },
                pl: {
                    inputPlaceholder: 'Wpisz adres lub współrzędne GPS',
                    routeInfo: 'Informacje o trasie:',
                    distance: 'Dystans',
                    time: 'Czas jazdy',
                    minutes: 'minut',
                    routeError: 'Wystąpił błąd podczas wyznaczania trasy',
                    addressNotFound: 'Nie znaleziono adresu',
                    geocodingError: 'Błąd geokodowania', 
                    addStartPoint: 'Dodaj punkt startowy',
                    addViaPoint: 'Dodaj punkt pośredni',
                    addEndPoint: 'Dodaj punkt końcowy',
                    coordinates: 'Koordynaty',
                    addStartFirst: 'Najpierw dodaj punkt startowy',
                    routeSettings: 'Ustawienia trasy',
                    defaultSettings: 'Domyślne ustawienia',
                    largeVehicle: 'Duży pojazd',
                    mediumVehicle: 'Średni pojazd',
                    smallVehicle: 'Mały pojazd',
                    vehicleWeight: 'Waga pojazdu (t)',
                    axleCount: 'Liczba osi',
                    euroClass: 'Klasa EUR',
                    co2Class: 'Klasa CO2',
                    excludedAreas: 'Wyłączone obszary',
                    roadCharges: 'Opłaty drogowe',
                    noRoadCharges: 'Brak opłat drogowych',
                    withoutFerryTrainKm: 'bez km prom/kolej',
                    fuelCosts: 'Koszty paliwa',
                    consumption: 'Spalanie',
                    totalFuelNeeded: 'Całkowite zużycie paliwa',
                    globalPrice: 'cena globalna',
                    costPerKm: '/km',
                    fuelConsumption: 'Spalanie',
                    fuelInCountry: 'Paliwo w kraju',
                    fuel: 'Paliwo',
                    selectVehicle: 'Wybierz pojazd',
                    lowestPrice: 'Najniższa cena'
                }
            };
            return translations[lang] || translations.en;
        }

        const vehicles = [
            {
                id: 'mega',
                name: 'MEGA',
                weight: 40000,
                truckAxles: 2,    
                trailerAxles: 3,
                trailerCount: 1,
                euroClass: '6',
                co2Class: '1',
                fuelConsumption: 27,
                adblueConsumption: 1.5,          
                costPerKm: 0.20,
                height: 400,
                width: 255,
                length: 1650
            },
            {
                id: 'standard',
                name: 'Standard',
                weight: 40000,
                truckAxles: 2,
                trailerAxles: 3,
                trailerCount: 1,
                euroClass: '6',
                co2Class: '1',
                fuelConsumption: 27,
                adblueConsumption: 1.5,
                costPerKm: 0.15,
                height: 400,
                width: 255,
                length: 1650
            },
            {
                id: 'jumbo',
                name: 'JUMBO',
                weight: 30000,
                truckAxles: 2,      
                trailerAxles: 1,
                trailerCount: 1,
                euroClass: '6',
                co2Class: '1',
                fuelConsumption: 24.5,
                adblueConsumption: 1.5,
                costPerKm: 0.10,
                height: 400,
                width: 255,
                length: 1750
            },
            {
                id: 'solo',
                name: 'Solo',
                weight: 8000,
                truckAxles: 2,    
                trailerAxles: 0,
                trailerCount: 0,
                euroClass: '6',
                co2Class: '1',
                fuelConsumption: 20,
                adblueConsumption: 1.5,
                costPerKm: 0.10,
                height: 350,
                width: 255,
                length: 850
            }
        ];

        const defaultFuelPrices = {
            'POL': 1.19,
            'DEU': 1.55,
            'LUX': 1.28,
            'CZE': 1.22,
            'SVK': 1.28,
            'HUN': 1.28,
            'AUT': 1.52,
            'ITA': 1.48,
            'FRA': 1.47,
            'ESP': 1.37,
            'PRT': 1.41,
            'BEL': 1.49,
            'NLD': 1.58,
            'CHE': 1.79,
            'DNK': 1.61,
            'SWE': 1.29,
            'NOR': 1.46,
            'FIN': 1.43,
            'EST': 1.27,
            'LVA': 1.31,
            'LTU': 1.36,
            'ROU': 1.28,
            'BGR': 1.12,
            'GRC': 1.58,
            'HRV': 1.15,
            'SVN': 1.31,
            'SRB': 1.41,
            'MKD': 1.42,
            'BIH': 1.29,
            'MNE': 1.45,
            'ALB': 1.42,
            'adblue': 0.65,  // domyślna cena AdBlue dla wszystkich krajów
        };

        const companyCosts = {
            fixedCostsPerHour: 50,
            variableCostsPerKm: 0.5,
            useLowestFuelPrice: true,
            useCustomFuelPrices: false,
            globalFuelPrice: 1.35,
            globalAdBluePrice: 0.65,
            customFuelPrices: {
                'POL': 1.32,
                'DEU': 1.46,
                'CZE': 1.42,
                'ESP': 1.35,
                'AUT': 1.4,
            }
        };




        const currentLang = getPreferredLanguage();
        const translations = getUITranslations(currentLang);
        const API_KEY = 'yuwY_LTItp881XAaYOHShjcBhdc0sHWuj4TQwGKwjms';
        
        const MANUAL_TOLL_SYSTEMS = {
            'TRAFORO DEL MONTE BIANCO': {
                checkLocation: null,
                displayName: 'Mont Bianc IT→FR'
            },
            'ATMB': {
                checkLocation: 'TUNNEL DU MONT-BLANC',
                displayName: 'Mont Bianc FR→IT'
            },
            'SITAF S.P.A.': {
                checkLocation: 'Bardonecchia',
                displayName: 'Frejus IT→FR'
            },
            'SFTRF': {
                checkLocation: 'TUNNEL DU FREJUS',
                displayName: 'Frejus FR→IT'
            }
        };

        ///LICZNIK ZAPYTAŃ
        const apiMonitor = new class APIMonitor {
            constructor() {
                this.endpoint = 'https://script.google.com/macros/s/AKfycbxBxX2x9tXlLxrXh6KrSVDdaEQZGfmtnncRMvZhd4yTL_bUwPcqFtHHSMUwIHlbDq-1/exec';
                this.testerId = this.getOrCreateTesterId();
            }

            getOrCreateTesterId() {
                let id = localStorage.getItem('testerId');
                if (!id) {
                    id = 'tester_' + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem('testerId', id);
                }
                return id;
            }

            logRequest(type) {
                fetch(this.endpoint, {
                    method: 'POST',
                    mode: 'no-cors',
                    body: JSON.stringify({
                        type: type,
                        testerId: this.testerId
                    })
                });
            }
        }();

        ///KONIEC LICZNIKA ZAPYTAŃ



        function isGPSCoordinates(text) {
            const cleanText = text.trim();
            
            const patterns = {
                decimal: /^(-?\d+\.?\d*),\s*(-?\d+\.?\d*)$/,
                dms: /^(-?\d+)°(\d+)'(\d+(\.\d+)?)"([NS])\s*(-?\d+)°(\d+)'(\d+(\.\d+)?)"([EW])$/
            };
            
            const decimalMatch = cleanText.match(patterns.decimal);
            if (decimalMatch) {
                const lat = parseFloat(decimalMatch[1]);
                const lng = parseFloat(decimalMatch[2]);
                return isValidLatLng(lat, lng) ? { lat, lng } : null;
            }
            
            const dmsMatch = cleanText.match(patterns.dms);
            if (dmsMatch) {
                const lat = convertDMSToDecimal(
                    parseFloat(dmsMatch[1]),
                    parseFloat(dmsMatch[2]),
                    parseFloat(dmsMatch[3]),
                    dmsMatch[5]
                );
                const lng = convertDMSToDecimal(
                    parseFloat(dmsMatch[6]),
                    parseFloat(dmsMatch[7]),
                    parseFloat(dmsMatch[8]),
                    dmsMatch[10]
                );
                return isValidLatLng(lat, lng) ? { lat, lng } : null;
            }
            
            return null;
        }

        function isValidLatLng(lat, lng) {
            return lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
        }

        function convertDMSToDecimal(degrees, minutes, seconds, direction) {
            let decimal = degrees + (minutes / 60) + (seconds / 3600);
            if (direction === 'S' || direction === 'W') {
                decimal = -decimal;
            }
            return decimal;
        }

        const platform = new H.service.Platform({
            apikey: API_KEY
        });

        const customTileProvider = new H.map.provider.ImageTileProvider({
            getURL: (x, y, z) => {
                // Determine PPI based on screen resolution
                const screenWidth = window.screen.width * window.devicePixelRatio;
                const ppi = screenWidth >= 2560 ? 200 : 200;
                
                // Select map style based on zoom level
                const mapStyle = z > 9 ? 'logistics.day' : 'explore.day';
                
                // Base URL with dynamic PPI
                let url = `https://maps.hereapi.com/v3/base/mc/${z}/${x}/${y}/png8?xnlp=CL_JSMv3.1.61.1` +
                        `&apikey=${API_KEY}` +
                        `&style=${mapStyle}` +
                        `&size=512` +
                        `&lang=${currentLang}` +
                        `&ppi=${ppi}`;
                
                // Add features for logistics.day style
                if (mapStyle === 'logistics.day') {
                    url += '&features=vehicle_restrictions:active_and_inactive,pois:disabled,congestion_zones:all';
                }
                
                return url;
            }
        });

        const customTileLayer = new H.map.layer.TileLayer(customTileProvider);
        const map = new H.Map(
            document.getElementById('map-container'),
            customTileLayer,
            {
                tileSize: 512,
                pixelRatio: window.devicePixelRatio *1.2|| 1,
                zoom: 5.5,
                center: { lat: 50.0, lng: 15.0 },
                renderBaseBackground: true, // Dodajemy tło podczas ładowania
            }
        );

        window.addEventListener('resize', () => {
            map.getViewPort().resize();
        });

        const ui = new H.ui.UI(map, {
            zoom: new H.ui.ZoomControl()
        });

        // Pobierz kontrolkę zoom i ustaw jej wyrównanie
        const zoomControl = ui.getControl('zoom');
        if (zoomControl) {
            zoomControl.setAlignment('bottom-right');
        }
        const mapEvents = new H.mapevents.MapEvents(map);
        const behavior = new H.mapevents.Behavior(mapEvents);
        

        // FUNCJE DO MENU KONTEKSTOWEGO (START/VIA/KONIEC)    
        // Functions for handling waypoints from context menu
        function addStartPoint(coordinates) {
            const waypointsContainer = document.getElementById('waypoints-container');
            const waypointContainers = waypointsContainer.querySelectorAll('.waypoint-container');
            
            // Create new waypoint
            const newWaypoint = createWaypointInput();
            const input = newWaypoint.querySelector('.waypoint');
            input.value = `${coordinates.lat.toFixed(6)}, ${coordinates.lng.toFixed(6)}`;

            // Always insert as first point
            if (waypointContainers.length > 0) {
                waypointsContainer.insertBefore(newWaypoint, waypointContainers[0]);
            } else {
                waypointsContainer.appendChild(newWaypoint);
            }

            input.dispatchEvent(new Event('input'));
            updateWaypointNumbers();
        }

        function addViaPoint(coordinates) {
            const waypointsContainer = document.getElementById('waypoints-container');
            const waypointContainers = waypointsContainer.querySelectorAll('.waypoint-container');
            
            if (waypointContainers.length === 0) {
                alert(translations.addStartFirst);
                return;
            }

            // Create new waypoint
            const newWaypoint = createWaypointInput();
            const input = newWaypoint.querySelector('.waypoint');
            input.value = `${coordinates.lat.toFixed(6)}, ${coordinates.lng.toFixed(6)}`;

            // Znajdź wszystkie niepuste punkty
            const nonEmptyContainers = Array.from(waypointContainers).filter(container => 
                container.querySelector('.waypoint').value.trim() !== ''
            );

            if (nonEmptyContainers.length === 1) {
                // Jeśli mamy tylko punkt startowy, dodaj po nim
                const secondContainer = waypointContainers[1];
                waypointsContainer.insertBefore(newWaypoint, secondContainer || null);
            } else if (nonEmptyContainers.length >= 2) {
                // Dodaj przed ostatnim niepustym punktem
                const lastContainer = nonEmptyContainers[nonEmptyContainers.length - 1];
                waypointsContainer.insertBefore(newWaypoint, lastContainer);
            } else {
                waypointsContainer.appendChild(newWaypoint);
            }

            input.dispatchEvent(new Event('input'));
            updateWaypointNumbers();
        }

        function addEndPoint(coordinates) {
            const waypointsContainer = document.getElementById('waypoints-container');
            const waypointContainers = waypointsContainer.querySelectorAll('.waypoint-container');
            
            if (waypointContainers.length === 0) {
                alert(translations.addStartFirst);
                return;
            }

            // Create new waypoint
            const newWaypoint = createWaypointInput();
            const input = newWaypoint.querySelector('.waypoint');
            input.value = `${coordinates.lat.toFixed(6)}, ${coordinates.lng.toFixed(6)}`;

            // In case of only one existing point (start point), add end point directly after it
            if (waypointContainers.length === 1) {
                waypointsContainer.appendChild(newWaypoint);
            } else {
                // For more points, add before the last empty container
                const lastContainer = waypointContainers[waypointContainers.length - 1];
                const lastInput = lastContainer.querySelector('.waypoint');
                
                if (lastInput && lastInput.value.trim() === '') {
                    waypointsContainer.insertBefore(newWaypoint, lastContainer);
                } else {
                    waypointsContainer.appendChild(newWaypoint);
                }
            }

            input.dispatchEvent(new Event('input'));
            updateWaypointNumbers();
        }


        // LISTENER NA PRAWY PRZYCISK MYSZY!
        // Add map right click handler
        map.addEventListener('pointerdown', (evt) => {
        // Check if it's right mouse button
        if (evt.currentPointer.button === 2) {
            // Prevent default browser's context menu
            evt.originalEvent.preventDefault();
            
            // Remove any existing menu before creating new one
            document.querySelectorAll('.context-menu').forEach(menu => menu.remove());
            
            const coordinates = map.screenToGeo(
                evt.currentPointer.viewportX,
                evt.currentPointer.viewportY
            );
            
            // Create a temporary div for our custom context menu
            const menuDiv = document.createElement('div');
            menuDiv.className = 'context-menu';
            menuDiv.style.position = 'fixed'; // Zmiana z 'absolute' na 'fixed'
            
            // Pobieramy pozycję kliknięcia względem strony
            const x = evt.originalEvent.pageX;
            const y = evt.originalEvent.pageY;
            
            menuDiv.style.left = x + 'px';
            menuDiv.style.top = y + 'px';
            menuDiv.style.backgroundColor = 'white';
            menuDiv.style.border = '1px solid #ddd';
            menuDiv.style.borderRadius = '4px';
            menuDiv.style.padding = '5px';
            menuDiv.style.zIndex = '1000';
            menuDiv.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';

            // Create menu items
            const menuItems = [
                { text: translations.addStartPoint, action: () => addStartPoint(coordinates) },
                { text: translations.addViaPoint, action: () => addViaPoint(coordinates) },
                { text: translations.addEndPoint, action: () => addEndPoint(coordinates) },
                { text: `${translations.coordinates}: ${coordinates.lat.toFixed(6)}, ${coordinates.lng.toFixed(6)}`, action: null }
            ];
            menuItems.forEach(item => {
                const menuItem = document.createElement('div');
                
                if (item.text.startsWith(translations.coordinates)) {
                    // Specjalna obsługa dla elementu z koordynatami
                    const coordsText = `${coordinates.lat.toFixed(6)}, ${coordinates.lng.toFixed(6)}`;
                    
                    menuItem.innerHTML = `
                        <div style="margin-bottom: 2px">
                            ${translations.coordinates}: 
                            <span class="coords-value" style="cursor: pointer; color: #0066CC;">${coordsText}</span>
                        </div>
                        <div class="copy-feedback" style="display: none; color: #28a745; font-size: 11px;">
                            ✓ Skopiowano
                        </div>
                    `;
                    
                    const wholeItem = menuItem;
                    const coordsSpan = menuItem.querySelector('.coords-value');
                    const feedbackSpan = menuItem.querySelector('.copy-feedback');
                    
                    // Dodaj obsługę kliknięcia na cały element
                    wholeItem.style.cursor = 'pointer';
                    wholeItem.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        
                        try {
                            await navigator.clipboard.writeText(coordsText); // Kopiujemy tylko same koordynaty
                            
                            feedbackSpan.style.display = 'block';
                            
                            setTimeout(() => {
                                feedbackSpan.style.display = 'none';
                            }, 2000);
                        } catch (err) {
                            console.error('Failed to copy coordinates:', err);
                            
                            const textArea = document.createElement('textarea');
                            textArea.value = coordsText;
                            document.body.appendChild(textArea);
                            textArea.select();
                            try {
                                document.execCommand('copy');
                                feedbackSpan.style.display = 'block';
                                setTimeout(() => {
                                    feedbackSpan.style.display = 'none';
                                }, 2000);
                            } catch (err) {
                                console.error('Fallback copy failed:', err);
                            }
                            document.body.removeChild(textArea);
                        }
                    });
                    
                    menuItem.style.padding = '8px 12px';
                    menuItem.style.color = '#666';
                    menuItem.style.fontSize = '12px';
                    
                } else {
                    // Standardowa obsługa dla pozostałych elementów menu
                    menuItem.textContent = item.text;
                    menuItem.style.padding = '8px 12px';
                    menuItem.style.cursor = item.action ? 'pointer' : 'default';
                    menuItem.style.borderBottom = '1px solid #eee';
                    
                    if (item.action) {
                        menuItem.addEventListener('mouseover', () => {
                            menuItem.style.backgroundColor = '#f0f0f0';
                        });
                        menuItem.addEventListener('mouseout', () => {
                            menuItem.style.backgroundColor = 'white';
                        });
                        menuItem.addEventListener('click', () => {
                            item.action();
                            menuDiv.remove();
                        });
                    }
                }
                
                menuDiv.appendChild(menuItem);
            });

            document.getElementById('map-container').appendChild(menuDiv);
            
            // Sprawdzamy, czy menu nie wychodzi poza ekran
            setTimeout(() => {
                const rect = menuDiv.getBoundingClientRect();
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                
                if (rect.right > windowWidth) {
                    menuDiv.style.left = (windowWidth - rect.width) + 'px';
                }
                
                if (rect.bottom > windowHeight) {
                    menuDiv.style.top = (windowHeight - rect.height) + 'px';
                }
            }, 0);
            
            // Remove menu when clicking anywhere else
            const removeMenu = () => {
                menuDiv.remove();
                document.removeEventListener('click', removeMenu);
            };
            
            document.addEventListener('click', removeMenu);
        }
    });

        // Disable the default draggability of the underlying map
        // and enable it only when no marker is being dragged
        let isDragging = false;

        map.addEventListener('dragstart', function(ev) {
            const target = ev.target;
            if (target instanceof H.map.Marker) {
                isDragging = true;
                // Disable the default draggability of the underlying map
                // when starting to drag a marker
                behavior.disable();
            }
        });

        map.addEventListener('drag', function(ev) {
            const target = ev.target;
            if (target instanceof H.map.Marker && isDragging) {
                const pointer = ev.currentPointer;
                target.setGeometry(map.screenToGeo(pointer.viewportX, pointer.viewportY));
            }
        });

        map.addEventListener('dragend', function(ev) {
            const target = ev.target;
            if (target instanceof H.map.Marker && isDragging) {
                isDragging = false;
                behavior.enable();
                
                const newPosition = target.getGeometry();
                const markerId = target.getData().id;
                
                const waypoints = document.querySelectorAll('.waypoint');
                const waypointInput = waypoints[markerId - 1];
                
                if (waypointInput) {
                    fetch(
                        `https://revgeocode.search.hereapi.com/v1/revgeocode` +
                        `?at=${newPosition.lat},${newPosition.lng}` +
                        `&limit=1` +
                        `&lang=${currentLang}` +
                        `&apiKey=${API_KEY}`
                    )
                    .then(response => response.json())
                    .then(data => {
                        if (data.items && data.items.length > 0) {
                            const address = data.items[0].title;
                            waypointInput.value = address;
                            geocodedPoints.set(address, {
                                lat: newPosition.lat,
                                lng: newPosition.lng,
                                address: address
                            });
                            calculateRouteIfPossible();
                        }
                    })
                    .catch(error => {
                        console.error('Reverse geocoding error:', error);
                    });
                }
            }
        });

        // Prevent the default draggability of the underlying map
        // when starting to drag a marker
        map.addEventListener('pointerdown', function(ev) {
            if (ev.target instanceof H.map.Marker) {
                behavior.disable();
            }
        }, false);

        // Re-enable the default draggability of the underlying map
        // after dragging is finished
        map.addEventListener('pointerup', function(ev) {
            if (ev.target instanceof H.map.Marker) {
                behavior.enable();
            }
        }, false);

        let currentRouteIndex = 0; // indeks aktualnie wybranej trasy
        let routeLines = [];
        let markers = [];
        let debounceTimer;
        let isOverHandle = false;
        let hideHandleTimeout;
		
        async function geocodeAddress(address) {
            if (geocodedPoints.has(address.trim())) {
                return geocodedPoints.get(address.trim());
            }

            apiMonitor.logRequest('geocoding');
            const gpsCoords = isGPSCoordinates(address);
            
            if (gpsCoords) {
                // Tylko dla ręcznie wpisanych współrzędnych GPS
                try {
                    const response = await fetch(
                        `https://revgeocode.search.hereapi.com/v1/revgeocode` +
                        `?at=${gpsCoords.lat},${gpsCoords.lng}` +
                        `&limit=1` +
                        `&lang=${currentLang}` +
                        `&apiKey=${API_KEY}`
                    );
                    
                    if (!response.ok) {
                        throw new Error(translations.geocodingError);
                    }
                    
                    const data = await response.json();
                    
                    if (data.items && data.items.length > 0) {
                        return {
                            lat: gpsCoords.lat,
                            lng: gpsCoords.lng,
                            address: data.items[0].title
                        };
                    }
                } catch (error) {
                    console.error('Reverse geocoding error:', error);
                    return { lat: gpsCoords.lat, lng: gpsCoords.lng };
                }
            } else {
                return new Promise((resolve, reject) => {
                    const service = platform.getSearchService();
                    service.geocode({
                        q: address,
                        limit: 1
                    }, (result) => {
                        if (result.items && result.items.length > 0) {
                            const addressInfo = result.items[0].address;
                            
                            // Tworzymy część adresu z ulicą i numerem
                            let streetPart = '';
                            if (addressInfo.street) {
                                streetPart = addressInfo.street;
                                if (addressInfo.houseNumber) {
                                    streetPart += ' ' + addressInfo.houseNumber;
                                }
                            }
                            
                            const formattedAddress = [
                                addressInfo.postalCode,
                                addressInfo.city,
                                addressInfo.countryCode,
                                streetPart
                            ].filter(Boolean).join(', ');

                            resolve({
                                lat: result.items[0].position.lat,
                                lng: result.items[0].position.lng,
                                address: formattedAddress
                            });
                        } else {
                            reject(new Error(translations.addressNotFound));
                        }
                    }, (error) => {
                        console.error('Geocoding error:', error);
                        reject(new Error(translations.geocodingError));
                    });
                });
            }
        }

        function updateWaypointNumbers() {
            const containers = document.querySelectorAll('.waypoint-container');
            containers.forEach((container, index) => {
                const numberDiv = container.querySelector('.waypoint-number');
                if (numberDiv) {
                    numberDiv.textContent = (index + 1).toString();
                }
            });
        }

        function addMarker(position, number) {
            const svgMarkup = '<svg width="48" height="48" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">' +
                '<circle cx="12" cy="21" r="2.5" fill="white" stroke="black" stroke-width="1"/>' + // dodana biała kropka na dole
                '<path fill="#0F52BA" d="M12 2.5c-3.8 0-7 3.2-7 7.1 0 5.4 7 11.9 7 11.9s7-6.5 7-11.9c0-3.9-3.2-7.1-7-7.1z" />' +
                '<circle cx="12" cy="9" r="4" fill="#FFFFFF"/>' +
                '<text x="12" y="11" font-size="6" font-family="Arial" font-weight="bold" text-anchor="middle" fill="#0066CC">' + 
                number + '</text>' +
                '</svg>';

            const icon = new H.map.Icon(svgMarkup, {
                anchor: { x: 24, y: 48 }
            });
            
            const marker = new H.map.Marker(position, {
                icon: icon,
                volatility: true,
                draggable: true,
                data: { id: number }
            });

            marker.draggable = true;
            
            markers.push(marker);
            map.addObject(marker);
            return marker;
        }


        let routeBubbles = [];
        function clearMap() {
            try {
                // Clear existing InfoBubbles
                routeBubbles.forEach(bubble => {
                    if (bubble && bubble.close) {
                        bubble.close();
                    }
                });
                routeBubbles = [];
                
                // Clear routes and markers
                routeLines.forEach(line => {
                    if (line && typeof line.dispose === 'function') {
                        line.dispose();
                    }
                    if (line && map.getObjects().includes(line)) {
                        map.removeObject(line);
                    }
                });
                routeLines = [];
                
                markers.forEach(marker => {
                    if (marker && typeof marker.dispose === 'function') {
                        marker.dispose();
                    }
                    if (marker && map.getObjects().includes(marker)) {
                        map.removeObject(marker);
                    }
                });
                markers = [];
                
                // Reset route info to default values
                document.querySelectorAll('#route-info .stat-value').forEach(element => {
                    element.textContent = '--';
                });

                // Ukryj wskaźniki odległości
                document.querySelectorAll('.distance-indicator').forEach(indicator => {
                    indicator.classList.remove('visible');
                    indicator.textContent = '↓ -- km';
                });
                
            } catch (error) {
                console.error('Error clearing map:', error);
            }
        }

        // Drag & Drop handlers
        // Zmienne globalne dla obsługi przeciągania
        let draggedElement = null;
        let initialY = 0;
        let currentY = 0;
        let offsetY = 0;

        // Główne funkcje obsługi przeciągania
        function handleDragStart(e) {
            if (!e.target.classList.contains('waypoint-number')) {
                return;
            }
            e.preventDefault();
            
            draggedElement = this.parentElement;
            const rect = draggedElement.getBoundingClientRect();
            initialY = e.clientY;
            offsetY = e.clientY - rect.top;
            
            draggedElement.style.setProperty('--y', '0px');
            draggedElement.classList.add('dragging');
            draggedElement.style.width = `${rect.width}px`;
            draggedElement.style.left = `${rect.left}px`;
            draggedElement.originalIndex = Array.from(draggedElement.parentNode.children).indexOf(draggedElement);
            
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', handleDragEnd);
        }

        function handleDrag(e) {
            if (!draggedElement) return;
            e.preventDefault();
            
            currentY = e.clientY;
            const deltaY = currentY - initialY;
            draggedElement.style.setProperty('--y', `${deltaY}px`);
            
            const containers = Array.from(document.querySelectorAll('.waypoint-container:not(.dragging)'));
            const draggedRect = draggedElement.getBoundingClientRect();
            const draggedCenter = draggedRect.top + draggedRect.height / 2;
            
            // Reset all shifts first
            containers.forEach(container => {
                container.classList.remove('shift-down');
            });
            
            // Find the first container we're above
            const targetIndex = containers.findIndex(container => {
                const rect = container.getBoundingClientRect();
                return draggedCenter < (rect.top + rect.height / 2);
            });
            
            if (targetIndex !== -1) {
                // Shift all containers from this index down
                containers.slice(targetIndex).forEach(container => {
                    container.classList.add('shift-down');
                });
            }
        }
        function handleDragEnd(e) {
            if (!draggedElement) return;
            
            document.removeEventListener('mousemove', handleDrag);
            document.removeEventListener('mouseup', handleDragEnd);
            
            const containers = document.querySelectorAll('.waypoint-container');
            containers.forEach(container => {
                container.classList.remove('shift-up', 'shift-down');
            });
            
            const draggedRect = draggedElement.getBoundingClientRect();
            const targetContainer = Array.from(containers).find(container => {
                if (container === draggedElement) return false;
                const rect = container.getBoundingClientRect();
                return draggedRect.top + draggedRect.height / 2 < rect.top + rect.height / 2;
            });
            
            if (targetContainer) {
                targetContainer.parentNode.insertBefore(draggedElement, targetContainer);
            } else {
                const lastContainer = containers[containers.length - 1];
                lastContainer.parentNode.insertBefore(draggedElement, lastContainer.nextSibling);
            }
            
            draggedElement.classList.remove('dragging');
            draggedElement.style.removeProperty('--y');
            draggedElement.style.removeProperty('width');
            draggedElement.style.removeProperty('left');
            
            // Sprawdź czy ostatnie pole jest puste
            const allWaypoints = document.querySelectorAll('.waypoint');
            const lastWaypoint = allWaypoints[allWaypoints.length - 1];
            
            if (lastWaypoint && lastWaypoint.value.trim() !== '' && allWaypoints.length < 15) {
                const waypointsContainer = document.getElementById('waypoints-container');
                waypointsContainer.appendChild(createWaypointInput());
            }
            
            updateWaypointNumbers();
            updateRemoveButtons();
            calculateRouteIfPossible();
            
            draggedElement = null;
        }

        // Zmiana w event listenerach
        document.addEventListener('mousemove', handleDrag);
        document.addEventListener('mouseup', handleDragEnd);



        function updateRemoveButtons() {
            const containers = document.querySelectorAll('.waypoint-container');
            
            containers.forEach((container, index) => {
                // Usuń istniejący przycisk usuwania (jeśli istnieje)
                const existingButton = container.querySelector('.remove-waypoint');
                if (existingButton) {
                    existingButton.remove();
                }
                
                // Sprawdź czy to ostatnie puste pole
                const isLastEmpty = index === containers.length - 1 && 
                                container.querySelector('.waypoint').value.trim() === '';
                
                // Sprawdź czy to jedyne pole
                const isOnlyField = containers.length === 1;
                
                // Dodaj przycisk usuwania jeśli:
                // - nie jest to jedyne pole AND
                // - nie jest to ostatnie puste pole
                if (!isOnlyField && !isLastEmpty) {
                    const removeButton = document.createElement('button');
                    removeButton.className = 'remove-waypoint';
                    removeButton.textContent = '×';
                    removeButton.onclick = () => {
                        const input = container.querySelector('.waypoint');
                        if (input && input.value) {
                            geocodedPoints.delete(input.value.trim());
                        }
                        container.remove();
                        updateWaypointNumbers();
                        updateRemoveButtons();
                        clearMap();
                        setTimeout(() => {
                            calculateRouteIfPossible();
                        }, 0);
                    };
                    container.appendChild(removeButton);
                }
            });
        }

        function createWaypointInput() {
            const container = document.createElement('div');
            container.className = 'waypoint-container';
            
            const numberDiv = document.createElement('div');
            numberDiv.className = 'waypoint-number';
            numberDiv.addEventListener('mousedown', handleDragStart);
            container.appendChild(numberDiv);
            
            const box = document.createElement('div');
            box.className = 'waypoint-box';
            
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'waypoint';
            input.placeholder = translations.inputPlaceholder;

            // Dodajemy nowy event listener na kliknięcie
            input.addEventListener('click', function(e) {
                this.select(); // To zaznaczy cały tekst w polu
            });

            const suggestionsContainer = document.createElement('div');
            suggestionsContainer.className = 'suggestions-container';
            
            // Sprawdź aktualną liczbę kontenerów
            const waypointsContainer = document.getElementById('waypoints-container');
            const existingContainers = waypointsContainer.querySelectorAll('.waypoint-container');
            const isFirstContainer = existingContainers.length === 0;
            const willBeLastContainer = container === existingContainers[existingContainers.length - 1];

            // Dodaj przycisk usuwania dla wszystkich pól oprócz pierwszego i ostatniego pustego
            if (!isFirstContainer && !willBeLastContainer) {
                const removeButton = document.createElement('button');
                removeButton.className = 'remove-waypoint';
                removeButton.textContent = '×';
                removeButton.onclick = () => {
                    const input = container.querySelector('.waypoint');
                    if (input && input.value) {
                        geocodedPoints.delete(input.value.trim());
                    }
                    
                    clearMap();
                    container.remove();
                    updateWaypointNumbers();
                    
                    setTimeout(() => {
                        calculateRouteIfPossible();
                    }, 0);
                };
                container.appendChild(removeButton);
            }
            
            box.appendChild(input);
            container.appendChild(box);
            container.appendChild(suggestionsContainer);

            // Dodaj wskaźnik odległości jako część kontenera
            const distanceIndicator = document.createElement('div');
            distanceIndicator.className = 'distance-indicator';
            distanceIndicator.innerHTML = '<span class="arrow">↓</span> -- km';
            container.appendChild(distanceIndicator);

            initializeAutocomplete(input, suggestionsContainer);
            updateWaypointNumbers();
            updateRemoveButtons();
            return container;
        }

        async function lookupPlace(hereId) {
            try {
                apiMonitor.logRequest('lookup');
                const response = await fetch(
                    `https://lookup.search.hereapi.com/v1/lookup` +
                    `?id=${encodeURIComponent(hereId)}` +
                    `&lang=${currentLang}` +
                    `&apiKey=${API_KEY}`
                );

                if (!response.ok) {
                    throw new Error(translations.geocodingError);
                }

                const data = await response.json();
                if (data) {
                    // Tworzymy sformatowany adres z poszczególnych części
                    const addressInfo = data.address;
                    const formattedAddress = [
                        addressInfo.postalCode,
                        addressInfo.city,
                        addressInfo.countryCode,
                        // Dodajemy część z ulicą jeśli istnieje
                        addressInfo.street ? (addressInfo.street + (addressInfo.houseNumber ? ' ' + addressInfo.houseNumber : '')) : ''
                    ].filter(Boolean).join(', ');

                    return {
                        lat: data.position.lat,
                        lng: data.position.lng,
                        address: formattedAddress
                    };
                }
                throw new Error(translations.addressNotFound);
            } catch (error) {
                console.error('Lookup error:', error);
                throw error;
            }
        }

        
        function initializeAutocomplete(input, suggestionsContainer) {
            let searchTimeout;
            let selectedIndex = -1;
            let suggestions = [];

            input.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                const query = input.value.trim();
                
                const gpsCoords = isGPSCoordinates(query);
                
                if (gpsCoords) {
                    suggestionsContainer.style.display = 'none';
                    selectedIndex = -1;
                    calculateRouteIfPossible();
                    return;
                }
                
                if (query.length >= 3) {
                    searchTimeout = setTimeout(async () => {
                        try {
                            apiMonitor.logRequest('autosuggest');
                            const response = await fetch(
                                `https://autocomplete.search.hereapi.com/v1/autocomplete` +
                                `?apiKey=${API_KEY}` +
                                `&q=${encodeURIComponent(query)}` +
                                `&in=countryCode:AND,ALB,AUT,BIH,BEL,BGR,BLR,CHE,CYP,CZE,DEU,DNK,EST,ESP,FIN,FRO,FRA,GBR,GIB,GRC,HRV,HUN,IRL,IMN,ISL,ITA,LIE,LTU,LUX,LVA,MCO,MDA,MNE,MKD,MLT,NLD,NOR,POL,PRT,ROU,SRB,RUS,SWE,SVN,SVK,SMR,TUR,UKR,VAT,KOS` +
                                `&limit=5` +
                                `&lang=${currentLang}`
                            );
                            
                            const data = await response.json();
                            suggestionsContainer.innerHTML = '';
                            suggestions = data.items || [];

                            if (suggestions.length > 0) {
                                selectedIndex = 0;
                                
                                suggestions.forEach((item, index) => {
                                    const div = document.createElement('div');
                                    div.className = 'suggestion-item';
                                    if (index === 0) {
                                        div.classList.add('selected');
                                    }
                                    div.textContent = item.title;
                                    // Dodajemy HERE ID jako data-atrybut
                                    div.dataset.hereId = item.id;
                                    
                                    div.addEventListener('click', () => {
                                        selectSuggestion(item, input);
                                    });
                                    
                                    suggestionsContainer.appendChild(div);
                                });
                                suggestionsContainer.style.display = 'block';
                            } else {
                                suggestionsContainer.style.display = 'none';
                                selectedIndex = -1;
                            }
                        } catch (error) {
                            console.error('Autosuggest error:', error);
                            suggestionsContainer.style.display = 'none';
                            selectedIndex = -1;
                        }
                    }, 300);
                } else {
                    suggestionsContainer.style.display = 'none';
                    selectedIndex = -1;
                }
            });

            input.addEventListener('keydown', (e) => {
                const query = input.value.trim();
                const gpsCoords = isGPSCoordinates(query);
                const suggestionItems = suggestionsContainer.querySelectorAll('.suggestion-item');
                
                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        if (!gpsCoords && selectedIndex < suggestionItems.length - 1) {
                            selectedIndex++;
                            updateSelection(suggestionItems);
                        }
                        break;
                        
                    case 'ArrowUp':
                        e.preventDefault();
                        if (!gpsCoords && selectedIndex > 0) {
                            selectedIndex--;
                            updateSelection(suggestionItems);
                        }
                        break;
                        
                    case 'Enter':
                        e.preventDefault();
                        if (gpsCoords) {
                            handleGPSEntry(input);
                        } else if (suggestionsContainer.style.display === 'block' && selectedIndex >= 0 && suggestions[selectedIndex]) {
                            selectSuggestion(suggestions[selectedIndex], input);
                        }
                        break;
                        
                    case 'Escape':
                        suggestionsContainer.style.display = 'none';
                        selectedIndex = -1;
                        break;
                }
            });

            function updateSelection(items) {
                items.forEach((item, index) => {
                    item.classList.toggle('selected', index === selectedIndex);
                });
            }

            function handleGPSEntry(input) {
                const waypoints = document.querySelectorAll('.waypoint');
                const currentIndex = Array.from(waypoints).indexOf(input);
                const lastWaypoint = waypoints[waypoints.length - 1];
                
                // Dodaj warunek sprawdzający limit
                if (input === lastWaypoint && waypoints.length < 15) {
                    const waypointsContainer = document.getElementById('waypoints-container');
                    waypointsContainer.appendChild(createWaypointInput());
                }
                
                setTimeout(() => {
                    const updatedWaypoints = document.querySelectorAll('.waypoint');
                    const nextInput = updatedWaypoints[currentIndex + 1];
                    if (nextInput) {
                        nextInput.focus();
                    }
                }, 50);

                calculateRouteIfPossible();
            }

            async function selectSuggestion(suggestion, input) {
                try {
                    let result;
                    if (isGPSCoordinates(suggestion.title)) {
                        result = await geocodeAddress(suggestion.title);
                    } else if (suggestion.id) {
                        result = await lookupPlace(suggestion.id);
                    } else {
                        result = await geocodeAddress(suggestion.title);
                    }

                    input.value = result.address;
                    geocodedPoints.set(input.value.trim(), result);
                    
                    const suggestionsContainer = input.parentElement.nextElementSibling;
                    suggestionsContainer.style.display = 'none';

                    const waypoints = document.querySelectorAll('.waypoint');
                    const currentIndex = Array.from(waypoints).indexOf(input);
                    const nextInput = waypoints[currentIndex + 1];
                    const lastWaypoint = waypoints[waypoints.length - 1];

                    // Dodaj nowe pole tylko jeśli jesteśmy na ostatnim i mamy miejsce
                    if (input === lastWaypoint && waypoints.length < 15) {
                        const waypointsContainer = document.getElementById('waypoints-container');
                        waypointsContainer.appendChild(createWaypointInput());
                    }

                    // Przenieś focus do następnego pola tylko jeśli jest puste
                    setTimeout(() => {
                        if (nextInput && nextInput.value.trim() === '') {
                            nextInput.focus();
                        }
                    }, 50);

                    calculateRouteIfPossible();
                } catch (error) {
                    console.error('Error processing suggestion:', error);
                }
            }

            input.addEventListener('click', function(e) {
                this.select(); // To zaznaczy cały tekst w polu
                // Nie wywołujemy tutaj żadnych dodatkowych eventów
            });
            
            document.addEventListener('click', (e) => {
                if (!input.contains(e.target) && !suggestionsContainer.contains(e.target)) {
                    suggestionsContainer.style.display = 'none';
                    selectedIndex = -1;
                }
            });
        }

        let allRoutes = [];
        let currentRouteCalculation = null;

        async function calculateRouteIfPossible() {
            try {
                
                // Anuluj poprzednie przeliczanie trasy
                if (currentRouteCalculation) {
                    currentRouteCalculation.abort();
                }
                
                // Utwórz nowy kontroler dla tego przeliczenia
                currentRouteCalculation = new AbortController();
                const signal = currentRouteCalculation.signal;    


                const waypointInputs = Array.from(document.querySelectorAll('.waypoint'))
                    .map(input => ({
                        element: input.parentElement,
                        value: input.value.trim()
                    }))
                    .filter(wp => wp.value !== '');

                clearMap();

                // Check if we have exactly 2 waypoints - delete this line and change alternatives to 1 to remove fature to check if only 2 points to show alternative
                const shouldRequestAlternatives = waypointInputs.length === 2;

                // Handle single waypoint case
                if (waypointInputs.length === 1) {
                    const result = await geocodeAddress(waypointInputs[0].value);
                    addMarker({ lat: result.lat, lng: result.lng }, 1);
                    
                    const input = waypointInputs[0].element.querySelector('.waypoint');
                    if (result.address) {
                        input.value = result.address;
                        geocodedPoints.set(input.value.trim(), result);
                    }

                    map.setCenter({ lat: result.lat, lng: result.lng });
                    map.setZoom(7);
                    return;
                }

                if (waypointInputs.length < 2) {
                    return;
                }
                const geoResults = await Promise.all(
                    waypointInputs.map(async wp => {
                        if (geocodedPoints.has(wp.value)) {
                            return geocodedPoints.get(wp.value);
                        }
                        const result = await geocodeAddress(wp.value);
                        geocodedPoints.set(wp.value, result);
                        return result;
                    })
                );
                apiMonitor.logRequest('routing');    
                geoResults.forEach((result, index) => {
                    addMarker({ lat: result.lat, lng: result.lng }, index + 1);
                    
                    const box = waypointInputs[index].element;
                    const container = box.closest('.waypoint-container');
                    const input = box.querySelector('.waypoint');
                    
                    if (result.address) {
                        input.value = result.address;
                        geocodedPoints.set(input.value.trim(), result);
                    }
                    
                    const numberDiv = container.querySelector('.waypoint-number');
                    numberDiv.textContent = (index + 1).toString();
                });

                const origin = { lat: geoResults[0].lat, lng: geoResults[0].lng };
                const destination = { 
                    lat: geoResults[geoResults.length - 1].lat, 
                    lng: geoResults[geoResults.length - 1].lng 
                };
                const viaPoints = geoResults.slice(1, -1).map(result => ({
                    lat: result.lat,
                    lng: result.lng
                }));

                // Get vehicle parameters
                // Get vehicle parameters
                const vehicleParams = getVehicleParameters();

                // Check excluded areas
                const excludedAreas = [];
                const excludedButtons = document.querySelectorAll('#excluded-areas button.active');

                excludedButtons.forEach(button => {
                    if (button.dataset.value === 'CH') {
                        excludedAreas.push('CHE'); // Country code for Switzerland
                    } else if (button.dataset.value === 'Fussen') {
                        excludedAreas.push({
                            type: 'bbox',
                            west: 10.503569952001044,
                            south: 47.40623942387259,
                            east: 10.88272284357322,
                            north: 47.648267570933086
                        });
                    }
                });

                // Construct route URL with exclusions
                let routeUrl = `https://router.hereapi.com/v8/routes` +
                    `?xnlp=CL_JSMv3.1.61.1` +
                    `&apiKey=${API_KEY}` +
                    `&transportMode=truck` +
                    `&routingMode=fast` +
                    `&units=metric` +
                    `&lang=${currentLang}` +
                    `&currency=EUR` +
                    `&alternatives=${shouldRequestAlternatives ? '1' : '0'}` + 
                    `&spans=tollSystems,truckAttributes,countryCode,length,routeNumbers,notices` +
                    `&return=polyline,tolls,summary,travelSummary,passthrough,routeHandle,incidents,actions,potentialTimeDependentViolations`;

                // Add vehicle parameters
                routeUrl += `&vehicle[height]=${vehicleParams.height}` +
                    `&vehicle[width]=${vehicleParams.width}` +
                    `&vehicle[length]=${vehicleParams.length}` +
                    `&vehicle[currentWeight]=${vehicleParams.weight}` +
                    `&vehicle[grossWeight]=${vehicleParams.weight}` +
                    `&vehicle[axleCount]=${vehicleParams.truckAxles + vehicleParams.trailerAxles}` +
                    `&vehicle[tiresCount]=${(vehicleParams.truckAxles + vehicleParams.trailerAxles) * 2}` +
                    `&vehicle[engineType]=internalCombustion` +
                    `&vehicle[weightPerAxle]=10000` +
                    `&vehicle[heightAboveFirstAxle]=${vehicleParams.height}`;

                // Add trailer parameters if vehicle has trailer
                if (vehicleParams.trailerCount > 0) {
                    routeUrl += `&vehicle[trailerCount]=${vehicleParams.trailerCount}` +
                            `&vehicle[trailerAxleCount]=${vehicleParams.trailerAxles}`;
                }

                // Add toll parameters
                routeUrl += `&departureTime=any` +
                    `&tolls[emissionType]=euro${vehicleParams.euroClass};co2class=${vehicleParams.co2Class}` +
                    `&tolls[summaries]=total`;

                // Add excluded areas
                excludedAreas.forEach(area => {
                    if (typeof area === 'string') {
                        routeUrl += `&exclude[countries]=${area}`;
                    } else if (area.type === 'bbox') {
                        routeUrl += `&avoid[areas]=bbox:${area.west},${area.south},${area.east},${area.north}`;
                    }
                });

                // Add waypoints
                routeUrl += `&origin=${origin.lat},${origin.lng}` +
                    `&destination=${destination.lat},${destination.lng}`;

                if (viaPoints.length > 0) {
                    routeUrl += viaPoints.map(point =>
                        `&via=${point.lat},${point.lng};snapRadius=3000`
                    ).join('');
}



                const response = await fetch(routeUrl, { signal });
                if (!response.ok) {
                    throw new Error(`${translations.routeError}: ${response.status}`);
                }

                const result = await response.json();
                function addRouteBubble(mainRoute, alternativeRoute) {
                    // Zbierz punkty z trasy głównej
                    const mainPoints = [];
                    mainRoute.sections.forEach(section => {
                        const lineString = H.geo.LineString.fromFlexiblePolyline(section.polyline);
                        const latLngArray = lineString.getLatLngAltArray();
                        for (let i = 0; i < latLngArray.length; i += 3) {
                            mainPoints.push({
                                lat: latLngArray[i],
                                lng: latLngArray[i + 1]
                            });
                        }
                    });

                    // Zbierz punkty z trasy alternatywnej
                    const altPoints = [];
                    alternativeRoute.sections.forEach(section => {
                        const lineString = H.geo.LineString.fromFlexiblePolyline(section.polyline);
                        const latLngArray = lineString.getLatLngAltArray();
                        for (let i = 0; i < latLngArray.length; i += 3) {
                            altPoints.push({
                                lat: latLngArray[i],
                                lng: latLngArray[i + 1]
                            });
                        }
                    });

                    // Znajdź punkt największego odchylenia
                    let maxDeviation = 0;
                    let deviationPoint = altPoints[Math.floor(altPoints.length / 2)]; // domyślnie środek trasy alternatywnej

                    // Sprawdzamy co 10-ty punkt dla optymalizacji
                    for (let i = 0; i < altPoints.length; i += 10) {
                        const altPoint = altPoints[i];
                        let minDistance = Infinity;

                        // Sprawdzamy co 10-ty punkt trasy głównej
                        for (let j = 0; j < mainPoints.length; j += 10) {
                            const mainPoint = mainPoints[j];
                            const latDiff = altPoint.lat - mainPoint.lat;
                            const lngDiff = altPoint.lng - mainPoint.lng;
                            const distance = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
                            
                            if (distance < minDistance) {
                                minDistance = distance;
                            }
                        }

                        if (minDistance > maxDeviation) {
                            maxDeviation = minDistance;
                            deviationPoint = altPoint;
                        }
                    }

                    // Oblicz różnice
                    const mainDistance = mainRoute.sections.reduce((sum, section) => sum + section.summary.length, 0);
                    const altDistance = alternativeRoute.sections.reduce((sum, section) => sum + section.summary.length, 0);
                    const mainTolls = calculateTotalTolls(mainRoute);
                    const altTolls = calculateTotalTolls(alternativeRoute);
                    
                    const distanceDiff = ((altDistance - mainDistance) / 1000);
                    const tollsDiff = (altTolls - mainTolls);
                    
                    // Sprawdź czy różnice przekraczają progi
                    const DISTANCE_THRESHOLD = 0.1; // 100m
                    const TOLL_THRESHOLD = 0.1; // 0.1 EUR
                    

                    if (Math.abs(distanceDiff) > DISTANCE_THRESHOLD || Math.abs(tollsDiff) > TOLL_THRESHOLD) {
                        const bubbleId = 'route-switch-' + Math.random().toString(36).substr(2, 9);

                        const bubbleContent = `
                            <div id="${bubbleId}" style="cursor: pointer;">
                                <div style="color: ${distanceDiff > 0 ? '#ff4444' : '#44aa44'}">${distanceDiff > 0 ? '+' : ''}${distanceDiff.toFixed(1)} km</div>
                                <div style="color: ${tollsDiff > 0 ? '#ff4444' : '#44aa44'}">${tollsDiff > 0 ? '+' : ''}${tollsDiff.toFixed(2)} €</div>
                            </div>
                        `;
                        
                        const bubble = new H.ui.InfoBubble(deviationPoint, {
                            content: bubbleContent,
                            hideCloseButton: true,
                            autoClose: false
                        });
                        
                        bubble.open();
                        ui.addBubble(bubble);
                        routeBubbles.push(bubble);

                        setTimeout(() => {
                            const element = document.getElementById(bubbleId);
                            if (element) {
                                element.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                    const alternativeIndex = allRoutes.findIndex(route => route === alternativeRoute);
                                    if (alternativeIndex !== -1) {
                                        currentRouteIndex = alternativeIndex;
                                        displayRoutes(allRoutes, alternativeIndex);
                                    }
                                });
                            }
                        }, 100);
                    }
                }

                function calculateTotalTolls(route) {
                    if (!route.sections) return 0;
                    
                    const countryTolls = new Map();
                    const minPassSubscriptionTolls = new Map();
                    const processedFareIds = new Set();
                    let totalToll = 0;

                    route.sections.forEach(section => {
                        if (section.tolls) {
                            section.tolls.forEach(toll => {
                                // Sprawdzamy czy to jest system manualny i czy spełnia kryteria
                                if (MANUAL_TOLL_SYSTEMS.hasOwnProperty(toll.tollSystem)) {
                                    const criteria = MANUAL_TOLL_SYSTEMS[toll.tollSystem];
                                    
                                    // Jeśli mamy dodatkowe kryteria (np. dla ATMB)
                                    if (criteria && criteria.checkLocation) {
                                        // Sprawdź czy punkt poboru istnieje
                                        const hasLocation = toll.tollCollectionLocations?.some(loc => 
                                            loc.name === criteria.checkLocation
                                        );
                                        if (hasLocation) return; // Pomijamy jeśli to jest potwierdzony system manualny
                                    } else {
                                        return; // Pomijamy jeśli to jest system manualny bez dodatkowych kryteriów
                                    }
                                }

                                const countryCode = toll.countryCode;
                                if (!countryTolls.has(countryCode)) {
                                    countryTolls.set(countryCode, 0);
                                }

                                if (toll.fares) {
                                    let minFare = Infinity;
                                    toll.fares.forEach(fare => {
                                        const value = fare.convertedPrice?.value || fare.price?.value || 0;
                                        
                                        if (fare.paymentMethods?.includes('passSubscription')) {
                                            const key = `${toll.countryCode}_${toll.tollSystem}`;
                                            if (!minPassSubscriptionTolls.has(key) || value < minPassSubscriptionTolls.get(key)) {
                                                minPassSubscriptionTolls.set(key, value);
                                            }
                                        } else if (!processedFareIds.has(fare.id)) {
                                            processedFareIds.add(fare.id);
                                            minFare = Math.min(minFare, value);
                                        }
                                    });
                                    
                                    if (minFare !== Infinity) {
                                        countryTolls.set(countryCode, countryTolls.get(countryCode) + minFare);
                                    }
                                }
                            });
                        }
                    });

                    // Dodaj najniższe opłaty za pass subscription
                    for (const [key, value] of minPassSubscriptionTolls.entries()) {
                        const [countryCode, tollSystem] = key.split('_');
                        if (!MANUAL_TOLL_SYSTEMS.hasOwnProperty(tollSystem) && countryTolls.has(countryCode)) {
                            countryTolls.set(countryCode, countryTolls.get(countryCode) + value);
                        }
                    }

                    return Array.from(countryTolls.values()).reduce((a, b) => a + b, 0);
                }



                
                if (result.routes && result.routes.length > 0) {
                    allRoutes = result.routes; // Zapisujemy wszystkie trasy
                    displayRoutes(allRoutes, currentRouteIndex);
                }

                // Funkcja znajdująca kraje na trasie i ich długości
                function getCountriesFromRoute(route) {
                    let countriesInfo = new Map();
                    
                    route.sections.forEach(section => {
                        if (section.spans) {
                            section.spans.forEach(span => {
                                if (span.countryCode) {
                                    const distance = span.length || 0;
                                    const current = countriesInfo.get(span.countryCode) || 0;
                                    countriesInfo.set(span.countryCode, current + distance);
                                }
                            });
                        }
                    });
                    
                    return countriesInfo;
                }

                // Funkcja znajdująca najniższą cenę paliwa dla krajów na trasie
                function getLowestFuelPrice(countriesInfo) {
                    let lowestPrice = Infinity;
                    let lowestPriceCountry = null;
                    
                    for (const [countryCode] of countriesInfo) {
                        let price;
                        if (companyCosts.useCustomFuelPrices) {
                            // Sprawdzamy czy kraj ma zdefiniowaną cenę niestandardową lub domyślną
                            price = companyCosts.customFuelPrices[countryCode] || defaultFuelPrices[countryCode];
                        } else {
                            price = defaultFuelPrices[countryCode];
                        }
                        
                        // Bierzemy pod uwagę tylko kraje z zdefiniowaną ceną
                        if (price && !isNaN(price) && price < lowestPrice) {
                            lowestPrice = price;
                            lowestPriceCountry = countryCode;
                        }
                    }
                    
                    // Jeśli nie znaleziono żadnej ceny, zwracamy null
                    if (lowestPrice === Infinity) {
                        return {
                            price: null,
                            country: null
                        };
                    }
                    
                    return {
                        price: lowestPrice,
                        country: lowestPriceCountry
                    };
                }

                // Funkcja obliczająca koszty paliwa
                function calculateFuelCosts(route, vehicle, selectedCountry = null) {
                    const totalDistance = route.sections.reduce((sum, section) => 
                        sum + (section.summary?.length || 0), 0);
                    
                    const distanceInKm = totalDistance / 1000;
                    const fuelConsumption = vehicle.fuelConsumption / 100; // L/km
                    const adblueConsumption = vehicle.adblueConsumption / 100; // L/km
                    
                    const totalFuelNeeded = distanceInKm * fuelConsumption;
                    const totalAdBlueNeeded = distanceInKm * adblueConsumption;
                    
                    // Logika dla AdBlue
                    let adbluePrice;
                    if (companyCosts.useCustomFuelPrices) {
                        if (companyCosts.customFuelPrices.adblue !== undefined) {
                            adbluePrice = companyCosts.customFuelPrices.adblue;
                        } else {
                            adbluePrice = defaultFuelPrices.adblue;
                        }
                    } else {
                        adbluePrice = defaultFuelPrices.adblue;
                    }
                    
                    const adblueCost = totalAdBlueNeeded * adbluePrice;

                    let fuelPrice;
                    let priceDetails = {};

                    if (selectedCountry) {
                        fuelPrice = companyCosts.useCustomFuelPrices && companyCosts.customFuelPrices[selectedCountry] ? 
                            companyCosts.customFuelPrices[selectedCountry] : 
                            defaultFuelPrices[selectedCountry];
                            
                        // Sprawdzamy czy cena została znaleziona
                        if (fuelPrice && !isNaN(fuelPrice)) {
                            priceDetails = {
                                country: selectedCountry,
                                price: fuelPrice,
                                type: 'selected'
                            };
                        } else {
                            // Jeśli nie znaleziono ceny dla wybranego kraju, szukamy najniższej dostępnej
                            const countriesInfo = getCountriesFromRoute(route);
                            const lowestFuelInfo = getLowestFuelPrice(countriesInfo);
                            fuelPrice = lowestFuelInfo.price;
                            priceDetails = {
                                country: lowestFuelInfo.country,
                                price: fuelPrice,
                                type: 'lowest'
                            };
                        }
                    } else {
                        const countriesInfo = getCountriesFromRoute(route);
                        const lowestFuelInfo = getLowestFuelPrice(countriesInfo);
                        fuelPrice = lowestFuelInfo.price;
                        priceDetails = {
                            country: lowestFuelInfo.country,
                            price: fuelPrice,
                            type: 'lowest'
                        };
                    }

                    // Sprawdzamy czy udało się znaleźć jakąkolwiek cenę
                    if (!fuelPrice || isNaN(fuelPrice)) {
                        return {
                            fuelNeeded: totalFuelNeeded,
                            adblueNeeded: totalAdBlueNeeded,
                            fuelCost: 0,
                            adblueCost: adblueCost,
                            totalCost: adblueCost, // tylko koszt AdBlue
                            priceDetails: {
                                country: null,
                                price: null,
                                type: 'no_prices_available'
                            },
                            adbluePrice: adbluePrice
                        };
                    }

                    const fuelCost = totalFuelNeeded * fuelPrice;
                    const totalCost = fuelCost + adblueCost;
                    
                    return {
                        fuelNeeded: totalFuelNeeded,
                        adblueNeeded: totalAdBlueNeeded,
                        fuelCost: fuelCost,
                        adblueCost: adblueCost,
                        totalCost: totalCost,
                        priceDetails: priceDetails,
                        adbluePrice: adbluePrice
                    };
                }

                // Funkcja generująca HTML dla sekcji kosztów paliwa
                function generateFuelCostsHTML(fuelCosts, route, selectedVehicle) {
                    const { totalCost, fuelNeeded, adblueNeeded, fuelCost, adblueCost, priceDetails, adbluePrice } = fuelCosts;
                    const totalDistance = route.sections.reduce((sum, section) => 
                        sum + (section.summary?.length || 0), 0) / 1000;
                    const costPerKm = totalCost / totalDistance;

                    // Pobierz kraje z trasy
                    const countriesFromRoute = getCountriesFromRoute(route);
                    
                    // Funkcja pomocnicza do pobierania aktualnej ceny dla kraju
                    function getPriceForCountry(countryCode) {
                        if (companyCosts.useCustomFuelPrices && companyCosts.customFuelPrices[countryCode] !== undefined) {
                            return companyCosts.customFuelPrices[countryCode];
                        }
                        return defaultFuelPrices[countryCode];
                    }

                    // Przygotuj kraje z trasy (posortowane po cenie)
                    const routeCountries = Array.from(countriesFromRoute.keys())
                        .map(code => ({
                            code,
                            price: getPriceForCountry(code)
                        }))
                        .sort((a, b) => a.price - b.price);

                    // Przygotuj pozostałe kraje
                    const otherCountries = Object.entries(defaultFuelPrices)
                        .filter(([code]) => code !== 'adblue' && !countriesFromRoute.has(code))
                        .map(([code]) => ({
                            code,
                            price: getPriceForCountry(code)
                        }))
                        .sort((a, b) => a.code.localeCompare(b.code)); // sortuj alfabetycznie

                    // Generuj opcje
                    const countryOptions = `
                        ${routeCountries.map(({ code, price }) => {
                            // Dodajemy tylko kraje z zdefiniowaną ceną
                            if (price && !isNaN(price)) {
                                return `
                                    <option value="${code}" ${priceDetails.country === code ? 'selected' : ''} style="font-weight: bold">
                                        ${code} (${price.toFixed(2)}€/L)
                                    </option>
                                `;
                            }
                            return ''; // Pomijamy kraje bez zdefiniowanej ceny
                        }).join('')}
                        ${otherCountries.length > 0 ? '<option disabled>──────────</option>' : ''}
                        ${otherCountries.map(({ code, price }) => {
                            // Również sprawdzamy czy cena jest zdefiniowana
                            if (price && !isNaN(price)) {
                                return `
                                    <option value="${code}" ${priceDetails.country === code ? 'selected' : ''}>
                                        ${code} (${price.toFixed(2)}€/L)
                                    </option>
                                `;
                            }
                            return '';
                        }).join('')}`;

                    // Aktualizujemy tylko zawartość szczegółów, nie całą strukturę
                    const detailsContent = `
                        <div class="country-toll">
                            ${translations.fuelConsumption}: ${selectedVehicle.fuelConsumption}L/100km
                        </div>
                        <div class="country-toll">
                            ${translations.fuelInCountry}: 
                            <select class="fuel-country-select" style="padding: 2px 5px; border: 1px solid #ddd; border-radius: 3px;">
                                <option value="">${translations.lowestPrice}</option>
                                ${countryOptions}
                            </select>
                        </div>
                        <div class="fuel-costs-details">
                            <div class="country-toll">
                                ${translations.fuel}: ${fuelNeeded.toFixed(0)}L × ${priceDetails.price.toFixed(2)}€/L = ${fuelCost.toFixed(2)}€
                            </div>
                            <div class="country-toll">
                                AdBlue: ${adblueNeeded.toFixed(1)}L × ${adbluePrice.toFixed(2)}€/L = ${adblueCost.toFixed(2)}€
                            </div>
                        </div>`;

                    // Główna wartość
                    const mainValue = `${totalCost.toFixed(2)} € (${costPerKm.toFixed(2)} €/km)`;

                    setTimeout(() => {
                        const countrySelect = document.querySelector('.fuel-country-select');
                        if (countrySelect) {
                            countrySelect.addEventListener('change', (e) => {
                                const selectedCountry = e.target.value || null; // gdy wybrana opcja "Najniższa cena", value będzie puste
                                
                                // Przeliczamy tylko koszty paliwa
                                const newFuelCosts = calculateFuelCosts(route, selectedVehicle, selectedCountry);
                                
                                // Aktualizujemy tylko odpowiednie elementy
                                const mainValueElement = document.querySelector('.fuel-costs-main-value');
                                const detailsElement = document.querySelector('.fuel-costs-details');
                                
                                if (mainValueElement) {
                                    mainValueElement.textContent = `${newFuelCosts.totalCost.toFixed(2)} € (${(newFuelCosts.totalCost/totalDistance).toFixed(2)} €/km)`;
                                }
                                
                                if (detailsElement) {
                                    detailsElement.innerHTML = `
                                        <div class="country-toll">
                                            Paliwo: ${newFuelCosts.fuelNeeded.toFixed(0)}L × ${newFuelCosts.priceDetails.price.toFixed(2)}€/L = ${newFuelCosts.fuelCost.toFixed(2)}€
                                        </div>
                                        <div class="country-toll">
                                            AdBlue: ${newFuelCosts.adblueNeeded.toFixed(1)}L × ${newFuelCosts.adbluePrice.toFixed(2)}€/L = ${newFuelCosts.adblueCost.toFixed(2)}€
                                        </div>`;
                                }
                            });
                        }
                    }, 0);

                    return `
                        <div class="stat-value">
                            <span class="fuel-costs-main-value">${mainValue}</span>
                            <button class="toll-details-toggle">▼</button>
                            <div class="toll-details" style="display: none;">
                                <div class="toll-details-content">
                                    ${detailsContent}
                                </div>
                            </div>
                        </div>`;
                    }


                function displayRoutes(routes, activeIndex) {
                    clearMap();
                    
                    // Oblicz metryki głównej trasy do porównania
                    const mainRoute = routes[activeIndex];
                    const mainDistance = mainRoute.sections.reduce((sum, section) => sum + section.summary.length, 0);
                    const mainTolls = calculateTotalTolls(mainRoute);

                    // Przetwórz każdą trasę (główną i alternatywne)
                    routes.forEach((route, routeIndex) => {
                        const sections = route.sections;
                        const isAlternative = routeIndex !== activeIndex;
                        
                        sections.forEach((section, sectionIndex) => {
                            const lineString = H.geo.LineString.fromFlexiblePolyline(section.polyline);
                            
                            // W funkcji displayRoutes, gdzie tworzymy polyline:
                            const ROUTE_STYLES = {
                                alternative: {
                                    strokeColor: '#808080',
                                    lineWidth: 5
                                },
                                main: {
                                    strokeColor: 'rgba(0, 0, 139, 0.7)',
                                    lineWidth: 5
                                }
                            };

                            // Użycie
                            const polyline = new H.map.Polyline(lineString, {
                                style: isAlternative ? ROUTE_STYLES.alternative : ROUTE_STYLES.main
                            });

                            // Dodaj informację o sekcji do polyline
                            polyline.setData({
                                sectionIndex: sectionIndex
                            });


                            polyline.setZIndex(isAlternative ? 1 : 2);
                            map.addObject(polyline);
                            routeLines.push(polyline);
                            

                            if (isAlternative) {
                                polyline.addEventListener('tap', () => {
                                    currentRouteIndex = routeIndex;
                                    displayRoutes(allRoutes, routeIndex);
                                });
                            }

                            map.addObject(polyline);
                            routeLines.push(polyline);

                            // Dodanie drag handle tylko dla aktywnej trasy
                            if (!isAlternative) {
                                // Dodaj marker-uchwyt (początkowo ukryty)
                                const svgMarkup = '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">' +
                                    '<circle cx="12" cy="12" r="11" fill="white" fill-opacity="0.8" stroke="#0066CC" stroke-width="2"/>' +
                                    '<circle cx="12" cy="12" r="6" fill="#0066CC" fill-opacity="0.3"/>' +
                                    '</svg>';
                                
                                const dragHandle = new H.map.Marker({ lat: 0, lng: 0 }, {
                                    icon: new H.map.Icon(svgMarkup, {
                                        anchor: { x: 12, y: 12 }
                                    }),
                                    visibility: false,
                                    volatility: true
                                });

                                dragHandle.addEventListener('pointerenter', () => {
                                    isOverHandle = true;
                                    clearTimeout(hideHandleTimeout);
                                });

                                dragHandle.addEventListener('pointerleave', () => {
                                    isOverHandle = false;
                                    if (!isDragging) {
                                        hideHandleTimeout = setTimeout(() => {
                                            if (!isOverHandle) {
                                                dragHandle.setVisibility(false);
                                                map.getViewPort().element.style.cursor = 'default';
                                            }
                                        }, 100);
                                    }
                                });
                                

                                dragHandle.draggable = true;
                                map.addObject(dragHandle);
                                routeLines.push(dragHandle);

                                // Obsługa ruchu myszy nad polyline
                                let isDragging = false;
                                let currentDragSegmentIndex = null;


                                polyline.addEventListener('pointermove', (evt) => {
                                    if (isDragging) return;
                                    
                                    clearTimeout(hideHandleTimeout);
                                    
                                    const pointer = evt.currentPointer;
                                    const coordinates = lineString.getLatLngAltArray();
                                    let closestPoint = null;
                                    let minDistance = Infinity;

                                    for(let i = 0; i < coordinates.length - 2; i += 3) {
                                        const point = map.geoToScreen({ 
                                            lat: coordinates[i], 
                                            lng: coordinates[i + 1] 
                                        });
                                        const distance = Math.hypot(point.x - pointer.viewportX, point.y - pointer.viewportY);
                                        
                                        if (distance < minDistance) {
                                            minDistance = distance;
                                            closestPoint = { lat: coordinates[i], lng: coordinates[i + 1] };
                                            currentDragSegmentIndex = polyline.getData().sectionIndex;
                                        }
                                    }

                                    if (minDistance < 50 || isOverHandle) {
                                        dragHandle.setGeometry(closestPoint);
                                        dragHandle.setVisibility(true);
                                        map.getViewPort().element.style.cursor = 'grab';
                                    }
                                });

                                // Obsługa przeciągania
                                dragHandle.addEventListener('pointerdown', (evt) => {
                                    evt.stopPropagation();
                                    isDragging = true;
                                    currentDragHandle = evt.target;
                                    behavior.disable();
                                    map.getViewPort().element.style.cursor = 'grabbing';
                                    
                                    const handlePointerMove = (e) => {
                                        if (!isDragging) return;
                                        const rect = map.getViewPort().element.getBoundingClientRect();
                                        const pointer = {
                                            viewportX: e.clientX - rect.left,
                                            viewportY: e.clientY - rect.top
                                        };
                                        currentDragHandle.setGeometry(map.screenToGeo(pointer.viewportX, pointer.viewportY));
                                    };

                                    const handlePointerUp = (e) => {
                                        if (!isDragging) return;

                                        const position = currentDragHandle.getGeometry();
                                        currentDragHandle.setVisibility(false);
                                        isDragging = false;
                                        behavior.enable();
                                        map.getViewPort().element.style.cursor = 'default';

                                        if (currentDragSegmentIndex !== null) {
                                            const waypointContainers = document.querySelectorAll('.waypoint-container');
                                            const newWaypoint = createWaypointInput();
                                            const input = newWaypoint.querySelector('.waypoint');
                                            input.value = `${position.lat.toFixed(6)}, ${position.lng.toFixed(6)}`;

                                            // Wstaw punkt za waypointem odpowiadającym początku sekcji
                                            const targetContainer = waypointContainers[currentDragSegmentIndex + 1];
                                            if (targetContainer) {
                                                waypointContainers[0].parentNode.insertBefore(newWaypoint, targetContainer);
                                            } else {
                                                waypointContainers[0].parentNode.appendChild(newWaypoint);
                                            }

                                            input.dispatchEvent(new Event('input'));
                                            updateWaypointNumbers();
                                            calculateRouteIfPossible();
                                        }

                                        currentDragHandle = null;
                                        currentDragSegmentIndex = null;
                                        document.removeEventListener('pointermove', handlePointerMove);
                                        document.removeEventListener('pointerup', handlePointerUp);
                                    };

                                    document.addEventListener('pointermove', handlePointerMove);
                                    document.addEventListener('pointerup', handlePointerUp);
                                });

                                polyline.addEventListener('pointerleave', () => {
                                    if (!isDragging && !isOverHandle) {
                                        hideHandleTimeout = setTimeout(() => {
                                            if (!isOverHandle) {
                                                dragHandle.setVisibility(false);
                                                map.getViewPort().element.style.cursor = 'default';
                                            }
                                        }, 100);
                                    }
                                });
                            }
                        });
                        function updateDistanceIndicators(route) {
                            const distanceIndicators = document.querySelectorAll('.distance-indicator');
                            distanceIndicators.forEach(indicator => indicator.classList.remove('visible'));

                            if (route.sections) {
                                route.sections.forEach((section, index) => {
                                    const indicator = distanceIndicators[index];
                                    if (indicator && section.summary && section.summary.length) {
                                        const distanceInKm = (section.summary.length / 1000).toFixed(1);
                                        const timeInHours = (distanceInKm / 73).toFixed(1);
                                        const hours = Math.floor(timeInHours);
                                        const minutes = Math.round((timeInHours - hours) * 60);
                                        
                                        const timeDisplay = hours > 0 ? 
                                            `${hours}h ${minutes}min` : 
                                            `${minutes}min`;
                                        
                                        indicator.innerHTML = `<span class="arrow">↓</span> ${distanceInKm} km (${timeDisplay})`;
                                        indicator.classList.add('visible');
                                    }
                                });
                            }
                        }

                        // I wywołaj ją dla aktywnej trasy
                        if (routeIndex === currentRouteIndex) {
                            updateDistanceIndicators(route);
                        }


                        // Dodaj markery tylko dla aktualnej trasy
                        if (routeIndex === currentRouteIndex) {
                            geoResults.forEach((result, index) => {
                                addMarker({ lat: result.lat, lng: result.lng }, index + 1);
                            });

                            // Oblicz i wyświetl informacje o trasie
                            const totalDistance = route.sections.reduce((sum, section) => {
                                if (section.transport?.mode === 'truck') {
                                    return sum + section.summary.length;
                                }
                                return sum;
                            }, 0);
                            const distanceInKm = totalDistance / 1000;
                            const timeInHours = distanceInKm / 73;
                            const totalTime = timeInHours * 3600;

                            // Pobieranie informacji o opłatach
                            let tollInfo = '';
                            if (route.sections) {
                                const countryTolls = new Map();
                                const ferries = new Map();
                                const minPassSubscriptionTolls = new Map();
                                const processedFareIds = new Set();
                                let totalToll = 0;
                                
                                route.sections.forEach(section => {
                                    if (section.transport?.mode) {
                                        const transportMode = section.transport.mode;
                                        const transportName = section.transport.name;
                                        
                                        if (transportName && (
                                            transportMode === 'ferry' || 
                                            transportMode.toLowerCase().includes('shuttletrain')
                                        )) {
                                            const icon = transportMode === 'ferry' ? '⛴️' : '🛤️';
                                            ferries.set(transportName, {
                                                icon: icon,
                                                value: localStorage.getItem(`ferry_${transportName}`) || ''
                                            });
                                        }
                                    }
                                    if (section.tolls) {
                                        section.tolls.forEach(toll => {
                                            // Pomijamy systemy z listy MANUAL_TOLL_SYSTEMS
                                            if (toll.tollSystem in MANUAL_TOLL_SYSTEMS) {
                                                return;
                                            }

                                            const countryCode = toll.countryCode;
                                            if (!countryTolls.has(countryCode)) {
                                                countryTolls.set(countryCode, 0);
                                            }

                                            if (toll.fares) {
                                                let minFare = Infinity;
                                                toll.fares.forEach(fare => {
                                                    const value = fare.convertedPrice?.value || fare.price?.value || 0;
                                                    
                                                    if (fare.paymentMethods?.includes('passSubscription')) {
                                                        const key = `${toll.countryCode}_${toll.tollSystem}`;
                                                        if (!minPassSubscriptionTolls.has(key) || value < minPassSubscriptionTolls.get(key)) {
                                                            minPassSubscriptionTolls.set(key, value);
                                                        }
                                                    } else if (!processedFareIds.has(fare.id)) {
                                                        processedFareIds.add(fare.id);
                                                        minFare = Math.min(minFare, value);
                                                    }
                                                });
                                                
                                                if (minFare !== Infinity) {
                                                    countryTolls.set(countryCode, countryTolls.get(countryCode) + minFare);
                                                }
                                            }
                                        });
                                    }
                                });

                                for (const [key, value] of minPassSubscriptionTolls.entries()) {
                                    const countryCode = key.split('_')[0];
                                    if (countryTolls.has(countryCode)) {
                                        countryTolls.set(countryCode, countryTolls.get(countryCode) + value);
                                    }
                                }

                                totalToll = Array.from(countryTolls.values()).reduce((a, b) => a + b, 0);

                                let roadTollsHtml = '';
                                if (totalToll > 0) {
                                    const costPerKm = totalToll / (totalDistance / 1000);
                                    roadTollsHtml = `
                                        <div class="route-stat">
                                            <div class="stat-label">${translations.roadCharges}</div>
                                            <div class="stat-value">${totalToll.toFixed(2)} € (${costPerKm.toFixed(2)} €/km)
                                                <button class="toll-details-toggle">▼</button>
                                            </div>
                                            <div class="toll-details" style="display: none;">
                                                <div class="toll-details-content">
                                                    ${Array.from(countryTolls.entries())
                                                        .map(([country, value]) => `
                                                            <div class="country-toll">
                                                                ${country}: ${value.toFixed(2)} EUR
                                                            </div>
                                                        `).join('')}
                                                </div>
                                            </div>
                                        </div>`;
                                } else {
                                    roadTollsHtml = `
                                        <div class="route-stat">
                                            <div class="stat-label">${translations.roadCharges}</div>
                                            <div class="stat-value">${translations.noRoadCharges}</div>
                                        </div>`;
                                }

                                let ferriesHtml = '';
                                    if (ferries.size > 0) {
                                        ferriesHtml = Array.from(ferries.entries())
                                            .map(([name, data]) => `
                                                <div class="ferry-item" style="margin-top: 2px;">
                                                    ${data.icon} ${name}: 
                                                    <input type="number" 
                                                        class="ferry-price" 
                                                        data-ferry-name="${name}"
                                                        value="${data.value}"
                                                        min="0" 
                                                        max="5000" 
                                                        step="1" 
                                                        style="width: 60px; padding: 2px 5px; border: 1px solid #ddd; border-radius: 3px;"
                                                        placeholder="EUR">
                                                </div>
                                            `).join('');
                                    }
                                
                                let manualTollsHtml = '';
                                if (route.sections) {
                                    const manualTollSystems = new Set();
                                    route.sections.forEach(section => {
                                        if (section.tolls) {
                                            section.tolls.forEach(toll => {
                                                // Sprawdź czy system jest na liście manualnych
                                                if (MANUAL_TOLL_SYSTEMS.hasOwnProperty(toll.tollSystem)) {
                                                    const criteria = MANUAL_TOLL_SYSTEMS[toll.tollSystem];
                                                    
                                                    // Jeśli mamy dodatkowe kryteria (np. dla ATMB)
                                                    if (criteria && criteria.checkLocation) {
                                                        // Sprawdź czy punkt poboru istnieje
                                                        const hasLocation = toll.tollCollectionLocations?.some(loc => 
                                                            loc.name === criteria.checkLocation
                                                        );
                                                        if (!hasLocation) return; // Jeśli nie ma wymaganej lokalizacji, pomiń
                                                    }
                                                    
                                                    manualTollSystems.add(toll.tollSystem);
                                                }
                                            });
                                        }
                                    });
                                    
                                    if (manualTollSystems.size > 0) {
                                        manualTollsHtml = Array.from(manualTollSystems).map(system => `
                                            <div class="ferry-item" style="margin-top: 2px;">
                                                🛤️ ${MANUAL_TOLL_SYSTEMS[system].displayName}: 
                                                <input type="number" 
                                                    class="manual-toll-price" 
                                                    data-toll-system="${system}"
                                                    value="${localStorage.getItem(`toll_${system}`) || ''}"
                                                    min="0" 
                                                    max="5000" 
                                                    step="1" 
                                                    style="width: 60px; padding: 2px 5px; border: 1px solid #ddd; border-radius: 3px;"
                                                    placeholder="EUR">
                                            </div>
                                        `).join('');
                                    }
                                }

                                tollInfo = roadTollsHtml + ferriesHtml + manualTollsHtml;
                            } else {
                                tollInfo = `<br>${translations.noRoadCharges}`;
                            }

                                // Najpierw sprawdzamy czy trasa zawiera prom lub pociąg
                                const selectedVehicle = vehicles.find(v => v.id === localStorage.getItem('selectedVehicleId')) || vehicles[0];
                                const fuelCosts = calculateFuelCosts(route, selectedVehicle);
                                const fuelCostsHTML = generateFuelCostsHTML(fuelCosts, route, selectedVehicle);

                                const hasferryOrTrain = route.sections.some(section => 
                                    section.transport?.mode === 'ferry' || section.transport?.mode === 'shuttletrain'
                                );

                                document.getElementById('route-info').innerHTML = `
                                    <div class="route-info-label">${translations.routeInfo}</div>
                                    <div class="route-stats-container">
                                        <div class="route-stat">
                                            <div class="stat-label">${translations.distance}${hasferryOrTrain ? ` (${translations.withoutFerryTrainKm})` : ''}</div>
                                            <div class="stat-value">${(totalDistance / 1000).toFixed(1)} km</div>
                                        </div>
                                        <div class="route-stat">
                                            <div class="stat-label">${translations.time}</div>
                                            <div class="stat-value">${Math.floor(totalTime / 3600)}h ${Math.round((totalTime % 3600) / 60)}min</div>
                                        </div>
                                    </div>
                                    ${tollInfo}
                                    <div class="route-stat">
                                        <div class="stat-label">${translations.fuelCosts}</div>
                                        ${fuelCostsHTML}
                                    </div>
                                `;
                                // Dodaj event listenery dla wszystkich przycisków rozwijania
                                document.querySelectorAll('.toll-details-toggle').forEach(button => {
                                    button.addEventListener('click', function() {
                                        const details = this.closest('.stat-value').querySelector('.toll-details');
                                        const isExpanded = details.style.display !== 'none';
                                        details.style.display = isExpanded ? 'none' : 'block';
                                        this.textContent = isExpanded ? '▼' : '▲';
                                    });
                                });
                            
                            // TUTAJ dodajmy event listenery
                            document.querySelectorAll('.manual-toll-price').forEach(input => {
                                input.addEventListener('input', (e) => {
                                    const value = e.target.value;
                                    const tollSystem = e.target.dataset.tollSystem;
                                    console.log('Manual toll input changed:', tollSystem, value); // debug
                                    if (value === '' || (parseFloat(value) >= 0 && parseFloat(value) <= 5000)) {
                                        localStorage.setItem(`toll_${tollSystem}`, value);
                                        console.log('Saved to localStorage:', tollSystem, value); // debug
                                    }
                                });
                            });    


                            // Dodaj event listenery dla szczegółów opłat
                            const tollDetailsToggle = document.querySelector('.toll-details-toggle');
                            if (tollDetailsToggle) {
                                tollDetailsToggle.addEventListener('click', function() {
                                    const details = document.querySelector('.toll-details');
                                    const isExpanded = details.style.display !== 'none';
                                    details.style.display = isExpanded ? 'none' : 'block';
                                    this.textContent = isExpanded ? '▼' : '▲';
                                });
                            }

                            // Dodaj event listenery dla cen promów
                            document.querySelectorAll('.ferry-price').forEach(input => {
                                input.addEventListener('input', (e) => {
                                    const value = e.target.value;
                                    const ferryName = e.target.dataset.ferryName;
                                    if (value === '' || (parseFloat(value) >= 0 && parseFloat(value) <= 5000)) {
                                        localStorage.setItem(`ferry_${ferryName}`, value);
                                }
                            });
                            // Dodaj event listenery dla manualnych opłat drogowych
                            document.querySelectorAll('.manual-toll-price').forEach(input => {
                                input.addEventListener('input', (e) => {
                                    const value = e.target.value;
                                    const tollSystem = e.target.dataset.tollSystem;
                                    if (value === '' || (parseFloat(value) >= 0 && parseFloat(value) <= 5000)) {
                                        localStorage.setItem(`toll_${tollSystem}`, value);
                                    }
                                });
                            });
                        });
                    }
                    // Dodaj InfoBubbles dla tras alternatywnych
                    if (routes.length > 1) {
                        const mainRoute = routes[currentRouteIndex];
                        routes.forEach((route, index) => {
                            if (index !== currentRouteIndex) {
                                addRouteBubble(mainRoute, route);
                            }
                        });
                    }
                });
                
                // Dostosuj widok mapy aby pokazać wszystkie trasy
                const allCoordinates = [origin, destination, ...viaPoints];
                let minLat = Math.min(...allCoordinates.map(coord => coord.lat));
                let maxLat = Math.max(...allCoordinates.map(coord => coord.lat));
                let minLng = Math.min(...allCoordinates.map(coord => coord.lng));
                let maxLng = Math.max(...allCoordinates.map(coord => coord.lng));

                const latMargin = (maxLat - minLat) * 0.2;
                const lngMargin = (maxLng - minLng) * 0.2;

                minLat -= latMargin;
                maxLat += latMargin;
                minLng -= lngMargin;
                maxLng += lngMargin;

                const fullBoundingBox = new H.geo.Rect(maxLat, minLng, minLat, maxLng);
                map.getViewModel().setLookAtData({
                    bounds: fullBoundingBox
                });
                }

            } catch (error) {
                    // Ignoruj cichutko błędy związane z anulowaniem żądania
                    if (error.name === 'AbortError') {
                        return;
                    }
                    
                    console.error('Route calculation error:', error);
                    document.getElementById('route-info').innerHTML = `
                        <div class="error-message">
                            ${error.message || translations.routeError}
                        </div>
                    `;
                }
        }
		// Initialize application
		const waypointsContainer = document.getElementById('waypoints-container');
		waypointsContainer.appendChild(createWaypointInput());

        function initializeUITranslations() {
            document.getElementById('settings-title').textContent = translations.routeSettings;
            document.getElementById('excluded-areas-text').textContent = translations.excludedAreas;

            // Dodajemy tłumaczenia dla elementów route-info
            document.querySelectorAll('[data-translation]').forEach(element => {
                const translationKey = element.dataset.translation;
                if (translations[translationKey]) {
                    element.textContent = translations[translationKey];
                }
            });
        }

		// Nasłuchuj zdarzeń input tylko dla dodawania nowych pól
        waypointsContainer.addEventListener('input', (e) => {
            if (e.target.classList.contains('waypoint')) {
                updateRemoveButtons();
                const waypoints = document.querySelectorAll('.waypoint');
                const lastWaypoint = waypoints[waypoints.length - 1];
                
                // Add new field only if last isn't empty and we're under the limit
                if (e.target === lastWaypoint && 
                    e.target.value.trim() !== '' && 
                    waypoints.length < 15) {
                    waypointsContainer.appendChild(createWaypointInput());
                }
            }
        });

        // Funkcja do inicjalizacji przycisków pojazdów
        function initializeVehicleButtons() {
            const container = document.getElementById('vehicle-selection');
            container.innerHTML = '';

            vehicles.forEach(vehicle => {
                const button = document.createElement('button');
                button.innerHTML = `
                    <div class="vehicle-name">${vehicle.name}</div>
                    <div class="vehicle-details">
                        <span>${vehicle.weight/1000}t</span>
                        <span>${vehicle.truckAxles}+${vehicle.trailerAxles} axles</span>
                        <span>EUR${vehicle.euroClass}</span>
                        <span>CO2-${vehicle.co2Class}</span>
                    </div>
                `;
                button.dataset.vehicleId = vehicle.id;
                button.classList.add('vehicle-button');
                button.addEventListener('click', () => selectVehicle(vehicle));
                container.appendChild(button);
            });

            const savedVehicleId = localStorage.getItem('selectedVehicleId') || vehicles[0].id;
            const vehicle = vehicles.find(v => v.id === savedVehicleId);
            if (vehicle) {
                selectVehicle(vehicle);
            }
        }
        // Funkcja do wyboru pojazdu
        function selectVehicle(vehicle) {
            // Aktualizuj wygląd przycisków
            document.querySelectorAll('#vehicle-selection button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.vehicleId === vehicle.id);
            });

            // Zapisz wybór w localStorage
            localStorage.setItem('selectedVehicleId', vehicle.id);

            // Przelicz trasę
            calculateRouteIfPossible();
        }

        // Funkcja do pobrania parametrów aktualnie wybranego pojazdu
        function getVehicleParameters() {
            const vehicleId = localStorage.getItem('selectedVehicleId') || vehicles[0].id;
            const vehicle = vehicles.find(v => v.id === vehicleId);
            
            return {
                weight: vehicle.weight,
                truckAxles: vehicle.truckAxles,
                trailerAxles: vehicle.trailerAxles,
                trailerCount: vehicle.trailerCount,
                euroClass: vehicle.euroClass,
                co2Class: vehicle.co2Class,
                fuelConsumption: vehicle.fuelConsumption,
                costPerKm: vehicle.costPerKm,
                height: vehicle.height,
                width: vehicle.width,
                length: vehicle.length
            };
        }

        // Event listenery dla wyłączonych obszarów
        document.querySelectorAll('#excluded-areas button').forEach(button => {
            button.addEventListener('click', () => {
                button.classList.toggle('active');
                saveExcludedAreas(); // Dodajemy zapisywanie
                if (typeof calculateRouteIfPossible === 'function') {
                    calculateRouteIfPossible();
                }
            });
        });
        // Funkcja zapisująca stan wyłączonych obszarów
        function saveExcludedAreas() {
            const excludedAreas = Array.from(document.querySelectorAll('#excluded-areas button.active'))
                .map(button => button.dataset.value);
            localStorage.setItem('excludedAreas', JSON.stringify(excludedAreas));
        }

        // Funkcja wczytująca stan wyłączonych obszarów
        function loadExcludedAreas() {
            const savedAreas = localStorage.getItem('excludedAreas');
            if (savedAreas) {
                const excludedAreas = JSON.parse(savedAreas);
                document.querySelectorAll('#excluded-areas button').forEach(button => {
                    button.classList.toggle('active', excludedAreas.includes(button.dataset.value));
                });
            }
        }

        ////////////////// FUNKCJE ODPOWIEDZIALNE ZA BUDOWE LINKU + ZMIANĘ PAGE TITLE
        // Function to update URL with current route and settings
        function updateURLParameters() {
            const waypoints = document.querySelectorAll('.waypoint');
            const params = new URLSearchParams();

            // Add only waypoints
            waypoints.forEach((waypoint, index) => {
                const value = waypoint.value.trim();
                if (value) {
                    if (isGPSCoordinates(value)) {
                        const coords = geocodedPoints.get(value);
                        if (coords) {
                            params.append(`wp${index}`, `${coords.lat},${coords.lng}`);
                        }
                    } else {
                        params.append(`wp${index}`, encodeURIComponent(value));
                    }
                }
            });

            // Update URL without reloading the page
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({ path: newURL }, '', newURL);
        }

        function updatePageTitle() {
            const waypoints = document.querySelectorAll('.waypoint');
            const nonEmptyWaypoints = Array.from(waypoints)
                .filter(wp => wp.value.trim() !== '');

            if (nonEmptyWaypoints.length >= 2) {
                const getLocationName = (value) => {
                    const words = value.trim().split(' ');
                    return words.slice(0, 2).join(' ');
                };

                const firstLocation = getLocationName(nonEmptyWaypoints[0].value);
                const lastLocation = getLocationName(nonEmptyWaypoints[nonEmptyWaypoints.length - 1].value);
                document.title = `TN: ${firstLocation} -> ${lastLocation}`;
            } else {
                document.title = 'Transport Nomad';
            }
        }

        // Function to load route from URL parameters
        async function loadRouteFromURL() {
            const params = new URLSearchParams(window.location.search);
            if (params.toString() === '') return;

            // Clear existing waypoints
            const waypointsContainer = document.getElementById('waypoints-container');
            waypointsContainer.innerHTML = '';

            // Load only waypoints
            const waypointParams = Array.from(params.entries())
                .filter(([key]) => key.startsWith('wp'))
                .sort((a, b) => parseInt(a[0].slice(2)) - parseInt(b[0].slice(2)));

            for (const [_, value] of waypointParams) {
                const container = createWaypointInput();
                const input = container.querySelector('.waypoint');
                
                if (value.includes(',')) {
                    const [lat, lng] = value.split(',').map(Number);
                    if (!isNaN(lat) && !isNaN(lng)) {
                        input.value = `${lat}, ${lng}`;
                    }
                } else {
                    input.value = decodeURIComponent(value);
                }
                waypointsContainer.appendChild(container);
            }

            // Add empty waypoint if needed
            const waypoints = document.querySelectorAll('.waypoint');
            if (waypoints.length < 12 && 
                waypoints[waypoints.length - 1]?.value.trim() !== '') {
                waypointsContainer.appendChild(createWaypointInput());
            }
            
            if (waypointParams.length > 0) {
                calculateRouteIfPossible();
            } else {
                updatePageTitle();
            }
        }

        // Modify calculateRouteIfPossible to update URL and title after successful route calculation
        const originalCalculateRouteIfPossible = calculateRouteIfPossible;
        calculateRouteIfPossible = async function() {
            await originalCalculateRouteIfPossible();
            updateURLParameters();
            updatePageTitle();
        };

        // Add URL update on browser navigation
        window.addEventListener('popstate', loadRouteFromURL);
        ////////////////// KONIEC FUNKCJE ODPOWIEDZIALNE ZA BUDOWE LINKU + ZMIANĘ PAGE TITLE

        // Funkcja do resetowania aplikacji
        function restartApp() {
            // Wyczyść kontener punktów trasy
            const waypointsContainer = document.getElementById('waypoints-container');
            waypointsContainer.innerHTML = '';

            // Ukryj wszystkie wskaźniki odległości
            document.querySelectorAll('.distance-indicator').forEach(indicator => indicator.remove());
            
            // Wyczyść mapę
            clearMap();
            
            // Wyczyść całkowicie informacje o trasie
            document.getElementById('route-info').innerHTML = `
                <div class="route-info-label">${translations.routeInfo}</div>
                <div class="route-stats-container">
                    <div class="route-stat">
                        <div class="stat-label">${translations.distance}</div>
                        <div class="stat-value">--</div>
                    </div>
                    <div class="route-stat">
                        <div class="stat-label">${translations.time}</div>
                        <div class="stat-value">--</div>
                    </div>
                </div>
                <div class="route-stat">
                    <div class="stat-label">${translations.roadCharges}</div>
                    <div class="stat-value">--</div>
                </div>
                <div class="route-stat">
                    <div class="stat-label">${translations.fuelCosts}</div>
                    <div class="stat-value">--</div>
                </div>
            `;
            
            // Zresetuj zapisane punkty geocoded
            geocodedPoints.clear();
            
            // Dodaj pojedyncze puste pole
            waypointsContainer.appendChild(createWaypointInput());
            
            // Ustaw focus na nowym polu
            const firstWaypoint = document.querySelector('.waypoint');
            if (firstWaypoint) {
                firstWaypoint.focus();
            }
            
            // Zresetuj tytuł strony
            document.title = 'Transport Nomad';
            
            // Wyczyść parametry URL
            window.history.pushState({}, '', window.location.pathname);
            
            // Zresetuj widok mapy do domyślnego
            map.setCenter({ lat: 50.0, lng: 15.0 });
            map.setZoom(5.5);
        }

        function initializeApplication() {
            // Inicjalizacja przycisków pojazdów
            initializeVehicleButtons();

            // Wczytaj stan wyłączonych obszarów
            loadExcludedAreas();

            // Pozostała część funkcji bez zmian...
            const firstWaypoint = document.querySelector('.waypoint');
            if (firstWaypoint) {
                firstWaypoint.focus();
            }
            
            initializeUITranslations();
            loadRouteFromURL();
            updatePageTitle();
            
            const restartButton = document.getElementById('restart-button');
            if (restartButton) {
                restartButton.addEventListener('click', restartApp);
            }
        }

        // Pojedynczy listener DOMContentLoaded
        document.addEventListener('DOMContentLoaded', initializeApplication);

        // Dodaj obsługę skrótu klawiszowego Ctrl+I
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key.toLowerCase() === 'i') {
                e.preventDefault(); // Zapobiegamy domyślnej akcji przeglądarki
                restartApp();
            }
        });
    </script>
</body>
</html
