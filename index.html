<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transpot Nomad</title>
    <script src="https://js.api.here.com/v3/3.1/mapsjs-core.js"></script>
    <script src="https://js.api.here.com/v3/3.1/mapsjs-service.js"></script>
    <script src="https://js.api.here.com/v3/3.1/mapsjs-ui.js"></script>
    <script src="https://js.api.here.com/v3/3.1/mapsjs-mapevents.js"></script>
    <link rel="stylesheet" href="https://js.api.here.com/v3/3.1/mapsjs-ui.css"/>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            display: flex;
            height: 100vh;
        }

        #sidebar {
            position: relative;
            width: 300px;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.95);
            border-right: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 16px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
            height: 100vh;
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        /* Delikatniejszy scrollbar */
        #sidebar::-webkit-scrollbar {
            display: none;
        }

        #map-container {
            flex: 1;
            height: 100%;
        }

        .waypoint-number {
            position: absolute;
            left: -8px;
            /* Zmieniamy top i transform aby centrować względem pola adresu */
            top: 19px; /* Połowa wysokości waypoint-box (który ma padding 8px góra i dół) */
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            background: white;
            color: #0066CC;
            border: 1.5px solid #0066CC;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            cursor: grab;
            user-select: none;
            z-index: 10;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .waypoint-number:hover {
            background: #f0f5ff;
            box-shadow: 0 2px 8px rgba(0, 102, 204, 0.15);
        }

        .waypoint-number:active {
            cursor: grabbing;
            background: #e5efff;
            transform: translateY(-50%) scale(0.95);
        }

        /* Dodajemy specjalny styl dla stanu przeciągania */
        .waypoint-container.dragging .waypoint-number {
            background: #0066CC;
            color: white;
            box-shadow: 0 4px 12px rgba(0, 102, 204, 0.25);
        }

        .waypoint-box:hover {
            border-color: #0066CC;
            box-shadow: 0 2px 8px rgba(0, 102, 204, 0.15);
        }

        .waypoint-number:active {
            cursor: grabbing;
        }

        .waypoint-container.dragging {
            position: fixed;
            z-index: 1000;
            transform: translateY(var(--y));
            width: var(--width);
        }

        .waypoint-container.shift-down {
            transform: translateY(40px);
        }


        .waypoint-box {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            background: white;
            position: relative; /* Dodaj to */
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }


        .waypoint {
            width: 100%;
            border: none;
            font-size: 14px;
            background: transparent;
            margin-bottom: 2px;
            color: #323130;
        }

        .waypoint:focus {
            outline: none;
        }

        .suggestions-container {
            position: absolute;
            top: 75%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .suggestion-item {
            padding: 8px 12px;
            cursor: pointer;
        }

        .suggestion-item:hover {
            background-color: #f0f0f0;
        }

        .suggestion-item.selected {
            background-color: #e6e6e6;
        }

        #route-info {
            position: relative;
            margin-top: 16px;
            padding: 16px;
            background-color: white;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05); /* Dodajemy ten sam cień co mają pola adresowe */
        }

        /* Możemy też dodać hover efekt, tak jak mają pola adresowe */
        #route-info:hover {
            border-color: #0066CC;
            box-shadow: 0 2px 8px rgba(0, 102, 204, 0.15);
        }

        .route-info-label {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: white;
            padding: 0 8px;
            font-size: 13px;
            color: #666;
        }

        .remove-waypoint {
            position: absolute;
            right: -18px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #ff4444;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            padding: 2px;
            z-index: 1;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .remove-waypoint:hover {
            color: #cc0000;
        }

        .error-message {
            color: #ff4444;
            font-size: 12px;
            margin-top: 4px;
        }

        .route-settings {
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            background-color: rgba(249, 249, 249, 0.9);
            padding: 24px 20px;
            margin: 0 -20px;
        }

        .route-settings .row {
            margin-bottom: 12px;  /* zmniejszony margines między rzędami */
        }

        .route-settings p {
            margin-bottom: 4px;  /* mniejszy odstęp między nagłówkiem a przyciskami */
            font-size: 13px;
            color: #323130;
        }

        .route-settings .button-group {
            display: flex;
            gap: 4px;  /* mniejszy odstęp między przyciskami */
            flex-wrap: wrap;
        }

        .route-settings button {
        padding: 6px 4px; /* zmniejszamy padding poziomy */
        border: 1px solid rgba(0, 0, 0, 0.1);
        background-color: white;
        color: #323130;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px; /* domyślny rozmiar czcionki */
        transition: all 0.2s ease;
        flex: 1 1 0;
        text-align: center;
        font-weight: 500;
        white-space: nowrap;
        overflow: visible; /* pozwalamy na widoczność całego tekstu */
        }
        .route-settings button:hover {
            background-color: #f3f2f1;
            border-color: rgba(0, 0, 0, 0.15);
        }


        .route-settings button.active {
            background-color: #0066CC;
            color: white;
            border-color: transparent;
            box-shadow: 0 2px 4px rgba(0, 102, 204, 0.25);
        }

        #excluded-areas button.active {
            background-color: #dc3545;
            border-color: #dc3545;
            color: white;
        }

        .select-group {
            display: flex;
            gap: 8px;  /* mniejszy odstęp między selectami */
        }

        .select-container {
            flex: 1;
        }

        .route-settings select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            background-color: white;
            font-size: 13px;
            color: #323130;
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 6px 8px;  /* mniejszy padding */
            font-size: 12px;  /* mniejsza czcionka */
        }

        /* Specjalne style dla przycisków wykluczonych obszarów */
        #excluded-areas.button-group {
            gap: 8px;  /* większy odstęp dla tych konkretnych przycisków */
        }

        #excluded-areas button {
            flex: 0 1 calc(50% - 4px);  /* każdy przycisk zajmuje połowę szerokości */
        }

        .route-settings select:hover {
            border-color: #0066CC;
        }


        .route-settings select:focus {
            outline: none;
            border-color: #0066CC;
            box-shadow: 0 0 0 2px rgba(0, 102, 204, 0.1);
        }
        #restart-button {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 6px 12px;
            background-color: white;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: #323130;
            transition: all 0.2s ease;
            z-index: 1;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            font-weight: 500;
        }

        #restart-button:hover {
            background-color: #f3f2f1;
            border-color: rgba(0, 0, 0, 0.15);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        #restart-button:active {
            background-color: #edebe9;
            transform: scale(0.98);
        }

        #map-container {
            flex: 1;
            height: 100%;
            position: relative;  /* dodajemy, żeby przycisk był względem map-container */
        }
        .toll-summary {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toll-details-toggle {
            background: none;
            border: none;
            padding: 0 4px;
            cursor: pointer;
            color: #0066CC;
            font-size: 12px;
        }

        .toll-details {
            margin-top: 8px;
            padding-left: 12px;
            border-left: 2px solid #eee;
        }

        .country-toll {
            margin: 4px 0;
            color: #666;
        }
        .route-bubble {
            position: absolute;
            background: white;
            border: 1px solid #666;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            white-space: nowrap;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .alternative-route {
            cursor: pointer;
        }
        /* InfoBubble styles */
        .H_ib {
            padding: 0 !important;
            margin: 0 !important;
            box-shadow: none !important;
            background: white !important;
            border: 1px solid #666 !important;
            border-radius: 4px !important;
            min-width: 0 !important;
            max-width: none !important;
        }

        .H_ib_body {
            padding: 4px 6px !important;
            margin: 0 !important;
            min-width: 0 !important;
            max-width: none !important;
        }

        .H_ib_content {
            margin: 0 !important;
            padding: 0 !important;
            font-size: 12px !important;
            white-space: nowrap !important;
            color: black !important;
            line-height: 1.5 !important;
            min-width: 0 !important;
            max-width: none !important;
            display: inline !important;
        }

        .H_ib_close {
            display: none !important;
        }
        .H_ib_tail {
            display: none !important;
        }

        .route-stat {
            display: flex;
            flex-direction: column;
        }

        .route-stat:last-child {
            margin-bottom: 0; /* Usuwa dolny margines z ostatniego elementu */
        }

        .stat-label {
            font-size: 13px; /* Zwiększone z 11px */
            color: #666;
            margin-bottom: 3px; /* Zwiększony margin */
        }

        .stat-value {
            font-size: 16px; /* Zwiększone z 14px */
            color: #323130;
            font-weight: 500;
        }

        .route-stats-container {
            display: flex;
            gap: 20px; /* Zwiększony gap */
            margin-bottom: 16px; /* Zwiększony margin */
        }

        /* Dostosowanie rozmiaru tekstu w szczegółach opłat */
        .country-toll {
            font-size: 14px; /* Zwiększone */
            margin: 6px 0; /* Zwiększony margin */
        }

        /* Dostosowanie przycisku szczegółów */
        .toll-details-toggle {
            font-size: 14px; /* Zwiększone */
            padding: 0 6px; /* Zwiększony padding */
        }

        /* Dostosowanie kontenerów dla promów */
        .ferry-item {
            font-size: 14px; /* Zwiększone */
            margin-top: 4px;
        }
        
        /* odległości między punktami */
        .distance-indicator {
            text-align: left;
            color: #666;
            font-size: 11px;
            padding: 4px 0;
            margin: -3px 0;
            visibility: hidden;
        }

        .distance-indicator.visible {
            visibility: visible;
        }

        .waypoint-container {
            position: relative;
            padding-left: 18px;
            margin-bottom: 0; /* Zmień z 10px na 0 */
        }
        #vehicle-selection {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
            margin-bottom: 12px;
            justify-content: flex-start;
        }

        #vehicle-selection button {
            width: 60px; /* zmniejszamy z 70px na 60px */
            flex: 0 0 60px;
            padding: 4px 2px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            gap: 2px;
            align-items: center;
        }

        .vehicle-name {
            font-size: 12px;
            font-weight: 500;
            margin-bottom: 1px;
        }

        .vehicle-details {
            display: flex;
            flex-direction: column;
            gap: 1px;
            align-items: center;
            font-size: 9px;
            opacity: 0.8;
            width: 100%;
        }

        .vehicle-details span {
            background: rgba(0, 0, 0, 0.05);
            padding: 1px 3px;
            border-radius: 2px;
            white-space: nowrap;
            width: 90%;
            text-align: center;
        }

        #vehicle-selection button.active {
            background-color: #0066CC;
            color: white;
            border-color: #0066CC;
            box-shadow: 0 2px 4px rgba(0, 102, 204, 0.15);
        }

        #vehicle-selection button.active .vehicle-details span {
            background: rgba(255, 255, 255, 0.15);
            color: white;
        }

        .work-time-section {
            margin: 8px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .main-info {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .time-controls {
            display: inline-flex;
            gap: 4px;
            margin-left: 8px;
        }

        .time-adjust {
            padding: 2px 6px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            min-width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .time-adjust:hover {
            background: #f3f2f1;
            border-color: #0066CC;
        }
        
        .excluded-lists-container {
            display: flex;
            flex-direction: column;
            gap: 8px;  /* Reduced gap */
            width: 100%;
        }

        .dropdown-container {
            position: relative;
            width: 100%;
        }

        .dropdown-selected {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;  /* Reduced padding */
            background: white;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;  /* Smaller font */
            color: #666;  /* Lighter text color */
            transition: all 0.2s ease;
        }
        .dropdown-selected span {
            color: #777;
            font-size: 12px;
        }
        #excluded-areas-text {
            font-size: 13px;
            color: #777;
            margin-bottom: 8px;
        }

        .dropdown-selected:hover {
            border-color: #0066CC;
            box-shadow: 0 2px 8px rgba(0, 102, 204, 0.15);
        }

        .dropdown-selected.active {
            border-color: #0066CC;
            box-shadow: 0 2px 8px rgba(0, 102, 204, 0.15);
        }

        .dropdown-arrow {
            font-size: 9px;
            transition: transform 0.2s ease;
            color: #999;
        }

        .dropdown-selected.active .dropdown-arrow {
            transform: rotate(180deg);
        }

        .dropdown-menu {
            position: absolute;
            bottom: 100%;
            left: 0;
            right: 0;
            margin-bottom: 5px;
            background: white;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            max-height: 250px;
            overflow-y: auto;
            z-index: 100;
            display: none;
            box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.1);
        }

        .dropdown-search {
            padding: 8px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            position: sticky;
            top: 0;
            background: white;
            z-index: 1;
        }

        .dropdown-search-input {
            width: 100%;
            padding: 5px 8px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            font-size: 12px;  /* Smaller font */
        }

        .dropdown-search-input:focus {
            outline: none;
            border-color: #0066CC;
        }

        .dropdown-items {
            max-height: 180px;
            overflow-y: auto;
        }

        .dropdown-item {
            padding: 5px 8px;  /* Smaller padding */
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;  /* Smaller font */
        }

        .dropdown-item:hover {
            background-color: #f8f8f8;
        }

        .dropdown-item.selected {
            background-color: rgba(0, 102, 204, 0.1);
        }

        .dropdown-item img {
            width: 16px;
            height: 12px;
            object-fit: cover;
        }

        .dropdown-item-flag {
            width: 16px;
            height: 12px;
            display: inline-block;
            margin-right: 8px;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }

        .selected-items {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;  /* Smaller gap */
        }

        .selected-item {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;  /* Smaller font */
            display: flex;
            align-items: center;
            gap: 3px;
            border: 1px solid rgba(0, 0, 0, 0.08);
        }

        .selected-item-remove {
            color: #0066CC;
            cursor: pointer;
            font-weight: bold;
        }

        .more-indicator {
            font-size: 11px;
            color: #888;
            margin-left: 3px;
        }

        #traffic-bans-button {
            position: absolute;
            top: 10px;
            left: 140px; /* Pozycja po przycisku restart */
            padding: 6px 12px;
            background-color: white;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: #323130;
            transition: all 0.2s ease;
            z-index: 1;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            font-weight: 500;
        }

        #traffic-bans-button:hover {
            background-color: #f3f2f1;
            border-color: rgba(0, 0, 0, 0.15);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        #traffic-bans-button:active {
            background-color: #edebe9;
            transform: scale(0.98);
        }

        #traffic-bans-button.active {
            background-color: #0066CC;
            color: white;
        }
        #traffic-bans-sidebar {
            position: fixed;
            top: 0;
            right: -350px;
            width: 320px;
            height: 100vh;
            background-color: white;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            transition: right 0.3s ease;
            display: flex;
            flex-direction: column;
            padding: 0;
            overflow: hidden;
        }

        #traffic-bans-sidebar.visible {
            right: 0;
        }

        .traffic-bans-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        .traffic-bans-header h3 {
            margin: 0;
            font-size: 16px;
        }

        #close-traffic-bans-button {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #666;
        }

        #traffic-bans-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
        }

        #bans-days-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .ban-day-card {
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .ban-day-header {
            background-color: #f0f4f8;
            padding: 12px 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        .ban-day-header:hover {
            background-color: #e6ecf2;
        }

        .ban-day-header.active {
            background-color: #0066CC;
            color: white;
        }

        .ban-day-header.active .ban-day-name,
        .ban-day-header.active .ban-day-date {
            color: white;
        }

        .ban-day-date {
            font-size: 16px;
            font-weight: 500;
            color: #0066CC;
        }

        .ban-day-name {
            font-size: 14px;
            color: #666;
        }

        .ban-day-content {
            padding: 10px 0;
        }

        .today-badge {
            background-color: #28a745;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
        }
        /* Style dla elementów krajów */
        .ban-country-item {
            margin: 8px 0 4px 0; /* Zwiększony margines górny */
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            padding-bottom: 4px;
        }

        .ban-country-header {
            display: flex;
            align-items: center;
            padding: 8px 10px; /* Dodany padding po bokach */
            cursor: pointer; /* Kursor pokazuje, że element jest klikalny */
            transition: background-color 0.2s ease;
        }

        .ban-country-header:hover {
            background-color: #f5f9ff; /* Delikatne podświetlenie przy najechaniu */
        }

        .ban-country-flag {
            width: 20px;
            height: 15px;
            margin-right: 8px;
            background-size: cover;
            flex-shrink: 0;
        }

        .ban-country-name {
            font-weight: 500;
            flex-grow: 1;
            flex-basis: 25%;
        }

        .ban-country-time {
            color: #333;
            font-size: 13px;
            text-align: right;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .ban-warning-icon {
            color: #ff6600;
            margin-left: 5px;
            flex-shrink: 0;
        }

        .ban-details-button {
            color: #0066CC;
            border: 1px solid #0066CC;
            border-radius: 4px;
            padding: 2px 8px;
            font-size: 12px;
            background: white;
            cursor: pointer;
            flex-shrink: 0;
        }

        .ban-details-button:hover {
            background-color: #f0f7ff;
        }

        .ban-area-item {
            padding: 4px 0 4px 28px;
            display: flex;
            align-items: center;
            border-top: 1px dotted rgba(0, 0, 0, 0.05);
        }

        .ban-area-icon {
            margin-right: 6px;
            flex-shrink: 0;
        }

        .ban-area-name {
            flex-grow: 1;
        }

        .ban-area-type {
            font-size: 11px;
            color: #666;
            margin-left: 5px;
            font-style: italic;
        }
        .ban-warning-text {
            margin-top: 5px;
            padding: 5px 8px;
            background-color: #fff3e0;
            border-left: 3px solid #ff9800;
            font-size: 12px;
            color: #e65100;
            display: none; /* Domyślnie ukryty, będzie pokazywany razem z obszarami */
        }

        .ban-area-item.selected {
            background-color: #e6f0ff;
            border-left: 3px solid #0066CC;
        }

        .ban-area-item {
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .ban-area-item:hover {
            background-color: #f0f7ff;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <div id="waypoints-container"></div>
        <div id="route-info">
            <div class="route-info-label" data-translation="routeInfo">Route information:</div>
            <div class="route-stats-container">
                <div class="route-stat">
                    <div class="stat-label" data-translation="distance">Distance</div>
                    <div class="stat-value">--</div>
                </div>
                <div class="route-stat">
                    <div class="stat-label" data-translation="time">Time</div>
                    <div class="stat-value">--</div>
                </div>
            </div>
            <div class="route-stat">
                <div class="stat-label" data-translation="roadCharges">Road Charges</div>
                <div class="stat-value">--</div>
            </div>
            <div class="route-stat">
                <div class="stat-label" data-translation="fuelCosts">Fuel costs</div>
                <div class="stat-value">--</div>
            </div>
            <div class="route-stat">
                <div class="stat-label" data-translation="otherCosts">Other costs</div>
                <div class="stat-value">--</div>
            </div>
        </div>
        <!-- Panel ustawień trasy - dodaj przed zamknięciem diva "sidebar" -->
        <div id="route-settings" class="route-settings" style="margin-top: auto; padding: 20px;">
            <h3 style="margin-bottom: 15px; font-size: 16px;" id="settings-title"></h3>
            
            <div class="row">
                <p>Wybierz pojazd:</p>
                <div class="button-group" id="vehicle-selection">
                    <!-- Przyciski będą generowane przez JavaScript -->
                </div>
            </div>

            <!-- Fifth Row: Excluded Areas -->
            <div class="row">
                <p id="excluded-areas-text"></p>
                <div class="excluded-lists-container">
                    <div class="dropdown-container">
                        <div class="dropdown-selected" id="excluded-items-selected">
                            <span>Wyłącz kraje i obszary...</span>
                            <i class="dropdown-arrow">▼</i>
                        </div>
                        <div class="dropdown-menu" id="excluded-items-menu">
                            <div class="dropdown-search">
                                <input type="text" placeholder="Szukaj..." class="dropdown-search-input" id="items-search">
                            </div>
                            <div id="selected-items-section" style="display: none;">
                                <div class="dropdown-section-title selected-title" style="padding: 8px 12px; font-size: 12px; color: #666; background: #f5f5f5;">Wybrane</div>
                                <div id="selected-items-container"></div>
                                <div style="border-bottom: 1px solid #eee; margin: 4px 0;"></div>
                            </div>
                            <div class="dropdown-section-title" style="padding: 8px 12px; font-size: 12px; color: #666; background: #f5f5f5;">Kraje</div>
                            <div id="countries-items-container"></div>
                            <div style="border-bottom: 1px solid #eee; margin: 4px 0;"></div>
                            <div class="dropdown-section-title" style="padding: 8px 12px; font-size: 12px; color: #666; background: #f5f5f5;">Obszary</div>
                            <div id="areas-items-container"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="map-container">
        <button id="restart-button">Restart [CTRL+I]</button>
        <button id="traffic-bans-button" data-translation="trafficBans">Zakazy</button>
    </div>
    <div id="traffic-bans-sidebar">
        <div class="traffic-bans-header">
            <h3 data-translation="truckRestrictions">Zakazy dla ciężarówek</h3>
            <button id="close-traffic-bans-button">&times;</button>
        </div>
        <div id="traffic-bans-content">
            <div id="bans-days-list"></div>
        </div>
        <button id="toggle-labels-button" style="background-color: white; color: #333; border: 1px solid #ddd; border-radius: 4px; padding: 4px 8px; margin-right: 10px; font-size: 12px;">Ukryj etykiety</button>
    </div>
	<script>
        let geocodedPoints = new Map();

        function getPreferredLanguage() {
            const supportedLanguages = ['de', 'fr', 'it', 'es', 'pl'];
            let browserLang = navigator.language.slice(0, 2).toLowerCase();
            return supportedLanguages.includes(browserLang) ? browserLang : 'en';
        }

        function getUITranslations(lang) {
            const translations = {
                en: {
                    inputPlaceholder: 'Enter address or GPS coordinates',
                    routeInfo: 'Route information:',
                    distance: 'Distance',
                    time: 'Time',
                    minutes: 'minutes',
                    routeError: 'An error occurred while calculating the route',
                    addressNotFound: 'Address not found',
                    geocodingError: 'Geocoding error',
                    addStartPoint: 'Add start point',
                    addViaPoint: 'Add via point',
                    addEndPoint: 'Add end point',
                    coordinates: 'Coordinates',
                    addStartFirst: 'Add start point first',
                    routeSettings: 'Route Settings',
                    roadCharges: 'Road Charges',
                    noRoadCharges: 'No Road Charges',
                    withoutFerryTrainKm: 'without ferry/train km',
                    fuelCosts: 'Fuel costs',
                    consumption: 'Consumption',
                    totalFuelNeeded: 'Total fuel needed',
                    globalPrice: 'global price',
                    costPerKm: '/km',
                    fuelConsumption: 'Consumption',
                    fuelInCountry: 'Fuel in country',
                    fuel: 'Fuel',
                    selectVehicle: 'Select vehicle',
                    lowestPrice: 'Lowest price',
                    workingTime: 'Working time',
                    days: 'days',
                    hours: 'hours',
                    theoreticalTime: 'Theoretical time',
                    actualTime: 'Actual time',
                    additionalCosts: 'Additional costs',
                    otherCosts: 'Other costs',
                    fixedCosts: 'Fixed costs',
                    costsPerKm: 'Costs per km',
                    dailyRate: 'Daily rate',
                    totalCosts: 'Total costs',
                    excludeCountriesAndAreas: "Exclude countries and areas:",
                    excludeCountriesAndAreasPlaceholder: "Exclude countries and areas...",
                    selected: "Selected",
                    countries: "Countries",
                    areas: "Areas",
                    search: "Search...",
                    more: "more",
                    trafficBans: 'Restrictions',
                    truckRestrictions: 'Truck Restrictions',
                },
                de: {
                    inputPlaceholder: 'Adresse oder GPS-Koordinaten eingeben',
                    routeInfo: 'Routeninformation:',
                    distance: 'Entfernung',
                    time: 'Zeit',
                    minutes: 'Minuten',
                    routeError: 'Bei der Routenberechnung ist ein Fehler aufgetreten',
                    addressNotFound: 'Adresse nicht gefunden',
                    geocodingError: 'Geokodierungsfehler',
                    addStartPoint: 'Startpunkt hinzufügen',
                    addViaPoint: 'Viapunkt hinzufügen',
                    addEndPoint: 'Endpunkt hinzufügen',
                    coordinates: 'Koordinaten',
                    addStartFirst: 'Fügen Sie zuerst den Startpunkt hinzu',
                    routeSettings: 'Routeneinstellungen',
                    roadCharges: 'Straßengebühren',
                    noRoadCharges: 'Keine Straßengebühren',
                    withoutFerryTrainKm: 'ohne Fähre/Zug km',
                    fuelCosts: 'Kraftstoffkosten',
                    consumption: 'Verbrauch',
                    totalFuelNeeded: 'Gesamter Kraftstoffbedarf',
                    globalPrice: 'Globalpreis',
                    costPerKm: '/km',
                    fuelConsumption: 'Verbrauch',
                    fuelInCountry: 'Kraftstoff im Land',
                    fuel: 'Kraftstoff',
                    selectVehicle: 'Fahrzeug auswählen',
                    lowestPrice: 'Niedrigster Preis',
                    totalCosts: 'Gesamtkosten',
                    excludeCountriesAndAreas: "Länder und Gebiete ausschließen:",
                    excludeCountriesAndAreasPlaceholder: "Länder und Gebiete ausschließen...",
                    selected: "Ausgewählt",
                    countries: "Länder",
                    areas: "Gebiete",
                    search: "Suchen...",
                    more: "mehr",
                    trafficBans: 'Fahrverbote',
                    truckRestrictions: 'LKW-Fahrverbote',
                },
                fr: {
                    inputPlaceholder: 'Entrez l\'adresse ou les coordonnées GPS',
                    routeInfo: 'Informations sur l\'itinéraire :',
                    distance: 'Distance',
                    time: 'Temps',
                    minutes: 'minutes',
                    routeError: 'Une erreur s\'est produite lors du calcul de l\'itinéraire',
                    addressNotFound: 'Adresse introuvable',
                    geocodingError: 'Erreur de géocodage',
                    addStartPoint: 'Ajouter le point de départ',
                    addViaPoint: 'Ajouter un point intermédiaire',
                    addEndPoint: 'Ajouter le point d\'arrivée',
                    coordinates: 'Coordonnées',
                    addStartFirst: 'Ajoutez d\'abord le point de départ',
                    routeSettings: 'Paramètres d\'itinéraire',
                    roadCharges: 'Péages routiers',
                    noRoadCharges: 'Pas de péages',
                    withoutFerryTrainKm: 'sans km ferry/train',
                    fuelCosts: 'Coûts de carburant',
                    consumption: 'Consommation',
                    totalFuelNeeded: 'Carburant total nécessaire',
                    globalPrice: 'prix global',
                    costPerKm: '/km',
                    fuelConsumption: 'Consommation',
                    fuelInCountry: 'Carburant dans le pays',
                    fuel: 'Carburant',
                    selectVehicle: 'Sélectionner le véhicule',
                    lowestPrice: 'Prix le plus bas',
                    totalCosts: 'Coûts totaux',
                    excludeCountriesAndAreas: "Exclure pays et zones:",
                    excludeCountriesAndAreasPlaceholder: "Exclure pays et zones...",
                    selected: "Sélectionné",
                    countries: "Pays",
                    areas: "Zones",
                    search: "Rechercher...",
                    more: "plus",
                    trafficBans: 'Restrictions',
                    truckRestrictions: 'Restrictions pour camions',
                },
                it: {
                    inputPlaceholder: 'Inserisci indirizzo o coordinate GPS',
                    routeInfo: 'Informazioni sul percorso:',
                    distance: 'Distanza',
                    time: 'Tempo',
                    minutes: 'minuti',
                    routeError: 'Si è verificato un errore durante il calcolo del percorso',
                    addressNotFound: 'Indirizzo non trovato',
                    geocodingError: 'Errore di geocodifica',
                    addStartPoint: 'Aggiungi punto di partenza',
                    addViaPoint: 'Aggiungi punto intermedio',
                    addEndPoint: 'Aggiungi punto di arrivo',
                    coordinates: 'Coordinate',
                    addStartFirst: 'Aggiungi prima il punto di partenza',
                    routeSettings: 'Impostazioni percorso',
                    roadCharges: 'Pedaggi stradali',
                    noRoadCharges: 'Nessun pedaggio',
                    withoutFerryTrainKm: 'senza km nave/treno',
                    fuelCosts: 'Costi carburante',
                    consumption: 'Consumo',
                    totalFuelNeeded: 'Carburante totale necessario',
                    globalPrice: 'prezzo globale',
                    costPerKm: '/km',
                    fuelConsumption: 'Consumo',
                    fuelInCountry: 'Carburante nel paese',
                    fuel: 'Carburante',
                    selectVehicle: 'Seleziona veicolo',
                    lowestPrice: 'Prezzo più basso',
                    totalCosts: 'Costi totali',
                    excludeCountriesAndAreas: "Escludi paesi e aree:",
                    excludeCountriesAndAreasPlaceholder: "Escludi paesi e aree...",
                    selected: "Selezionato",
                    countries: "Paesi",
                    areas: "Aree",
                    search: "Cerca...",
                    more: "più",
                    trafficBans: 'Restrictions',
                    truckRestrictions: 'Restrictions pour camions',
                    trafficBans: 'Divieti',
                    truckRestrictions: 'Divieti per camion',
                },
                es: {
                    inputPlaceholder: 'Introduce la dirección o coordenadas GPS',
                    routeInfo: 'Información de la ruta:',
                    distance: 'Distancia',
                    time: 'Tiempo',
                    minutes: 'minutos',
                    routeError: 'Se produjo un error al calcular la ruta',
                    addressNotFound: 'Dirección no encontrada',
                    geocodingError: 'Error de geocodificación', 
                    addStartPoint: 'Añadir punto de inicio',
                    addViaPoint: 'Añadir punto intermedio',
                    addEndPoint: 'Añadir punto final',
                    coordinates: 'Coordenadas',
                    addStartFirst: 'Añade primero el punto de inicio',
                    routeSettings: 'Configuración de ruta',
                    roadCharges: 'Peajes',
                    noRoadCharges: 'Sin peajes',
                    withoutFerryTrainKm: 'sin km de ferry/tren',
                    fuelCosts: 'Costes de combustible',
                    consumption: 'Consumo',
                    totalFuelNeeded: 'Combustible total necesario',
                    globalPrice: 'precio global',
                    costPerKm: '/km',
                    fuelConsumption: 'Consumo',
                    fuelInCountry: 'Combustible en el país',
                    fuel: 'Combustible',
                    selectVehicle: 'Seleccionar vehículo',
                    lowestPrice: 'Precio más bajo',
                    totalCosts: 'Costes totales',
                    excludeCountriesAndAreas: "Excluir países y áreas:",
                    excludeCountriesAndAreasPlaceholder: "Excluir países y áreas...",
                    selected: "Seleccionado",
                    countries: "Países",
                    areas: "Áreas",
                    search: "Buscar...",
                    more: "más",
                    trafficBans: 'Restricciones',
                    truckRestrictions: 'Restricciones para camiones',
                    
                },
                pl: {
                    inputPlaceholder: 'Wpisz adres lub współrzędne GPS',
                    routeInfo: 'Informacje o trasie:',
                    distance: 'Dystans',
                    time: 'Czas jazdy',
                    minutes: 'minut',
                    routeError: 'Wystąpił błąd podczas wyznaczania trasy',
                    addressNotFound: 'Nie znaleziono adresu',
                    geocodingError: 'Błąd geokodowania', 
                    addStartPoint: 'Dodaj punkt startowy',
                    addViaPoint: 'Dodaj punkt pośredni',
                    addEndPoint: 'Dodaj punkt końcowy',
                    coordinates: 'Koordynaty',
                    addStartFirst: 'Najpierw dodaj punkt startowy',
                    routeSettings: 'Ustawienia trasy',
                    roadCharges: 'Opłaty drogowe',
                    noRoadCharges: 'Brak opłat drogowych',
                    withoutFerryTrainKm: 'bez km prom/kolej',
                    fuelCosts: 'Koszty paliwa',
                    consumption: 'Spalanie',
                    totalFuelNeeded: 'Całkowite zużycie paliwa',
                    globalPrice: 'cena globalna',
                    costPerKm: '/km',
                    fuelConsumption: 'Spalanie',
                    fuelInCountry: 'Paliwo w kraju',
                    fuel: 'Paliwo',
                    selectVehicle: 'Wybierz pojazd',
                    lowestPrice: 'Najniższa cena',
                    workingTime: 'Czas pracy',
                    days: 'dni',
                    hours: 'godz',
                    theoreticalTime: 'Czas teoretyczny',
                    actualTime: 'Czas rzeczywisty',
                    additionalCosts: 'Koszty dodatkowe',
                    otherCosts: 'Pozostałe koszty',
                    fixedCosts: 'Koszty stałe',
                    costsPerKm: 'Koszty za kilometr',
                    dailyRate: 'Stawka dzienna',
                    totalCosts: 'Koszty całkowite',
                    excludeCountriesAndAreas: "Wyłącz kraje i obszary:",
                    excludeCountriesAndAreasPlaceholder: "Wyłącz kraje i obszary...",
                    selected: "Wybrane",
                    countries: "Kraje",
                    areas: "Obszary",
                    search: "Szukaj...",
                    more: "więcej",
                    trafficBans: 'Zakazy',
                    truckRestrictions: 'Zakazy dla ciężarówek',
                }
            };
            return translations[lang] || translations.en;
        }

        const vehicles = [
            {
                id: 'mega',
                name: 'MEGA',
                weight: 40000,
                truckAxles: 2,    
                trailerAxles: 3,
                trailerCount: 1,
                euroClass: '6',
                co2Class: '1',
                fuelConsumption: 27,
                adblueConsumption: 1.5,          
                costPerKm: 0.20,
                height: 400,
                width: 255,
                length: 1650, 
                workingDays: 240,
                avgKm: 12500,
                advFixedPerMonth: 7000,
                advVariablePerKM: 0.00,
                simpleCosts: false,  // ten będzie miał pełne wyliczenia
                simpleCostValuePerKM: 0
            },
            {
                id: 'standard',
                name: 'Standard',
                weight: 40000,
                truckAxles: 2,
                trailerAxles: 3,
                trailerCount: 1,
                euroClass: '6',
                co2Class: '1',
                fuelConsumption: 27,
                adblueConsumption: 1.5,
                costPerKm: 0.15,
                height: 400,
                width: 255,
                length: 1650,
                workingDays: 240,
                avgKm: 12500,
                advFixedPerMonth: 6500,
                advVariablePerKM: 0.00,
                simpleCosts: false,  // ten będzie miał pełne wyliczenia
                simpleCostValuePerKM: 0
            },
            {
                id: 'jumbo',
                name: 'JUMBO',
                weight: 30000,
                truckAxles: 2,      
                trailerAxles: 1,
                trailerCount: 1,
                euroClass: '6',
                co2Class: '1',
                fuelConsumption: 24,
                adblueConsumption: 1.5,
                costPerKm: 0.10,
                height: 400,
                width: 255,
                length: 1750,
                workingDays: 250,
                avgKm: 12000,
                advFixedPerMonth: 6000,
                advVariablePerKM: 0.00,
                simpleCosts: false,  // ten będzie miał pełne wyliczenia
                simpleCostValuePerKM: 0
            },
            {
                id: 'solo',
                name: 'Solo',
                weight: 8000,
                truckAxles: 2,    
                trailerAxles: 0,
                trailerCount: 0,
                euroClass: '6',
                co2Class: '1',
                fuelConsumption: 20,
                adblueConsumption: 1.5,
                costPerKm: 0.10,
                height: 350,
                width: 255,
                length: 850,
                workingDays: 250,
                avgKm: 12000,
                advFixedPerMonth: 4500,
                advVariablePerKM: 0.35,
                simpleCosts: true,  // ten będzie miał uproszczone
                simpleCostValuePerKM: 1.35
            }
        ];

        const defaultFuelPrices = {
            'POL': 1.23,
            'DEU': 1.46,
            'LUX': 1.28,
            'CZE': 1.19,
            'SVK': 1.29,
            'HUN': 1.25,
            'AUT': 1.37,
            'ITA': 1.48,
            'FRA': 1.31,
            'ESP': 1.27,
            'PRT': 1.41,
            'BEL': 1.29,
            'NLD': 1.57,
            'CHE': 1.79,
            'DNK': 1.61,
            'SWE': 1.29,
            'NOR': 1.46,
            'FIN': 1.43,
            'EST': 1.22,
            'LVA': 1.31,
            'LTU': 1.36,
            'ROU': 1.28,
            'BGR': 1.12,
            'GRC': 1.58,
            'HRV': 1.15,
            'SVN': 1.31,
            'SRB': 1.41,
            'MKD': 1.42,
            'BIH': 1.29,
            'MNE': 1.45,
            'ALB': 1.42,
            'adblue': 0.65,  // domyślna cena AdBlue dla wszystkich krajów
        };

        const companyCosts = {
            fixedCostsPerHour: 50,
            variableCostsPerKm: 0.5,
            useLowestFuelPrice: true,
            useCustomFuelPrices: true,
            globalFuelPrice: 1.35,
            globalAdBluePrice: 0.65,
            customFuelPrices: {
                'POL': 1.32,
                'DEU': 1.46,
                'CZE': 1.42,
                'ESP': 1.35,
                'AUT': 1.4,
            }
        };

        const excludableCountries = [
            // Kraje zachodniej Europy
            { code3: "CHE", code2: "CH" },
            { code3: "AUT", code2: "AT" },
            { code3: "DEU", code2: "DE" },
            { code3: "FRA", code2: "FR" },
            { code3: "ITA", code2: "IT" },
            { code3: "NLD", code2: "NL" },
            { code3: "BEL", code2: "BE" },
            { code3: "LUX", code2: "LU" },
            { code3: "GBR", code2: "GB" },
            { code3: "IRL", code2: "IE" },
            { code3: "DNK", code2: "DK" },
            { code3: "NOR", code2: "NO" },
            { code3: "SWE", code2: "SE" },
            { code3: "FIN", code2: "FI" },
            
            // Kraje Europy Środkowej
            { code3: "POL", code2: "PL" },
            { code3: "CZE", code2: "CZ" },
            { code3: "SVK", code2: "SK" },
            { code3: "SVN", code2: "SI" },
            { code3: "HRV", code2: "HR" },
            { code3: "HUN", code2: "HU" },
            
            // Kraje Europy Wschodniej
            { code3: "RUS", code2: "RU" },
            { code3: "UKR", code2: "UA" },
            { code3: "BLR", code2: "BY" },
            { code3: "MDA", code2: "MD" },
            { code3: "EST", code2: "EE" },
            { code3: "LVA", code2: "LV" },
            { code3: "LTU", code2: "LT" },
            
            // Kraje Europy Południowej
            { code3: "ESP", code2: "ES" },
            { code3: "PRT", code2: "PT" },
            { code3: "GRC", code2: "GR" },
            { code3: "CYP", code2: "CY" },
            { code3: "MLT", code2: "MT" },
            
            // Kraje Bałkanów
            { code3: "BGR", code2: "BG" },
            { code3: "ROU", code2: "RO" },
            { code3: "SRB", code2: "RS" },
            { code3: "MNE", code2: "ME" },
            { code3: "MKD", code2: "MK" },
            { code3: "ALB", code2: "AL" },
            { code3: "BIH", code2: "BA" },
            
            // Państwa na Kaukazie (część europejska)
            { code3: "GEO", code2: "GE" },
            { code3: "ARM", code2: "AM" },
            { code3: "AZE", code2: "AZ" }
        ];

        // Define areas list for exclusion
        const excludableAreas = [
            { 
                name: "Füssen", 
                bbox: {
                    west: 10.503569952001044,
                    south: 47.40623942387259,
                    east: 10.88272284357322,
                    north: 47.648267570933086
                }
            },
            { 
                name: "Brenner Pass", 
                bbox: {
                    west: 11.3018,
                    south: 46.9361,
                    east: 11.5425,
                    north: 47.0687
                }
            },
            { 
                name: "Mont Blanc Tunnel", 
                bbox: {
                    west: 6.82412,
                    south: 45.8169,
                    east: 6.9336,
                    north: 45.8742
                }
            },
            { 
                name: "Frejus Tunnel", 
                bbox: {
                    west: 6.672028,
                    south: 45.12587,
                    east: 6.713914,
                    north: 45.8742
                }
            },
        ];

        // Główna funkcja inicjalizująca zintegrowany dropdown
        function initializeExcludedList() {
            const selectedElement = document.getElementById('excluded-items-selected');
            const menuElement = document.getElementById('excluded-items-menu');
            const searchInput = document.getElementById('items-search');
            
            // Wypełnij sekcje krajów i obszarów
            populateCountriesSection();
            populateAreasSection();
            updateSelectedItemsSection();
            updateDropdownText(); // DODAJ TĘ LINIĘ
            
            // Toggle dropdown on click
            selectedElement.addEventListener('click', () => {
                const isActive = selectedElement.classList.contains('active');
                
                // Close all dropdowns first
                document.querySelectorAll('.dropdown-selected').forEach(el => {
                    el.classList.remove('active');
                });
                document.querySelectorAll('.dropdown-menu').forEach(el => {
                    el.style.display = 'none';
                });
                
                // Toggle this dropdown
                if (!isActive) {
                    selectedElement.classList.add('active');
                    menuElement.style.display = 'block';
                    searchInput.focus();
                    searchInput.value = '';
                    
                    // Refresh items when opening
                    populateCountriesSection();
                    populateAreasSection();
                    updateSelectedItemsSection();
                    // Przewiń na samą górę, aby od razu pokazać sekcję wybranych elementów
                    setTimeout(() => {
                        menuElement.scrollTop = 0;
                    }, 10);
                }
            });
            // Po inicjalizacji dropdown:
            // Ustawienie tekstów tłumaczeń
            document.querySelector('.selected-title').textContent = translations.selected;
            document.querySelectorAll('.dropdown-section-title')[1].textContent = translations.countries;
            document.querySelectorAll('.dropdown-section-title')[2].textContent = translations.areas;
            document.getElementById('items-search').placeholder = translations.search;
            
            // Handle search
            searchInput.addEventListener('input', () => {
                const searchTerm = searchInput.value.toLowerCase();
                filterItems(searchTerm);
            });
            
            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!selectedElement.contains(e.target) && !menuElement.contains(e.target)) {
                    selectedElement.classList.remove('active');
                    menuElement.style.display = 'none';
                }
            });
        }

        // Funkcja wypełniająca sekcję krajów
        function populateCountriesSection(searchTerm = '') {
            const container = document.getElementById('countries-items-container');
            container.innerHTML = '';
            
            excludableCountries.forEach(country => {
                if (searchTerm && !country.code2.toLowerCase().includes(searchTerm.toLowerCase())) {
                    return;
                }
                
                const isSelected = isCountrySelected(country.code3);
                const item = createCountryItem(country, isSelected);
                container.appendChild(item);
            });
        }

        // Funkcja wypełniająca sekcję obszarów
        function populateAreasSection(searchTerm = '') {
            const container = document.getElementById('areas-items-container');
            container.innerHTML = '';
            
            excludableAreas.forEach(area => {
                if (searchTerm && !area.name.toLowerCase().includes(searchTerm.toLowerCase())) {
                    return;
                }
                
                const isSelected = isAreaSelected(area.name);
                const item = createAreaItem(area, isSelected);
                container.appendChild(item);
            });
        }

        // Funkcja aktualizująca sekcję wybranych elementów
        function updateSelectedItemsSection() {
            const selectedCountries = getSelectedCountries();
            const selectedAreas = getSelectedAreas();
            const sectionContainer = document.getElementById('selected-items-section');
            const container = document.getElementById('selected-items-container');
            // Dodajemy definicję spanElement
            const spanElement = document.getElementById('excluded-items-selected').querySelector('span');
            
            // Pokaż lub ukryj sekcję w zależności od tego, czy coś jest wybrane
            if (selectedCountries.length === 0 && selectedAreas.length === 0) {
                sectionContainer.style.display = 'none';
                spanElement.innerHTML = '';
                spanElement.textContent = translations.excludeCountriesAndAreasPlaceholder;
                return;
            }
            
            sectionContainer.style.display = 'block';
            container.innerHTML = '';
            
            // Dodaj wybrane kraje
            selectedCountries.forEach(countryCode => {
                const country = excludableCountries.find(c => c.code3 === countryCode);
                if (country) {
                    const item = createCountryItem(country, true);
                    container.appendChild(item);
                }
            });
            
            // Dodaj wybrane obszary
            selectedAreas.forEach(areaName => {
                const area = excludableAreas.find(a => a.name === areaName);
                if (area) {
                    const item = createAreaItem(area, true);
                    container.appendChild(item);
                }
            });
        }

        // Funkcja tworząca element kraju
        function createCountryItem(country, isSelected) {
            const item = document.createElement('div');
            item.className = `dropdown-item ${isSelected ? 'selected' : ''}`;
            item.dataset.type = 'country';
            item.dataset.id = country.code3;
            
            item.innerHTML = `<span class="item-name">${country.code2}</span>`;
            
            item.addEventListener('click', () => {
                toggleCountrySelection(country);
            });
            
            return item;
        }

        // Funkcja tworząca element obszaru
        function createAreaItem(area, isSelected) {
            const item = document.createElement('div');
            item.className = `dropdown-item ${isSelected ? 'selected' : ''}`;
            item.dataset.type = 'area';
            item.dataset.id = area.name;
            
            item.innerHTML = `<span class="item-name">${area.name}</span>`;
            
            item.addEventListener('click', () => {
                toggleAreaSelection(area);
            });
            
            return item;
        }

        // Funkcja przełączająca zaznaczenie kraju
        function toggleCountrySelection(country) {
            const selectedCountries = getSelectedCountries();
            const countryId = country.code3;
            const isSelected = selectedCountries.includes(countryId);
            
            if (isSelected) {
                // Usuń kraj z zaznaczonych
                const newSelection = selectedCountries.filter(id => id !== countryId);
                saveSelectedCountries(newSelection);
            } else {
                // Dodaj kraj do zaznaczonych
                selectedCountries.push(countryId);
                saveSelectedCountries(selectedCountries);
            }
            
            // Odśwież widok
            populateCountriesSection();
            updateSelectedItemsSection();
            updateDropdownText();
            
            // Przelicz trasę
            calculateRouteIfPossible();
        }

        // Funkcja przełączająca zaznaczenie obszaru
        function toggleAreaSelection(area) {
            const selectedAreas = getSelectedAreas();
            const areaName = area.name;
            const isSelected = selectedAreas.includes(areaName);
            
            if (isSelected) {
                // Usuń obszar z zaznaczonych
                const newSelection = selectedAreas.filter(name => name !== areaName);
                saveSelectedAreas(newSelection);
            } else {
                // Dodaj obszar do zaznaczonych
                selectedAreas.push(areaName);
                saveSelectedAreas(selectedAreas);
            }
            
            // Odśwież widok
            populateAreasSection();
            updateSelectedItemsSection();
            updateDropdownText();
            
            // Przelicz trasę
            calculateRouteIfPossible();
        }

        // Funkcja filtrująca wszystkie listy
        function filterItems(searchTerm) {
            populateCountriesSection(searchTerm);
            populateAreasSection(searchTerm);
        }

        // Funkcja aktualizująca tekst w dropdown
        function updateDropdownText() {
            const selectedElement = document.getElementById('excluded-items-selected');
            const spanElement = selectedElement.querySelector('span');
            
            const selectedCountries = getSelectedCountries();
            const selectedAreas = getSelectedAreas();
            
            if (selectedCountries.length === 0 && selectedAreas.length === 0) {
                spanElement.innerHTML = '';
                spanElement.textContent = translations.excludeCountriesAndAreasPlaceholder;
                return;
            }
            
            // Tworzymy tekst podsumowujący selekcję
            const countryCount = selectedCountries.length;
            const areaCount = selectedAreas.length;
            
            spanElement.innerHTML = '';
            
            const selectedItems = document.createElement('div');
            selectedItems.className = 'selected-items';
            
            // Dodaj wybrane kraje
            const maxItems = 5; // Maksymalna liczba elementów do wyświetlenia
            let displayedCount = 0;
            
            // Dodaj kraje
            for (let i = 0; i < selectedCountries.length && displayedCount < maxItems; i++) {
                const countryCode = selectedCountries[i];
                const country = excludableCountries.find(c => c.code3 === countryCode);
                if (country) {
                    const item = document.createElement('div');
                    item.className = 'selected-item';
                    item.textContent = country.code2;
                    
                    // Dodaj przycisk usuwania
                    const removeBtn = document.createElement('span');
                    removeBtn.className = 'selected-item-remove';
                    removeBtn.textContent = '×';
                    removeBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleCountrySelection(country);
                    });
                    
                    item.appendChild(removeBtn);
                    selectedItems.appendChild(item);
                    displayedCount++;
                }
            }
            
            // Dodaj obszary
            for (let i = 0; i < selectedAreas.length && displayedCount < maxItems; i++) {
                const areaName = selectedAreas[i];
                const area = excludableAreas.find(a => a.name === areaName);
                if (area) {
                    const item = document.createElement('div');
                    item.className = 'selected-item';
                    item.textContent = area.name;
                    
                    // Dodaj przycisk usuwania
                    const removeBtn = document.createElement('span');
                    removeBtn.className = 'selected-item-remove';
                    removeBtn.textContent = '×';
                    removeBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleAreaSelection(area);
                    });
                    
                    item.appendChild(removeBtn);
                    selectedItems.appendChild(item);
                    displayedCount++;
                }
            }
            
            // Dodaj wskaźnik "więcej" jeśli potrzebny
            const totalItems = selectedCountries.length + selectedAreas.length;
            if (totalItems > maxItems) {
                const moreIndicator = document.createElement('div');
                moreIndicator.className = 'more-indicator';
                moreIndicator.textContent = `+${totalItems - maxItems} ${translations.more}`;
                selectedItems.appendChild(moreIndicator);
            }
            
            spanElement.appendChild(selectedItems);
        }

        // Funkcje pomocnicze do pobierania zaznaczonych elementów
        function getSelectedCountries() {
            const savedItems = localStorage.getItem('excludedCountries');
            return savedItems ? JSON.parse(savedItems) : [];
        }

        function getSelectedAreas() {
            const savedItems = localStorage.getItem('excludedAreas');
            return savedItems ? JSON.parse(savedItems) : [];
        }

        // Funkcje pomocnicze do zapisywania zaznaczonych elementów
        function saveSelectedCountries(countries) {
            localStorage.setItem('excludedCountries', JSON.stringify(countries));
        }

        function saveSelectedAreas(areas) {
            localStorage.setItem('excludedAreas', JSON.stringify(areas));
        }

        // Funkcje pomocnicze do sprawdzania, czy elementy są zaznaczone
        function isCountrySelected(countryCode) {
            return getSelectedCountries().includes(countryCode);
        }

        function isAreaSelected(areaName) {
            return getSelectedAreas().includes(areaName);
        }



        function getExcludedAreasForRoute() {
            const result = {
                excludedCountries: [],
                excludedAreas: []
            };
            
            // Dodaj wykluczone kraje
            result.excludedCountries = getSelectedCountries();
            
            // Dodaj wykluczone obszary
            const selectedAreaNames = getSelectedAreas();
            selectedAreaNames.forEach(areaName => {
                const area = excludableAreas.find(a => a.name === areaName);
                if (area) {
                    result.excludedAreas.push({
                        type: 'bbox',
                        ...area.bbox
                    });
                }
            });
            
            return result;
        }

        const currentLang = getPreferredLanguage();
        const translations = getUITranslations(currentLang);
        const API_KEY = 'yuwY_LTItp881XAaYOHShjcBhdc0sHWuj4TQwGKwjms';
        
        const MANUAL_TOLL_SYSTEMS = {
            'TRAFORO DEL MONTE BIANCO': {
                checkLocation: null,
                displayName: 'Mont Bianc IT→FR'
            },
            'ATMB': {
                checkLocation: 'TUNNEL DU MONT-BLANC',
                displayName: 'Mont Bianc FR→IT'
            },
            'SITAF S.P.A.': {
                checkLocation: 'Bardonecchia',
                displayName: 'Frejus IT→FR'
            },
            'SFTRF': {
                checkLocation: 'TUNNEL DU FREJUS',
                displayName: 'Frejus FR→IT'
            }
        };

        ///LICZNIK ZAPYTAŃ
        const apiMonitor = new class APIMonitor {
            constructor() {
                this.endpoint = 'https://script.google.com/macros/s/AKfycbxBxX2x9tXlLxrXh6KrSVDdaEQZGfmtnncRMvZhd4yTL_bUwPcqFtHHSMUwIHlbDq-1/exec';
                this.testerId = this.getOrCreateTesterId();
            }

            getOrCreateTesterId() {
                let id = localStorage.getItem('testerId');
                if (!id) {
                    id = 'tester_' + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem('testerId', id);
                }
                return id;
            }

            logRequest(type) {
                fetch(this.endpoint, {
                    method: 'POST',
                    mode: 'no-cors',
                    body: JSON.stringify({
                        type: type,
                        testerId: this.testerId
                    })
                });
            }
        }();

        ///KONIEC LICZNIKA ZAPYTAŃ



        function isGPSCoordinates(text) {
            const cleanText = text.trim();
            
            const patterns = {
                decimal: /^(-?\d+\.?\d*),\s*(-?\d+\.?\d*)$/,
                dms: /^(-?\d+)°(\d+)'(\d+(\.\d+)?)"([NS])\s*(-?\d+)°(\d+)'(\d+(\.\d+)?)"([EW])$/
            };
            
            const decimalMatch = cleanText.match(patterns.decimal);
            if (decimalMatch) {
                const lat = parseFloat(decimalMatch[1]);
                const lng = parseFloat(decimalMatch[2]);
                return isValidLatLng(lat, lng) ? { lat, lng } : null;
            }
            
            const dmsMatch = cleanText.match(patterns.dms);
            if (dmsMatch) {
                const lat = convertDMSToDecimal(
                    parseFloat(dmsMatch[1]),
                    parseFloat(dmsMatch[2]),
                    parseFloat(dmsMatch[3]),
                    dmsMatch[5]
                );
                const lng = convertDMSToDecimal(
                    parseFloat(dmsMatch[6]),
                    parseFloat(dmsMatch[7]),
                    parseFloat(dmsMatch[8]),
                    dmsMatch[10]
                );
                return isValidLatLng(lat, lng) ? { lat, lng } : null;
            }
            
            return null;
        }

        function isValidLatLng(lat, lng) {
            return lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
        }

        function convertDMSToDecimal(degrees, minutes, seconds, direction) {
            let decimal = degrees + (minutes / 60) + (seconds / 3600);
            if (direction === 'S' || direction === 'W') {
                decimal = -decimal;
            }
            return decimal;
        }

        const platform = new H.service.Platform({
            apikey: API_KEY
        });

        const customTileProvider = new H.map.provider.ImageTileProvider({
            getURL: (x, y, z) => {
                // Determine PPI based on screen resolution
                const screenWidth = window.screen.width * window.devicePixelRatio;
                const ppi = screenWidth >= 2560 ? 200 : 200;
                
                // Select map style based on zoom level
                const mapStyle = z > 9 ? 'logistics.day' : 'explore.day';
                
                // Base URL with dynamic PPI
                let url = `https://maps.hereapi.com/v3/base/mc/${z}/${x}/${y}/png8?xnlp=CL_JSMv3.1.61.1` +
                        `&apikey=${API_KEY}` +
                        `&style=${mapStyle}` +
                        `&size=512` +
                        `&lang=${currentLang}` +
                        `&ppi=${ppi}`;
                
                // Add features for logistics.day style
                if (mapStyle === 'logistics.day') {
                    url += '&features=vehicle_restrictions:active_and_inactive,pois:disabled,congestion_zones:all';
                }
                
                return url;
            }
        });

        const customTileLayer = new H.map.layer.TileLayer(customTileProvider);
        const map = new H.Map(
            document.getElementById('map-container'),
            customTileLayer,
            {
                tileSize: 512,
                pixelRatio: window.devicePixelRatio|| 1,
                zoom: 5.5,
                center: { lat: 50.0, lng: 15.0 },
                renderBaseBackground: true, // Dodajemy tło podczas ładowania
            }
        );

        window.addEventListener('resize', () => {
            map.getViewPort().resize();
        });

        const ui = new H.ui.UI(map, {
            zoom: new H.ui.ZoomControl()
        });

        // Pobierz kontrolkę zoom i ustaw jej wyrównanie
        const zoomControl = ui.getControl('zoom');
        if (zoomControl) {
            zoomControl.setAlignment('bottom-right');
        }
        const mapEvents = new H.mapevents.MapEvents(map);
        const behavior = new H.mapevents.Behavior(mapEvents);
        

        // FUNCJE DO MENU KONTEKSTOWEGO (START/VIA/KONIEC)    
        // Functions for handling waypoints from context menu
        function addStartPoint(coordinates) {
            const waypointsContainer = document.getElementById('waypoints-container');
            const waypointContainers = waypointsContainer.querySelectorAll('.waypoint-container');
            
            // Create new waypoint
            const newWaypoint = createWaypointInput();
            const input = newWaypoint.querySelector('.waypoint');
            input.value = `${coordinates.lat.toFixed(6)}, ${coordinates.lng.toFixed(6)}`;

            // Always insert as first point
            if (waypointContainers.length > 0) {
                waypointsContainer.insertBefore(newWaypoint, waypointContainers[0]);
            } else {
                waypointsContainer.appendChild(newWaypoint);
            }

            input.dispatchEvent(new Event('input'));
            updateWaypointNumbers();
        }

        function addViaPoint(coordinates) {
            const waypointsContainer = document.getElementById('waypoints-container');
            const waypointContainers = waypointsContainer.querySelectorAll('.waypoint-container');
            
            if (waypointContainers.length === 0) {
                alert(translations.addStartFirst);
                return;
            }

            // Create new waypoint
            const newWaypoint = createWaypointInput();
            const input = newWaypoint.querySelector('.waypoint');
            input.value = `${coordinates.lat.toFixed(6)}, ${coordinates.lng.toFixed(6)}`;

            // Znajdź wszystkie niepuste punkty
            const nonEmptyContainers = Array.from(waypointContainers).filter(container => 
                container.querySelector('.waypoint').value.trim() !== ''
            );

            if (nonEmptyContainers.length === 1) {
                // Jeśli mamy tylko punkt startowy, dodaj po nim
                const secondContainer = waypointContainers[1];
                waypointsContainer.insertBefore(newWaypoint, secondContainer || null);
            } else if (nonEmptyContainers.length >= 2) {
                // Dodaj przed ostatnim niepustym punktem
                const lastContainer = nonEmptyContainers[nonEmptyContainers.length - 1];
                waypointsContainer.insertBefore(newWaypoint, lastContainer);
            } else {
                waypointsContainer.appendChild(newWaypoint);
            }

            input.dispatchEvent(new Event('input'));
            updateWaypointNumbers();
        }

        function addEndPoint(coordinates) {
            const waypointsContainer = document.getElementById('waypoints-container');
            const waypointContainers = waypointsContainer.querySelectorAll('.waypoint-container');
            
            if (waypointContainers.length === 0) {
                alert(translations.addStartFirst);
                return;
            }

            // Create new waypoint
            const newWaypoint = createWaypointInput();
            const input = newWaypoint.querySelector('.waypoint');
            input.value = `${coordinates.lat.toFixed(6)}, ${coordinates.lng.toFixed(6)}`;

            // In case of only one existing point (start point), add end point directly after it
            if (waypointContainers.length === 1) {
                waypointsContainer.appendChild(newWaypoint);
            } else {
                // For more points, add before the last empty container
                const lastContainer = waypointContainers[waypointContainers.length - 1];
                const lastInput = lastContainer.querySelector('.waypoint');
                
                if (lastInput && lastInput.value.trim() === '') {
                    waypointsContainer.insertBefore(newWaypoint, lastContainer);
                } else {
                    waypointsContainer.appendChild(newWaypoint);
                }
            }

            input.dispatchEvent(new Event('input'));
            updateWaypointNumbers();
        }


        // LISTENER NA PRAWY PRZYCISK MYSZY!
        // Add map right click handler
        map.addEventListener('pointerdown', (evt) => {
        // Check if it's right mouse button
        if (evt.currentPointer.button === 2) {
            // Prevent default browser's context menu
            evt.originalEvent.preventDefault();
            
            // Remove any existing menu before creating new one
            document.querySelectorAll('.context-menu').forEach(menu => menu.remove());
            
            const coordinates = map.screenToGeo(
                evt.currentPointer.viewportX,
                evt.currentPointer.viewportY
            );
            
            // Create a temporary div for our custom context menu
            const menuDiv = document.createElement('div');
            menuDiv.className = 'context-menu';
            menuDiv.style.position = 'fixed'; // Zmiana z 'absolute' na 'fixed'
            
            // Pobieramy pozycję kliknięcia względem strony
            const x = evt.originalEvent.pageX;
            const y = evt.originalEvent.pageY;
            
            menuDiv.style.left = x + 'px';
            menuDiv.style.top = y + 'px';
            menuDiv.style.backgroundColor = 'white';
            menuDiv.style.border = '1px solid #ddd';
            menuDiv.style.borderRadius = '4px';
            menuDiv.style.padding = '5px';
            menuDiv.style.zIndex = '1000';
            menuDiv.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';

            // Create menu items
            const menuItems = [
                { text: translations.addStartPoint, action: () => addStartPoint(coordinates) },
                { text: translations.addViaPoint, action: () => addViaPoint(coordinates) },
                { text: translations.addEndPoint, action: () => addEndPoint(coordinates) },
                { text: `${translations.coordinates}: ${coordinates.lat.toFixed(6)}, ${coordinates.lng.toFixed(6)}`, action: null }
            ];
            menuItems.forEach(item => {
                const menuItem = document.createElement('div');
                
                if (item.text.startsWith(translations.coordinates)) {
                    // Specjalna obsługa dla elementu z koordynatami
                    const coordsText = `${coordinates.lat.toFixed(6)}, ${coordinates.lng.toFixed(6)}`;
                    
                    menuItem.innerHTML = `
                        <div style="margin-bottom: 2px">
                            ${translations.coordinates}: 
                            <span class="coords-value" style="cursor: pointer; color: #0066CC;">${coordsText}</span>
                        </div>
                        <div class="copy-feedback" style="display: none; color: #28a745; font-size: 11px;">
                            ✓ Skopiowano
                        </div>
                    `;
                    
                    const wholeItem = menuItem;
                    const coordsSpan = menuItem.querySelector('.coords-value');
                    const feedbackSpan = menuItem.querySelector('.copy-feedback');
                    
                    // Dodaj obsługę kliknięcia na cały element
                    wholeItem.style.cursor = 'pointer';
                    wholeItem.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        
                        try {
                            await navigator.clipboard.writeText(coordsText); // Kopiujemy tylko same koordynaty
                            
                            feedbackSpan.style.display = 'block';
                            
                            setTimeout(() => {
                                feedbackSpan.style.display = 'none';
                            }, 2000);
                        } catch (err) {
                            console.error('Failed to copy coordinates:', err);
                            
                            const textArea = document.createElement('textarea');
                            textArea.value = coordsText;
                            document.body.appendChild(textArea);
                            textArea.select();
                            try {
                                document.execCommand('copy');
                                feedbackSpan.style.display = 'block';
                                setTimeout(() => {
                                    feedbackSpan.style.display = 'none';
                                }, 2000);
                            } catch (err) {
                                console.error('Fallback copy failed:', err);
                            }
                            document.body.removeChild(textArea);
                        }
                    });
                    
                    menuItem.style.padding = '8px 12px';
                    menuItem.style.color = '#666';
                    menuItem.style.fontSize = '12px';
                    
                } else {
                    // Standardowa obsługa dla pozostałych elementów menu
                    menuItem.textContent = item.text;
                    menuItem.style.padding = '8px 12px';
                    menuItem.style.cursor = item.action ? 'pointer' : 'default';
                    menuItem.style.borderBottom = '1px solid #eee';
                    
                    if (item.action) {
                        menuItem.addEventListener('mouseover', () => {
                            menuItem.style.backgroundColor = '#f0f0f0';
                        });
                        menuItem.addEventListener('mouseout', () => {
                            menuItem.style.backgroundColor = 'white';
                        });
                        menuItem.addEventListener('click', () => {
                            item.action();
                            menuDiv.remove();
                        });
                    }
                }
                
                menuDiv.appendChild(menuItem);
            });

            document.getElementById('map-container').appendChild(menuDiv);
            
            // Sprawdzamy, czy menu nie wychodzi poza ekran
            setTimeout(() => {
                const rect = menuDiv.getBoundingClientRect();
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                
                if (rect.right > windowWidth) {
                    menuDiv.style.left = (windowWidth - rect.width) + 'px';
                }
                
                if (rect.bottom > windowHeight) {
                    menuDiv.style.top = (windowHeight - rect.height) + 'px';
                }
            }, 0);
            
            // Remove menu when clicking anywhere else
            const removeMenu = () => {
                menuDiv.remove();
                document.removeEventListener('click', removeMenu);
            };
            
            document.addEventListener('click', removeMenu);
        }
    });

        // Disable the default draggability of the underlying map
        // and enable it only when no marker is being dragged
        let isDragging = false;

        map.addEventListener('dragstart', function(ev) {
            const target = ev.target;
            if (target instanceof H.map.Marker) {
                isDragging = true;
                // Disable the default draggability of the underlying map
                // when starting to drag a marker
                behavior.disable();
            }
        });

        map.addEventListener('drag', function(ev) {
            const target = ev.target;
            if (target instanceof H.map.Marker && isDragging) {
                const pointer = ev.currentPointer;
                target.setGeometry(map.screenToGeo(pointer.viewportX, pointer.viewportY));
            }
        });

        map.addEventListener('dragend', function(ev) {
            const target = ev.target;
            if (target instanceof H.map.Marker && isDragging) {
                isDragging = false;
                behavior.enable();
                
                const newPosition = target.getGeometry();
                const markerId = target.getData().id;
                
                const waypoints = document.querySelectorAll('.waypoint');
                const waypointInput = waypoints[markerId - 1];
                
                if (waypointInput) {
                    fetch(
                        `https://revgeocode.search.hereapi.com/v1/revgeocode` +
                        `?at=${newPosition.lat},${newPosition.lng}` +
                        `&limit=1` +
                        `&lang=${currentLang}` +
                        `&apiKey=${API_KEY}`
                    )
                    .then(response => response.json())
                    .then(data => {
                        if (data.items && data.items.length > 0) {
                            const address = data.items[0].title;
                            waypointInput.value = address;
                            geocodedPoints.set(address, {
                                lat: newPosition.lat,
                                lng: newPosition.lng,
                                address: address
                            });
                            calculateRouteIfPossible();
                        }
                    })
                    .catch(error => {
                        console.error('Reverse geocoding error:', error);
                    });
                }
            }
        });

        // Prevent the default draggability of the underlying map
        // when starting to drag a marker
        map.addEventListener('pointerdown', function(ev) {
            if (ev.target instanceof H.map.Marker) {
                behavior.disable();
            }
        }, false);

        // Re-enable the default draggability of the underlying map
        // after dragging is finished
        map.addEventListener('pointerup', function(ev) {
            if (ev.target instanceof H.map.Marker) {
                behavior.enable();
            }
        }, false);

        let currentRouteIndex = 0; // indeks aktualnie wybranej trasy
        let routeLines = [];
        let markers = [];
        let debounceTimer;
        let isOverHandle = false;
        let hideHandleTimeout;
		
        async function geocodeAddress(address) {
            if (geocodedPoints.has(address.trim())) {
                return geocodedPoints.get(address.trim());
            }

            apiMonitor.logRequest('geocoding');
            const gpsCoords = isGPSCoordinates(address);
            
            if (gpsCoords) {
                // Tylko dla ręcznie wpisanych współrzędnych GPS
                try {
                    const response = await fetch(
                        `https://revgeocode.search.hereapi.com/v1/revgeocode` +
                        `?at=${gpsCoords.lat},${gpsCoords.lng}` +
                        `&limit=1` +
                        `&lang=${currentLang}` +
                        `&apiKey=${API_KEY}`
                    );
                    
                    if (!response.ok) {
                        throw new Error(translations.geocodingError);
                    }
                    
                    const data = await response.json();
                    
                    if (data.items && data.items.length > 0) {
                        return {
                            lat: gpsCoords.lat,
                            lng: gpsCoords.lng,
                            address: data.items[0].title
                        };
                    }
                } catch (error) {
                    console.error('Reverse geocoding error:', error);
                    return { lat: gpsCoords.lat, lng: gpsCoords.lng };
                }
            } else {
                return new Promise((resolve, reject) => {
                    const service = platform.getSearchService();
                    service.geocode({
                        q: address,
                        limit: 1
                    }, (result) => {
                        if (result.items && result.items.length > 0) {
                            const addressInfo = result.items[0].address;
                            
                            // Tworzymy część adresu z ulicą i numerem
                            let streetPart = '';
                            if (addressInfo.street) {
                                streetPart = addressInfo.street;
                                if (addressInfo.houseNumber) {
                                    streetPart += ' ' + addressInfo.houseNumber;
                                }
                            }
                            
                            const formattedAddress = [
                                addressInfo.postalCode,
                                addressInfo.city,
                                addressInfo.countryCode,
                                streetPart
                            ].filter(Boolean).join(', ');

                            resolve({
                                lat: result.items[0].position.lat,
                                lng: result.items[0].position.lng,
                                address: formattedAddress
                            });
                        } else {
                            reject(new Error(translations.addressNotFound));
                        }
                    }, (error) => {
                        console.error('Geocoding error:', error);
                        reject(new Error(translations.geocodingError));
                    });
                });
            }
        }

        function updateWaypointNumbers() {
            const containers = document.querySelectorAll('.waypoint-container');
            containers.forEach((container, index) => {
                const numberDiv = container.querySelector('.waypoint-number');
                if (numberDiv) {
                    numberDiv.textContent = (index + 1).toString();
                }
            });
        }

        function addMarker(position, number) {
            const svgMarkup = '<svg width="48" height="48" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">' +
                '<circle cx="12" cy="21" r="2.5" fill="white" stroke="black" stroke-width="1"/>' + // dodana biała kropka na dole
                '<path fill="#0F52BA" d="M12 2.5c-3.8 0-7 3.2-7 7.1 0 5.4 7 11.9 7 11.9s7-6.5 7-11.9c0-3.9-3.2-7.1-7-7.1z" />' +
                '<circle cx="12" cy="9" r="4" fill="#FFFFFF"/>' +
                '<text x="12" y="11" font-size="6" font-family="Arial" font-weight="bold" text-anchor="middle" fill="#0066CC">' + 
                number + '</text>' +
                '</svg>';

            const icon = new H.map.Icon(svgMarkup, {
                anchor: { x: 24, y: 48 }
            });
            
            const marker = new H.map.Marker(position, {
                icon: icon,
                volatility: true,
                draggable: true,
                data: { id: number }
            });

            marker.draggable = true;
            
            markers.push(marker);
            map.addObject(marker);
            return marker;
        }


        let routeBubbles = [];
        function clearMap() {
            try {
                // Clear existing InfoBubbles
                routeBubbles.forEach(bubble => {
                    if (bubble && bubble.close) {
                        bubble.close();
                    }
                });
                routeBubbles = [];
                
                // Clear routes and markers
                routeLines.forEach(line => {
                    if (line && typeof line.dispose === 'function') {
                        line.dispose();
                    }
                    if (line && map.getObjects().includes(line)) {
                        map.removeObject(line);
                    }
                });
                routeLines = [];
                
                markers.forEach(marker => {
                    if (marker && typeof marker.dispose === 'function') {
                        marker.dispose();
                    }
                    if (marker && map.getObjects().includes(marker)) {
                        map.removeObject(marker);
                    }
                });
                markers = [];
                
                // Reset route info to default values
                document.querySelectorAll('#route-info .stat-value').forEach(element => {
                    element.textContent = '--';
                });

                // Ukryj wskaźniki odległości
                document.querySelectorAll('.distance-indicator').forEach(indicator => {
                    indicator.classList.remove('visible');
                    indicator.textContent = '↓ -- km';
                });
                
            } catch (error) {
                console.error('Error clearing map:', error);
            }
        }

        // Drag & Drop handlers
        // Zmienne globalne dla obsługi przeciągania
        let draggedElement = null;
        let initialY = 0;
        let currentY = 0;
        let offsetY = 0;

        // Główne funkcje obsługi przeciągania
        function handleDragStart(e) {
            if (!e.target.classList.contains('waypoint-number')) {
                return;
            }
            e.preventDefault();
            
            draggedElement = this.parentElement;
            const rect = draggedElement.getBoundingClientRect();
            initialY = e.clientY;
            offsetY = e.clientY - rect.top;
            
            draggedElement.style.setProperty('--y', '0px');
            draggedElement.classList.add('dragging');
            draggedElement.style.width = `${rect.width}px`;
            draggedElement.style.left = `${rect.left}px`;
            draggedElement.originalIndex = Array.from(draggedElement.parentNode.children).indexOf(draggedElement);
            
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', handleDragEnd);
        }

        function handleDrag(e) {
            if (!draggedElement) return;
            e.preventDefault();
            
            currentY = e.clientY;
            const deltaY = currentY - initialY;
            draggedElement.style.setProperty('--y', `${deltaY}px`);
            
            const containers = Array.from(document.querySelectorAll('.waypoint-container:not(.dragging)'));
            const draggedRect = draggedElement.getBoundingClientRect();
            const draggedCenter = draggedRect.top + draggedRect.height / 2;
            
            // Reset all shifts first
            containers.forEach(container => {
                container.classList.remove('shift-down');
            });
            
            // Find the first container we're above
            const targetIndex = containers.findIndex(container => {
                const rect = container.getBoundingClientRect();
                return draggedCenter < (rect.top + rect.height / 2);
            });
            
            if (targetIndex !== -1) {
                // Shift all containers from this index down
                containers.slice(targetIndex).forEach(container => {
                    container.classList.add('shift-down');
                });
            }
        }
        function handleDragEnd(e) {
            if (!draggedElement) return;
            
            document.removeEventListener('mousemove', handleDrag);
            document.removeEventListener('mouseup', handleDragEnd);
            
            const containers = document.querySelectorAll('.waypoint-container');
            containers.forEach(container => {
                container.classList.remove('shift-up', 'shift-down');
            });
            
            const draggedRect = draggedElement.getBoundingClientRect();
            const targetContainer = Array.from(containers).find(container => {
                if (container === draggedElement) return false;
                const rect = container.getBoundingClientRect();
                return draggedRect.top + draggedRect.height / 2 < rect.top + rect.height / 2;
            });
            
            if (targetContainer) {
                targetContainer.parentNode.insertBefore(draggedElement, targetContainer);
            } else {
                const lastContainer = containers[containers.length - 1];
                lastContainer.parentNode.insertBefore(draggedElement, lastContainer.nextSibling);
            }
            
            draggedElement.classList.remove('dragging');
            draggedElement.style.removeProperty('--y');
            draggedElement.style.removeProperty('width');
            draggedElement.style.removeProperty('left');
            
            // Sprawdź czy ostatnie pole jest puste
            const allWaypoints = document.querySelectorAll('.waypoint');
            const lastWaypoint = allWaypoints[allWaypoints.length - 1];
            
            if (lastWaypoint && lastWaypoint.value.trim() !== '' && allWaypoints.length < 15) {
                const waypointsContainer = document.getElementById('waypoints-container');
                waypointsContainer.appendChild(createWaypointInput());
            }
            
            updateWaypointNumbers();
            updateRemoveButtons();
            calculateRouteIfPossible();
            
            draggedElement = null;
        }

        // Zmiana w event listenerach
        document.addEventListener('mousemove', handleDrag);
        document.addEventListener('mouseup', handleDragEnd);



        function updateRemoveButtons() {
            const containers = document.querySelectorAll('.waypoint-container');
            
            containers.forEach((container, index) => {
                // Usuń istniejący przycisk usuwania (jeśli istnieje)
                const existingButton = container.querySelector('.remove-waypoint');
                if (existingButton) {
                    existingButton.remove();
                }
                
                // Sprawdź czy to ostatnie puste pole
                const isLastEmpty = index === containers.length - 1 && 
                                container.querySelector('.waypoint').value.trim() === '';
                
                // Sprawdź czy to jedyne pole
                const isOnlyField = containers.length === 1;
                
                // Dodaj przycisk usuwania jeśli:
                // - nie jest to jedyne pole AND
                // - nie jest to ostatnie puste pole
                if (!isOnlyField && !isLastEmpty) {
                    const removeButton = document.createElement('button');
                    removeButton.className = 'remove-waypoint';
                    removeButton.textContent = '×';
                    removeButton.onclick = () => {
                        const input = container.querySelector('.waypoint');
                        if (input && input.value) {
                            geocodedPoints.delete(input.value.trim());
                        }
                        container.remove();
                        updateWaypointNumbers();
                        updateRemoveButtons();
                        clearMap();
                        setTimeout(() => {
                            calculateRouteIfPossible();
                        }, 0);
                    };
                    container.appendChild(removeButton);
                }
            });
        }

        function createWaypointInput() {
            const container = document.createElement('div');
            container.className = 'waypoint-container';
            
            const numberDiv = document.createElement('div');
            numberDiv.className = 'waypoint-number';
            numberDiv.addEventListener('mousedown', handleDragStart);
            container.appendChild(numberDiv);
            
            const box = document.createElement('div');
            box.className = 'waypoint-box';
            
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'waypoint';
            input.placeholder = translations.inputPlaceholder;

            // Dodajemy nowy event listener na kliknięcie
            input.addEventListener('click', function(e) {
                this.select(); // To zaznaczy cały tekst w polu
            });

            const suggestionsContainer = document.createElement('div');
            suggestionsContainer.className = 'suggestions-container';
            
            // Sprawdź aktualną liczbę kontenerów
            const waypointsContainer = document.getElementById('waypoints-container');
            const existingContainers = waypointsContainer.querySelectorAll('.waypoint-container');
            const isFirstContainer = existingContainers.length === 0;
            const willBeLastContainer = container === existingContainers[existingContainers.length - 1];

            // Dodaj przycisk usuwania dla wszystkich pól oprócz pierwszego i ostatniego pustego
            if (!isFirstContainer && !willBeLastContainer) {
                const removeButton = document.createElement('button');
                removeButton.className = 'remove-waypoint';
                removeButton.textContent = '×';
                removeButton.onclick = () => {
                    const input = container.querySelector('.waypoint');
                    if (input && input.value) {
                        geocodedPoints.delete(input.value.trim());
                    }
                    
                    clearMap();
                    container.remove();
                    updateWaypointNumbers();
                    
                    setTimeout(() => {
                        calculateRouteIfPossible();
                    }, 0);
                };
                container.appendChild(removeButton);
            }
            
            box.appendChild(input);
            container.appendChild(box);
            container.appendChild(suggestionsContainer);

            // Dodaj wskaźnik odległości jako część kontenera
            const distanceIndicator = document.createElement('div');
            distanceIndicator.className = 'distance-indicator';
            distanceIndicator.innerHTML = '<span class="arrow">↓</span> -- km';
            container.appendChild(distanceIndicator);

            initializeAutocomplete(input, suggestionsContainer);
            updateWaypointNumbers();
            updateRemoveButtons();
            return container;
        }

        async function lookupPlace(hereId) {
            try {
                apiMonitor.logRequest('lookup');
                const response = await fetch(
                    `https://lookup.search.hereapi.com/v1/lookup` +
                    `?id=${encodeURIComponent(hereId)}` +
                    `&lang=${currentLang}` +
                    `&apiKey=${API_KEY}`
                );

                if (!response.ok) {
                    throw new Error(translations.geocodingError);
                }

                const data = await response.json();
                if (data) {
                    // Tworzymy sformatowany adres z poszczególnych części
                    const addressInfo = data.address;
                    const formattedAddress = [
                        addressInfo.postalCode,
                        addressInfo.city,
                        addressInfo.countryCode,
                        // Dodajemy część z ulicą jeśli istnieje
                        addressInfo.street ? (addressInfo.street + (addressInfo.houseNumber ? ' ' + addressInfo.houseNumber : '')) : ''
                    ].filter(Boolean).join(', ');

                    return {
                        lat: data.position.lat,
                        lng: data.position.lng,
                        address: formattedAddress
                    };
                }
                throw new Error(translations.addressNotFound);
            } catch (error) {
                console.error('Lookup error:', error);
                throw error;
            }
        }

        
        function initializeAutocomplete(input, suggestionsContainer) {
            let searchTimeout;
            let selectedIndex = -1;
            let suggestions = [];

            input.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                const query = input.value.trim();
                
                const gpsCoords = isGPSCoordinates(query);
                
                if (gpsCoords) {
                    suggestionsContainer.style.display = 'none';
                    selectedIndex = -1;
                    calculateRouteIfPossible();
                    return;
                }
                
                if (query.length >= 3) {
                    searchTimeout = setTimeout(async () => {
                        try {
                            apiMonitor.logRequest('autosuggest');
                            const response = await fetch(
                                `https://autocomplete.search.hereapi.com/v1/autocomplete` +
                                `?apiKey=${API_KEY}` +
                                `&q=${encodeURIComponent(query)}` +
                                `&in=countryCode:AND,ALB,AUT,BIH,BEL,BGR,BLR,CHE,CYP,CZE,DEU,DNK,EST,ESP,FIN,FRO,FRA,GBR,GIB,GRC,HRV,HUN,IRL,IMN,ISL,ITA,LIE,LTU,LUX,LVA,MCO,MDA,MNE,MKD,MLT,NLD,NOR,POL,PRT,ROU,SRB,RUS,SWE,SVN,SVK,SMR,TUR,UKR,VAT,KOS` +
                                `&limit=5` +
                                `&lang=${currentLang}`
                            );
                            
                            const data = await response.json();
                            suggestionsContainer.innerHTML = '';
                            suggestions = data.items || [];

                            if (suggestions.length > 0) {
                                selectedIndex = 0;
                                
                                suggestions.forEach((item, index) => {
                                    const div = document.createElement('div');
                                    div.className = 'suggestion-item';
                                    if (index === 0) {
                                        div.classList.add('selected');
                                    }
                                    div.textContent = item.title;
                                    // Dodajemy HERE ID jako data-atrybut
                                    div.dataset.hereId = item.id;
                                    
                                    div.addEventListener('click', () => {
                                        selectSuggestion(item, input);
                                    });
                                    
                                    suggestionsContainer.appendChild(div);
                                });
                                suggestionsContainer.style.display = 'block';
                            } else {
                                suggestionsContainer.style.display = 'none';
                                selectedIndex = -1;
                            }
                        } catch (error) {
                            console.error('Autosuggest error:', error);
                            suggestionsContainer.style.display = 'none';
                            selectedIndex = -1;
                        }
                    }, 300);
                } else {
                    suggestionsContainer.style.display = 'none';
                    selectedIndex = -1;
                }
            });

            input.addEventListener('keydown', (e) => {
                const query = input.value.trim();
                const gpsCoords = isGPSCoordinates(query);
                const suggestionItems = suggestionsContainer.querySelectorAll('.suggestion-item');
                
                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        if (!gpsCoords && selectedIndex < suggestionItems.length - 1) {
                            selectedIndex++;
                            updateSelection(suggestionItems);
                        }
                        break;
                        
                    case 'ArrowUp':
                        e.preventDefault();
                        if (!gpsCoords && selectedIndex > 0) {
                            selectedIndex--;
                            updateSelection(suggestionItems);
                        }
                        break;
                        
                    case 'Enter':
                        e.preventDefault();
                        if (gpsCoords) {
                            handleGPSEntry(input);
                        } else if (suggestionsContainer.style.display === 'block' && selectedIndex >= 0 && suggestions[selectedIndex]) {
                            selectSuggestion(suggestions[selectedIndex], input);
                        }
                        break;
                        
                    case 'Escape':
                        suggestionsContainer.style.display = 'none';
                        selectedIndex = -1;
                        break;
                }
            });

            function updateSelection(items) {
                items.forEach((item, index) => {
                    item.classList.toggle('selected', index === selectedIndex);
                });
            }

            function handleGPSEntry(input) {
                const waypoints = document.querySelectorAll('.waypoint');
                const currentIndex = Array.from(waypoints).indexOf(input);
                const lastWaypoint = waypoints[waypoints.length - 1];
                
                // Dodaj warunek sprawdzający limit
                if (input === lastWaypoint && waypoints.length < 15) {
                    const waypointsContainer = document.getElementById('waypoints-container');
                    waypointsContainer.appendChild(createWaypointInput());
                }
                
                setTimeout(() => {
                    const updatedWaypoints = document.querySelectorAll('.waypoint');
                    const nextInput = updatedWaypoints[currentIndex + 1];
                    if (nextInput) {
                        nextInput.focus();
                    }
                }, 50);

                calculateRouteIfPossible();
            }

            async function selectSuggestion(suggestion, input) {
                try {
                    let result;
                    if (isGPSCoordinates(suggestion.title)) {
                        result = await geocodeAddress(suggestion.title);
                    } else if (suggestion.id) {
                        result = await lookupPlace(suggestion.id);
                    } else {
                        result = await geocodeAddress(suggestion.title);
                    }

                    input.value = result.address;
                    geocodedPoints.set(input.value.trim(), result);
                    
                    const suggestionsContainer = input.parentElement.nextElementSibling;
                    suggestionsContainer.style.display = 'none';

                    const waypoints = document.querySelectorAll('.waypoint');
                    const currentIndex = Array.from(waypoints).indexOf(input);
                    const nextInput = waypoints[currentIndex + 1];
                    const lastWaypoint = waypoints[waypoints.length - 1];

                    // Dodaj nowe pole tylko jeśli jesteśmy na ostatnim i mamy miejsce
                    if (input === lastWaypoint && waypoints.length < 15) {
                        const waypointsContainer = document.getElementById('waypoints-container');
                        waypointsContainer.appendChild(createWaypointInput());
                    }

                    // Przenieś focus do następnego pola i zaznacz jego zawartość
                    setTimeout(() => {
                        if (nextInput) {
                            nextInput.focus();
                            nextInput.select(); // Zaznacz cały tekst
                        }
                    }, 50);

                    calculateRouteIfPossible();
                } catch (error) {
                    console.error('Error processing suggestion:', error);
                }
            }

            input.addEventListener('click', function(e) {
                this.select(); // To zaznaczy cały tekst w polu
                // Nie wywołujemy tutaj żadnych dodatkowych eventów
            });
            
            document.addEventListener('click', (e) => {
                if (!input.contains(e.target) && !suggestionsContainer.contains(e.target)) {
                    suggestionsContainer.style.display = 'none';
                    selectedIndex = -1;
                }
            });
        }

        let allRoutes = [];
        let currentRouteCalculation = null;

        async function calculateRouteIfPossible() {
            try {
                
                // Anuluj poprzednie przeliczanie trasy
                if (currentRouteCalculation) {
                    currentRouteCalculation.abort();
                }
                
                // Utwórz nowy kontroler dla tego przeliczenia
                currentRouteCalculation = new AbortController();
                const signal = currentRouteCalculation.signal;    


                const waypointInputs = Array.from(document.querySelectorAll('.waypoint'))
                    .map(input => ({
                        element: input.parentElement,
                        value: input.value.trim()
                    }))
                    .filter(wp => wp.value !== '');

                clearMap();

                // Check if we have exactly 2 waypoints - delete this line and change alternatives to 1 to remove fature to check if only 2 points to show alternative
                const shouldRequestAlternatives = waypointInputs.length === 2;

                // Handle single waypoint case
                if (waypointInputs.length === 1) {
                    const result = await geocodeAddress(waypointInputs[0].value);
                    addMarker({ lat: result.lat, lng: result.lng }, 1);
                    
                    const input = waypointInputs[0].element.querySelector('.waypoint');
                    if (result.address) {
                        input.value = result.address;
                        geocodedPoints.set(input.value.trim(), result);
                    }

                    map.setCenter({ lat: result.lat, lng: result.lng });
                    map.setZoom(7);
                    return;
                }

                if (waypointInputs.length < 2) {
                    return;
                }
                const geoResults = await Promise.all(
                    waypointInputs.map(async wp => {
                        if (geocodedPoints.has(wp.value)) {
                            return geocodedPoints.get(wp.value);
                        }
                        const result = await geocodeAddress(wp.value);
                        geocodedPoints.set(wp.value, result);
                        return result;
                    })
                );
                apiMonitor.logRequest('routing');    
                geoResults.forEach((result, index) => {
                    addMarker({ lat: result.lat, lng: result.lng }, index + 1);
                    
                    const box = waypointInputs[index].element;
                    const container = box.closest('.waypoint-container');
                    const input = box.querySelector('.waypoint');
                    
                    if (result.address) {
                        input.value = result.address;
                        geocodedPoints.set(input.value.trim(), result);
                    }
                    
                    const numberDiv = container.querySelector('.waypoint-number');
                    numberDiv.textContent = (index + 1).toString();
                });

                const origin = { lat: geoResults[0].lat, lng: geoResults[0].lng };
                const destination = { 
                    lat: geoResults[geoResults.length - 1].lat, 
                    lng: geoResults[geoResults.length - 1].lng 
                };
                const viaPoints = geoResults.slice(1, -1).map(result => ({
                    lat: result.lat,
                    lng: result.lng
                }));

                // Get vehicle parameters
                // Get vehicle parameters
                const vehicleParams = getVehicleParameters();

                // Get excluded areas from dropdown selections
                const excludedAreas = getExcludedAreasForRoute();

                // Construct route URL with exclusions
                let routeUrl = `https://router.hereapi.com/v8/routes` +
                    `?xnlp=CL_JSMv3.1.61.1` +
                    `&apiKey=${API_KEY}` +
                    `&transportMode=truck` +
                    `&routingMode=fast` +
                    `&units=metric` +
                    `&lang=${currentLang}` +
                    `&currency=EUR` +
                    `&alternatives=${shouldRequestAlternatives ? '1' : '0'}` + 
                    `&spans=tollSystems,truckAttributes,countryCode,length,routeNumbers,notices` +
                    `&return=polyline,tolls,summary,travelSummary,passthrough,routeHandle,incidents,actions,potentialTimeDependentViolations`;

                // Add vehicle parameters
                routeUrl += `&vehicle[height]=${vehicleParams.height}` +
                    `&vehicle[width]=${vehicleParams.width}` +
                    `&vehicle[length]=${vehicleParams.length}` +
                    `&vehicle[currentWeight]=${vehicleParams.weight}` +
                    `&vehicle[grossWeight]=${vehicleParams.weight}` +
                    `&vehicle[axleCount]=${vehicleParams.truckAxles + vehicleParams.trailerAxles}` +
                    `&vehicle[tiresCount]=${(vehicleParams.truckAxles + vehicleParams.trailerAxles) * 2}` +
                    `&vehicle[engineType]=internalCombustion` +
                    `&vehicle[weightPerAxle]=10000` +
                    `&vehicle[heightAboveFirstAxle]=${vehicleParams.height}`;

                // Add trailer parameters if vehicle has trailer
                if (vehicleParams.trailerCount > 0) {
                    routeUrl += `&vehicle[trailerCount]=${vehicleParams.trailerCount}` +
                            `&vehicle[trailerAxleCount]=${vehicleParams.trailerAxles}`;
                }

                // Add toll parameters
                routeUrl += `&departureTime=any` +
                    `&tolls[emissionType]=euro${vehicleParams.euroClass};co2class=${vehicleParams.co2Class}` +
                    `&tolls[summaries]=total`;

                // Add excluded areas
                const excludedItems = getExcludedAreasForRoute();

                // Add excluded countries as a comma-separated list (only one parameter)
                if (excludedItems.excludedCountries.length > 0) {
                    routeUrl += `&exclude[countries]=${excludedItems.excludedCountries.join(',')}`;
                }

                // Add excluded areas as a single parameter with multiple values
                if (excludedItems.excludedAreas.length > 0) {
                    const areasToAvoid = excludedItems.excludedAreas.map(area => 
                        `bbox:${area.west},${area.south},${area.east},${area.north}`
                    );
                    routeUrl += `&avoid[areas]=${areasToAvoid.join('|')}`;
                }

                // Add waypoints
                routeUrl += `&origin=${origin.lat},${origin.lng}` +
                    `&destination=${destination.lat},${destination.lng}`;

                if (viaPoints.length > 0) {
                    routeUrl += viaPoints.map(point =>
                        `&via=${point.lat},${point.lng};snapRadius=3000`
                    ).join('');
}



                const response = await fetch(routeUrl, { signal });
                if (!response.ok) {
                    throw new Error(`${translations.routeError}: ${response.status}`);
                }

                const result = await response.json();
                function addRouteBubble(mainRoute, alternativeRoute) {
                    // Zbierz punkty z trasy głównej
                    const mainPoints = [];
                    mainRoute.sections.forEach(section => {
                        const lineString = H.geo.LineString.fromFlexiblePolyline(section.polyline);
                        const latLngArray = lineString.getLatLngAltArray();
                        for (let i = 0; i < latLngArray.length; i += 3) {
                            mainPoints.push({
                                lat: latLngArray[i],
                                lng: latLngArray[i + 1]
                            });
                        }
                    });

                    // Zbierz punkty z trasy alternatywnej
                    const altPoints = [];
                    alternativeRoute.sections.forEach(section => {
                        const lineString = H.geo.LineString.fromFlexiblePolyline(section.polyline);
                        const latLngArray = lineString.getLatLngAltArray();
                        for (let i = 0; i < latLngArray.length; i += 3) {
                            altPoints.push({
                                lat: latLngArray[i],
                                lng: latLngArray[i + 1]
                            });
                        }
                    });

                    // Znajdź punkt największego odchylenia
                    let maxDeviation = 0;
                    let deviationPoint = altPoints[Math.floor(altPoints.length / 2)]; // domyślnie środek trasy alternatywnej

                    // Sprawdzamy co 10-ty punkt dla optymalizacji
                    for (let i = 0; i < altPoints.length; i += 10) {
                        const altPoint = altPoints[i];
                        let minDistance = Infinity;

                        // Sprawdzamy co 10-ty punkt trasy głównej
                        for (let j = 0; j < mainPoints.length; j += 10) {
                            const mainPoint = mainPoints[j];
                            const latDiff = altPoint.lat - mainPoint.lat;
                            const lngDiff = altPoint.lng - mainPoint.lng;
                            const distance = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
                            
                            if (distance < minDistance) {
                                minDistance = distance;
                            }
                        }

                        if (minDistance > maxDeviation) {
                            maxDeviation = minDistance;
                            deviationPoint = altPoint;
                        }
                    }

                    // Oblicz różnice
                    const mainDistance = mainRoute.sections.reduce((sum, section) => sum + section.summary.length, 0);
                    const altDistance = alternativeRoute.sections.reduce((sum, section) => sum + section.summary.length, 0);
                    const mainTolls = calculateTotalTolls(mainRoute);
                    const altTolls = calculateTotalTolls(alternativeRoute);
                    
                    const distanceDiff = ((altDistance - mainDistance) / 1000);
                    const tollsDiff = (altTolls - mainTolls);
                    
                    // Sprawdź czy różnice przekraczają progi
                    const DISTANCE_THRESHOLD = 0.1; // 100m
                    const TOLL_THRESHOLD = 0.1; // 0.1 EUR
                    

                    if (Math.abs(distanceDiff) > DISTANCE_THRESHOLD || Math.abs(tollsDiff) > TOLL_THRESHOLD) {
                        const bubbleId = 'route-switch-' + Math.random().toString(36).substr(2, 9);

                        const bubbleContent = `
                            <div id="${bubbleId}" style="cursor: pointer;">
                                <div style="color: ${distanceDiff > 0 ? '#ff4444' : '#44aa44'}">${distanceDiff > 0 ? '+' : ''}${distanceDiff.toFixed(1)} km</div>
                                <div style="color: ${tollsDiff > 0 ? '#ff4444' : '#44aa44'}">${tollsDiff > 0 ? '+' : ''}${tollsDiff.toFixed(2)} €</div>
                            </div>
                        `;
                        
                        const bubble = new H.ui.InfoBubble(deviationPoint, {
                            content: bubbleContent,
                            hideCloseButton: true,
                            autoClose: false
                        });
                        
                        bubble.open();
                        ui.addBubble(bubble);
                        routeBubbles.push(bubble);

                        setTimeout(() => {
                            const element = document.getElementById(bubbleId);
                            if (element) {
                                element.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                    const alternativeIndex = allRoutes.findIndex(route => route === alternativeRoute);
                                    if (alternativeIndex !== -1) {
                                        currentRouteIndex = alternativeIndex;
                                        displayRoutes(allRoutes, alternativeIndex);
                                    }
                                });
                            }
                        }, 100);
                    }
                }

                function calculateTotalTolls(route) {
                    if (!route.sections) return 0;
                    
                    const countryTolls = new Map();
                    const processedFareIds = new Set();
                    let totalToll = 0;

                    route.sections.forEach(section => {
                        if (section.tolls) {
                            section.tolls.forEach(toll => {
                                if (MANUAL_TOLL_SYSTEMS.hasOwnProperty(toll.tollSystem)) {
                                    return;
                                }

                                const countryCode = toll.countryCode;
                                if (!countryTolls.has(countryCode)) {
                                    countryTolls.set(countryCode, 0);
                                }

                                if (toll.fares) {
                                    let minFare = Infinity;
                                    let hasPassSubscription = false;
                                    let minPassSubscriptionFare = Infinity;

                                    toll.fares.forEach(fare => {
                                        if (processedFareIds.has(fare.id)) return;
                                        
                                        const value = fare.convertedPrice?.value || fare.price?.value || 0;
                                        processedFareIds.add(fare.id);
                                        
                                        if (fare.paymentMethods?.includes('passSubscription')) {
                                            hasPassSubscription = true;
                                            minPassSubscriptionFare = Math.min(minPassSubscriptionFare, value);
                                        } else {
                                            minFare = Math.min(minFare, value);
                                        }
                                    });
                                    
                                    // Użyj niższej wartości: albo minimalnej opłaty standardowej, albo minimalnej opłaty za pass subscription
                                    if (hasPassSubscription && minPassSubscriptionFare !== Infinity) {
                                        countryTolls.set(countryCode, countryTolls.get(countryCode) + minPassSubscriptionFare);
                                    } else if (minFare !== Infinity) {
                                        countryTolls.set(countryCode, countryTolls.get(countryCode) + minFare);
                                    }
                                }
                            });
                        }
                    });

                    return Array.from(countryTolls.values()).reduce((a, b) => a + b, 0);
                }



                
                if (result.routes && result.routes.length > 0) {
                    allRoutes = result.routes; // Zapisujemy wszystkie trasy
                    displayRoutes(allRoutes, currentRouteIndex);
                }

                // Funkcja znajdująca kraje na trasie i ich długości
                function getCountriesFromRoute(route) {
                    let countriesInfo = new Map();
                    
                    route.sections.forEach(section => {
                        if (section.spans) {
                            section.spans.forEach(span => {
                                if (span.countryCode) {
                                    const distance = span.length || 0;
                                    const current = countriesInfo.get(span.countryCode) || 0;
                                    countriesInfo.set(span.countryCode, current + distance);
                                }
                            });
                        }
                    });
                    
                    return countriesInfo;
                }

                // Funkcja znajdująca najniższą cenę paliwa dla krajów na trasie
                function getLowestFuelPrice(countriesInfo) {
                    let lowestPrice = Infinity;
                    let lowestPriceCountry = null;
                    
                    for (const [countryCode] of countriesInfo) {
                        let price;
                        if (companyCosts.useCustomFuelPrices) {
                            // Sprawdzamy czy kraj ma zdefiniowaną cenę niestandardową lub domyślną
                            price = companyCosts.customFuelPrices[countryCode] || defaultFuelPrices[countryCode];
                        } else {
                            price = defaultFuelPrices[countryCode];
                        }
                        
                        // Bierzemy pod uwagę tylko kraje z zdefiniowaną ceną
                        if (price && !isNaN(price) && price < lowestPrice) {
                            lowestPrice = price;
                            lowestPriceCountry = countryCode;
                        }
                    }
                    
                    // Jeśli nie znaleziono żadnej ceny, zwracamy null
                    if (lowestPrice === Infinity) {
                        return {
                            price: null,
                            country: null
                        };
                    }
                    
                    return {
                        price: lowestPrice,
                        country: lowestPriceCountry
                    };
                }

                // Funkcja obliczająca koszty paliwa
                function calculateFuelCosts(route, vehicle, selectedCountry = null) {
                    const totalDistance = route.sections.reduce((sum, section) => 
                        sum + (section.summary?.length || 0), 0);
                    
                    const distanceInKm = totalDistance / 1000;
                    const fuelConsumption = vehicle.fuelConsumption / 100; // L/km
                    const adblueConsumption = vehicle.adblueConsumption / 100; // L/km
                    
                    const totalFuelNeeded = distanceInKm * fuelConsumption;
                    const totalAdBlueNeeded = distanceInKm * adblueConsumption;
                    
                    // Logika dla AdBlue
                    let adbluePrice;
                    if (companyCosts.useCustomFuelPrices) {
                        if (companyCosts.customFuelPrices.adblue !== undefined) {
                            adbluePrice = companyCosts.customFuelPrices.adblue;
                        } else {
                            adbluePrice = defaultFuelPrices.adblue;
                        }
                    } else {
                        adbluePrice = defaultFuelPrices.adblue;
                    }
                    
                    const adblueCost = totalAdBlueNeeded * adbluePrice;

                    let fuelPrice;
                    let priceDetails = {};

                    if (selectedCountry) {
                        fuelPrice = companyCosts.useCustomFuelPrices && companyCosts.customFuelPrices[selectedCountry] ? 
                            companyCosts.customFuelPrices[selectedCountry] : 
                            defaultFuelPrices[selectedCountry];
                            
                        // Sprawdzamy czy cena została znaleziona
                        if (fuelPrice && !isNaN(fuelPrice)) {
                            priceDetails = {
                                country: selectedCountry,
                                price: fuelPrice,
                                type: 'selected'
                            };
                        } else {
                            // Jeśli nie znaleziono ceny dla wybranego kraju, szukamy najniższej dostępnej
                            const countriesInfo = getCountriesFromRoute(route);
                            const lowestFuelInfo = getLowestFuelPrice(countriesInfo);
                            fuelPrice = lowestFuelInfo.price;
                            priceDetails = {
                                country: lowestFuelInfo.country,
                                price: fuelPrice,
                                type: 'lowest'
                            };
                        }
                    } else {
                        const countriesInfo = getCountriesFromRoute(route);
                        const lowestFuelInfo = getLowestFuelPrice(countriesInfo);
                        fuelPrice = lowestFuelInfo.price;
                        priceDetails = {
                            country: lowestFuelInfo.country,
                            price: fuelPrice,
                            type: 'lowest'
                        };
                    }

                    // Sprawdzamy czy udało się znaleźć jakąkolwiek cenę
                    if (!fuelPrice || isNaN(fuelPrice)) {
                        return {
                            fuelNeeded: totalFuelNeeded,
                            adblueNeeded: totalAdBlueNeeded,
                            fuelCost: 0,
                            adblueCost: adblueCost,
                            totalCost: adblueCost, // tylko koszt AdBlue
                            priceDetails: {
                                country: null,
                                price: null,
                                type: 'no_prices_available'
                            },
                            adbluePrice: adbluePrice
                        };
                    }

                    const fuelCost = totalFuelNeeded * fuelPrice;
                    const totalCost = fuelCost + adblueCost;
                    
                    return {
                        fuelNeeded: totalFuelNeeded,
                        adblueNeeded: totalAdBlueNeeded,
                        fuelCost: fuelCost,
                        adblueCost: adblueCost,
                        totalCost: totalCost,
                        priceDetails: priceDetails,
                        adbluePrice: adbluePrice
                    };
                }

                // Funkcja generująca HTML dla sekcji kosztów paliwa
                function generateFuelCostsHTML(fuelCosts, route, selectedVehicle) {
                    const { totalCost, fuelNeeded, adblueNeeded, fuelCost, adblueCost, priceDetails, adbluePrice } = fuelCosts;
                    const totalDistance = route.sections.reduce((sum, section) => 
                        sum + (section.summary?.length || 0), 0) / 1000;
                    const costPerKm = totalCost / totalDistance;

                    // Pobierz kraje z trasy
                    const countriesFromRoute = getCountriesFromRoute(route);
                    
                    // Funkcja pomocnicza do pobierania aktualnej ceny dla kraju
                    function getPriceForCountry(countryCode) {
                        if (companyCosts.useCustomFuelPrices && companyCosts.customFuelPrices[countryCode] !== undefined) {
                            return companyCosts.customFuelPrices[countryCode];
                        }
                        return defaultFuelPrices[countryCode];
                    }

                    // Przygotuj kraje z trasy (posortowane po cenie)
                    const routeCountries = Array.from(countriesFromRoute.keys())
                        .map(code => ({
                            code,
                            price: getPriceForCountry(code)
                        }))
                        .sort((a, b) => a.price - b.price);

                    // Przygotuj pozostałe kraje
                    const otherCountries = Object.entries(defaultFuelPrices)
                        .filter(([code]) => code !== 'adblue' && !countriesFromRoute.has(code))
                        .map(([code]) => ({
                            code,
                            price: getPriceForCountry(code)
                        }))
                        .sort((a, b) => a.code.localeCompare(b.code)); // sortuj alfabetycznie

                    // Generuj opcje
                    const countryOptions = `
                        ${routeCountries.map(({ code, price }) => {
                            // Dodajemy tylko kraje z zdefiniowaną ceną
                            if (price && !isNaN(price)) {
                                return `
                                    <option value="${code}" ${priceDetails.country === code ? 'selected' : ''} style="font-weight: bold">
                                        ${code} (${price.toFixed(2)}€/L)
                                    </option>
                                `;
                            }
                            return ''; // Pomijamy kraje bez zdefiniowanej ceny
                        }).join('')}
                        ${otherCountries.length > 0 ? '<option disabled>──────────</option>' : ''}
                        ${otherCountries.map(({ code, price }) => {
                            // Również sprawdzamy czy cena jest zdefiniowana
                            if (price && !isNaN(price)) {
                                return `
                                    <option value="${code}" ${priceDetails.country === code ? 'selected' : ''}>
                                        ${code} (${price.toFixed(2)}€/L)
                                    </option>
                                `;
                            }
                            return '';
                        }).join('')}`;

                    // Aktualizujemy tylko zawartość szczegółów, nie całą strukturę
                    const detailsContent = `
                        <div class="country-toll">
                            ${translations.fuelConsumption}: ${selectedVehicle.fuelConsumption}L/100km
                        </div>
                        <div class="country-toll">
                            ${translations.fuelInCountry}: 
                            <select class="fuel-country-select" style="padding: 2px 5px; border: 1px solid #ddd; border-radius: 3px;">
                                <option value="">${translations.lowestPrice}</option>
                                ${countryOptions}
                            </select>
                        </div>
                        <div class="fuel-costs-details">
                            <div class="country-toll">
                                ${translations.fuel}: ${fuelNeeded.toFixed(0)}L × ${priceDetails.price.toFixed(2)}€/L = ${fuelCost.toFixed(2)}€
                            </div>
                            <div class="country-toll">
                                AdBlue: ${adblueNeeded.toFixed(1)}L × ${adbluePrice.toFixed(2)}€/L = ${adblueCost.toFixed(2)}€
                            </div>
                        </div>`;

                    // Główna wartość
                    const mainValue = `${totalCost.toFixed(2)} € (${costPerKm.toFixed(2)} €/km)`;

                    setTimeout(() => {
                        const countrySelect = document.querySelector('.fuel-country-select');
                        if (countrySelect) {
                            countrySelect.addEventListener('change', (e) => {
                            const selectedCountry = e.target.value || null;
                            const newFuelCosts = calculateFuelCosts(route, selectedVehicle, selectedCountry);
                            
                            const mainValueElement = document.querySelector('.fuel-costs-main-value');
                            const detailsElement = document.querySelector('.fuel-costs-details');
                            
                            if (mainValueElement) {
                                mainValueElement.textContent = `${newFuelCosts.totalCost.toFixed(2)} € (${(newFuelCosts.totalCost/totalDistance).toFixed(2)} €/km)`;
                            }
                            
                            if (detailsElement) {
                                detailsElement.innerHTML = `
                                    <div class="country-toll">
                                        Paliwo: ${newFuelCosts.fuelNeeded.toFixed(0)}L × ${newFuelCosts.priceDetails.price.toFixed(2)}€/L = ${newFuelCosts.fuelCost.toFixed(2)}€
                                    </div>
                                    <div class="country-toll">
                                        AdBlue: ${newFuelCosts.adblueNeeded.toFixed(1)}L × ${newFuelCosts.adbluePrice.toFixed(2)}€/L = ${newFuelCosts.adblueCost.toFixed(2)}€
                                    </div>`;
                            }

                            // Dodaj to wywołanie:
                            updateTotalCosts(route, selectedVehicle);
                        });
                        }
                    }, 0);

                    return `
                        <div class="stat-value">
                            <span class="fuel-costs-main-value">${mainValue}</span>
                            <button class="toll-details-toggle">▼</button>
                            <div class="toll-details" style="display: none;">
                                <div class="toll-details-content">
                                    ${detailsContent}
                                </div>
                            </div>
                        </div>`;
                    }

                    function calculateWorkingTime(routeDistance, vehicle) {
                        const kmPerDay = (vehicle.avgKm * 12) / vehicle.workingDays;
                        const theoreticalDays = routeDistance / kmPerDay;
                        
                        return {
                            days: Math.floor(theoreticalDays),
                            hours: Math.round((theoreticalDays - Math.floor(theoreticalDays)) * 24),
                            kmPerDay: kmPerDay
                        };
                    }

                    function calculateOtherCosts(route, vehicle, actualTime = null) {
                        const routeDistance = route.sections.reduce((sum, section) => 
                            sum + section.summary.length, 0) / 1000; // w km

                        // Obliczenie km na dzień roboczy (24h)
                        const kmPerDay = (vehicle.avgKm * 12) / vehicle.workingDays;
                        
                        // Obliczenie kosztu stałego na dzień roboczy (24h)
                        const fixedCostPerDay = vehicle.advFixedPerMonth / (vehicle.workingDays / 12);
                        
                        // Obliczenie teoretycznego czasu i zaokrąglenie w górę do pełnych godzin
                        const theoreticalDays = routeDistance / kmPerDay;
                        const theoreticalHoursTotal = Math.ceil(theoreticalDays * 24); // zaokrąglamy w górę do pełnych godzin
                        
                        const theoreticalTime = {
                            days: Math.floor(theoreticalHoursTotal / 24),
                            hours: theoreticalHoursTotal % 24
                        };
                        
                        // Jeśli nie ma aktualnego czasu, użyj teoretycznego
                        if (!actualTime) {
                            actualTime = {...theoreticalTime};
                        }

                        const actualHoursTotal = actualTime.days * 24 + actualTime.hours;
                        
                        // Obliczenie kosztów stałych na podstawie całkowitej liczby godzin
                        const fixedCostPerHour = fixedCostPerDay / 24;
                        const fixedCosts = fixedCostPerHour * actualHoursTotal;

                        // Obliczenie kosztów zmiennych (zawsze stałe na km)
                        const variableCosts = routeDistance * vehicle.advVariablePerKM;

                        const totalCosts = fixedCosts + variableCosts;

                        return {
                            total: totalCosts,
                            costPerKm: totalCosts / routeDistance,
                            fixedCosts: fixedCosts,
                            variableCosts: variableCosts,
                            theoreticalTime: theoreticalTime,
                            actualTime: actualTime,
                            routeDistance: routeDistance
                        };
                    }


                    function generateOtherCostsHTML(costs, vehicle) {
                        return `
                            <div class="stat-value other-costs-main">
                                <span>${costs.total.toFixed(2)} € (${costs.costPerKm.toFixed(2)} €/km)</span>
                                <button class="toll-details-toggle">▼</button>
                                <div class="toll-details" style="display: none;">
                                    <div class="toll-details-content">
                                        <div class="country-toll">
                                            ${translations.fixedCosts}: ${costs.fixedCosts.toFixed(2)} €
                                        </div>
                                        <div class="country-toll">
                                            Koszty zmienne (${vehicle.advVariablePerKM.toFixed(2)} €/km): ${costs.variableCosts.toFixed(2)} €
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="stat-label">${translations.workingTime}</div>
                            <div class="stat-value working-time-value">
                                <span>${costs.actualTime.days} ${translations.days} ${costs.actualTime.hours} ${translations.hours}</span>
                                <div class="time-controls">
                                    <button class="time-adjust plus">+</button>
                                    <button class="time-adjust minus">-</button>
                                </div>
                            </div>
                        `;
                    }

                    function updateTotalCosts(route, selectedVehicle) {
                        const hasferryOrTrain = route.sections.some(section => 
                            section.transport?.mode === 'ferry' || 
                            section.transport?.mode.toLowerCase().includes('shuttletrain')
                        );

                        // Obliczanie całkowitego dystansu w km (tylko dla odcinków drogowych)
                        const totalDistance = route.sections.reduce((sum, section) => {
                            if (section.transport?.mode === 'truck') {
                                return sum + section.summary.length;
                            }
                            return sum;
                        }, 0) / 1000;

                        if (selectedVehicle.simpleCosts) {
                            const simpleCosts = totalDistance * selectedVehicle.simpleCostValuePerKM;
                            const totalCostsElement = document.querySelector('.total-costs-value');
                            if (totalCostsElement) {
                                totalCostsElement.textContent = `${simpleCosts.toFixed(2)} € (${selectedVehicle.simpleCostValuePerKM.toFixed(2)} €/km)`;
                            }
                            return;
                        }

                        // 1. Koszty paliwa
                        const fuelCountrySelect = document.querySelector('.fuel-country-select');
                        const selectedCountry = fuelCountrySelect ? fuelCountrySelect.value : null;
                        const fuelCosts = calculateFuelCosts(route, selectedVehicle, selectedCountry);
                        
                        // 2. Pozostałe koszty (z aktualnym czasem pracy)
                        const timeText = document.querySelector('.working-time-value span').textContent;
                        const [days, hours] = timeText.match(/(\d+)/g).map(Number);
                        const otherCosts = calculateOtherCosts(route, selectedVehicle, { days, hours });
                        
                        // 3. Opłaty drogowe automatyczne
                        const totalToll = calculateTotalTolls(route);
                        
                        // 4. Opłaty manualne i promy
                        let ferryAndManualTotal = 0;

                        // Promy i pociągi
                        route.sections.forEach(section => {
                            if (section.transport?.mode === 'ferry' || 
                                section.transport?.mode.toLowerCase().includes('shuttletrain')) {
                                const transportName = section.transport.name;
                                const inputElement = document.querySelector(`input[data-ferry-name="${transportName}"]`);
                                if (inputElement && inputElement.value && !isNaN(inputElement.value)) {
                                    ferryAndManualTotal += parseFloat(inputElement.value);
                                }
                            }
                        });
                        
			// Manualne opłaty drogowe
			const processedTollSystems = new Set(); // Keep track of processed toll systems
			route.sections.forEach(section => {
			    if (section.tolls) {
			        section.tolls.forEach(toll => {
			            if (MANUAL_TOLL_SYSTEMS.hasOwnProperty(toll.tollSystem) && !processedTollSystems.has(toll.tollSystem)) {
			                processedTollSystems.add(toll.tollSystem); // Mark as processed
			                const inputElement = document.querySelector(`input[data-toll-system="${toll.tollSystem}"]`);
			                if (inputElement && inputElement.value && !isNaN(inputElement.value)) {
			                    ferryAndManualTotal += parseFloat(inputElement.value);
			                }
			            }
			        });
			    }
			});

                        const totalCosts = fuelCosts.totalCost + otherCosts.total + totalToll + ferryAndManualTotal;
                        const costPerKm = totalCosts / totalDistance;

                        // Aktualizacja wyświetlanej sumy
                        const totalCostsElement = document.querySelector('.total-costs-value');
                        if (totalCostsElement) {
                            totalCostsElement.textContent = `${totalCosts.toFixed(2)} € (${costPerKm.toFixed(2)} €/km)`;
                        }
                    }


                function displayRoutes(routes, activeIndex) {
                    clearMap();
                    
                    // Oblicz metryki głównej trasy do porównania
                    const mainRoute = routes[activeIndex];
                    const mainDistance = mainRoute.sections.reduce((sum, section) => sum + section.summary.length, 0);
                    const mainTolls = calculateTotalTolls(mainRoute);

                    // Przetwórz każdą trasę (główną i alternatywne)
                    routes.forEach((route, routeIndex) => {
                        const sections = route.sections;
                        const isAlternative = routeIndex !== activeIndex;
                        
                        sections.forEach((section, sectionIndex) => {
                            const lineString = H.geo.LineString.fromFlexiblePolyline(section.polyline);
                            
                            // W funkcji displayRoutes, gdzie tworzymy polyline:
                            const ROUTE_STYLES = {
                                alternative: {
                                    strokeColor: '#808080',
                                    lineWidth: 5,
                                    lineCap: 'round',
                                    lineJoin: 'round',
                                    lineDash: [ ],
                                    strokeLinecap: 'round',
                                    strokeLinejoin: 'round'
                                },
                                main: {
                                    strokeColor: 'rgba(0, 100, 255, 0.9)',
                                    lineWidth: 5,
                                    lineCap: 'round',
                                    lineJoin: 'round',
                                    lineDash: [ ],
                                    strokeLinecap: 'round',
                                    strokeLinejoin: 'round'
                                }
                            };

                            // Użycie
                            const polyline = new H.map.Polyline(lineString, {
                                style: isAlternative ? ROUTE_STYLES.alternative : ROUTE_STYLES.main
                            });

                            // Dodaj informację o sekcji do polyline
                            polyline.setData({
                                sectionIndex: sectionIndex
                            });


                            polyline.setZIndex(isAlternative ? 1 : 2);
                            map.addObject(polyline);
                            routeLines.push(polyline);
                            

                            if (isAlternative) {
                                polyline.addEventListener('tap', () => {
                                    currentRouteIndex = routeIndex;
                                    displayRoutes(allRoutes, routeIndex);
                                });
                            }

                            map.addObject(polyline);
                            routeLines.push(polyline);

                            // Dodanie drag handle tylko dla aktywnej trasy
                            if (!isAlternative) {
                                // Dodaj marker-uchwyt (początkowo ukryty)
                                const svgMarkup = '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">' +
                                    '<circle cx="12" cy="12" r="11" fill="white" fill-opacity="0.8" stroke="#0066CC" stroke-width="2"/>' +
                                    '<circle cx="12" cy="12" r="6" fill="#0066CC" fill-opacity="0.3"/>' +
                                    '</svg>';
                                
                                const dragHandle = new H.map.Marker({ lat: 0, lng: 0 }, {
                                    icon: new H.map.Icon(svgMarkup, {
                                        anchor: { x: 12, y: 12 }
                                    }),
                                    visibility: false,
                                    volatility: true
                                });

                                dragHandle.addEventListener('pointerenter', () => {
                                    isOverHandle = true;
                                    clearTimeout(hideHandleTimeout);
                                });

                                dragHandle.addEventListener('pointerleave', () => {
                                    isOverHandle = false;
                                    if (!isDragging) {
                                        hideHandleTimeout = setTimeout(() => {
                                            if (!isOverHandle) {
                                                dragHandle.setVisibility(false);
                                                map.getViewPort().element.style.cursor = 'default';
                                            }
                                        }, 100);
                                    }
                                });
                                

                                dragHandle.draggable = true;
                                map.addObject(dragHandle);
                                routeLines.push(dragHandle);

                                // Obsługa ruchu myszy nad polyline
                                let isDragging = false;
                                let currentDragSegmentIndex = null;


                                polyline.addEventListener('pointermove', (evt) => {
                                    if (isDragging) return;
                                    
                                    clearTimeout(hideHandleTimeout);
                                    
                                    const pointer = evt.currentPointer;
                                    const coordinates = lineString.getLatLngAltArray();
                                    let closestPoint = null;
                                    let minDistance = Infinity;

                                    for(let i = 0; i < coordinates.length - 2; i += 3) {
                                        const point = map.geoToScreen({ 
                                            lat: coordinates[i], 
                                            lng: coordinates[i + 1] 
                                        });
                                        const distance = Math.hypot(point.x - pointer.viewportX, point.y - pointer.viewportY);
                                        
                                        if (distance < minDistance) {
                                            minDistance = distance;
                                            closestPoint = { lat: coordinates[i], lng: coordinates[i + 1] };
                                            currentDragSegmentIndex = polyline.getData().sectionIndex;
                                        }
                                    }

                                    if (minDistance < 50 || isOverHandle) {
                                        dragHandle.setGeometry(closestPoint);
                                        dragHandle.setVisibility(true);
                                        map.getViewPort().element.style.cursor = 'grab';
                                    }
                                });

                                // Obsługa przeciągania
                                dragHandle.addEventListener('pointerdown', (evt) => {
                                    evt.stopPropagation();
                                    isDragging = true;
                                    currentDragHandle = evt.target;
                                    behavior.disable();
                                    map.getViewPort().element.style.cursor = 'grabbing';
                                    
                                    const handlePointerMove = (e) => {
                                        if (!isDragging) return;
                                        const rect = map.getViewPort().element.getBoundingClientRect();
                                        const pointer = {
                                            viewportX: e.clientX - rect.left,
                                            viewportY: e.clientY - rect.top
                                        };
                                        currentDragHandle.setGeometry(map.screenToGeo(pointer.viewportX, pointer.viewportY));
                                    };

                                    const handlePointerUp = (e) => {
                                        if (!isDragging) return;

                                        const position = currentDragHandle.getGeometry();
                                        currentDragHandle.setVisibility(false);
                                        isDragging = false;
                                        behavior.enable();
                                        map.getViewPort().element.style.cursor = 'default';

                                        if (currentDragSegmentIndex !== null) {
                                            const waypointContainers = document.querySelectorAll('.waypoint-container');
                                            const newWaypoint = createWaypointInput();
                                            const input = newWaypoint.querySelector('.waypoint');
                                            input.value = `${position.lat.toFixed(6)}, ${position.lng.toFixed(6)}`;

                                            // Wstaw punkt za waypointem odpowiadającym początku sekcji
                                            const targetContainer = waypointContainers[currentDragSegmentIndex + 1];
                                            if (targetContainer) {
                                                waypointContainers[0].parentNode.insertBefore(newWaypoint, targetContainer);
                                            } else {
                                                waypointContainers[0].parentNode.appendChild(newWaypoint);
                                            }

                                            input.dispatchEvent(new Event('input'));
                                            updateWaypointNumbers();
                                            calculateRouteIfPossible();
                                        }

                                        currentDragHandle = null;
                                        currentDragSegmentIndex = null;
                                        document.removeEventListener('pointermove', handlePointerMove);
                                        document.removeEventListener('pointerup', handlePointerUp);
                                    };

                                    document.addEventListener('pointermove', handlePointerMove);
                                    document.addEventListener('pointerup', handlePointerUp);
                                });

                                polyline.addEventListener('pointerleave', () => {
                                    if (!isDragging && !isOverHandle) {
                                        hideHandleTimeout = setTimeout(() => {
                                            if (!isOverHandle) {
                                                dragHandle.setVisibility(false);
                                                map.getViewPort().element.style.cursor = 'default';
                                            }
                                        }, 100);
                                    }
                                });
                            }
                        });
                        function updateDistanceIndicators(route) {
                            const distanceIndicators = document.querySelectorAll('.distance-indicator');
                            distanceIndicators.forEach(indicator => indicator.classList.remove('visible'));

                            if (route.sections) {
                                route.sections.forEach((section, index) => {
                                    const indicator = distanceIndicators[index];
                                    if (indicator && section.summary && section.summary.length) {
                                        const distanceInKm = (section.summary.length / 1000).toFixed(1);
                                        const timeInHours = (distanceInKm / 73).toFixed(1);
                                        const hours = Math.floor(timeInHours);
                                        const minutes = Math.round((timeInHours - hours) * 60);
                                        
                                        const timeDisplay = hours > 0 ? 
                                            `${hours}h ${minutes}min` : 
                                            `${minutes}min`;
                                        
                                        indicator.innerHTML = `<span class="arrow">↓</span> ${distanceInKm} km (${timeDisplay})`;
                                        indicator.classList.add('visible');
                                    }
                                });
                            }
                        }

                        // I wywołaj ją dla aktywnej trasy
                        if (routeIndex === currentRouteIndex) {
                            updateDistanceIndicators(route);
                        }


                        // Dodaj markery tylko dla aktualnej trasy
                        if (routeIndex === currentRouteIndex) {
                            geoResults.forEach((result, index) => {
                                addMarker({ lat: result.lat, lng: result.lng }, index + 1);
                            });

                            // Oblicz i wyświetl informacje o trasie
                            const totalDistance = route.sections.reduce((sum, section) => {
                                if (section.transport?.mode === 'truck') {
                                    return sum + section.summary.length;
                                }
                                return sum;
                            }, 0);
                            const distanceInKm = totalDistance / 1000;
                            const timeInHours = distanceInKm / 73;
                            const totalTime = timeInHours * 3600;

                            // Pobieranie informacji o opłatach
                            let tollInfo = '';
                            if (route.sections) {
                                const countryTolls = new Map();
                                const ferries = new Map();
                                const minPassSubscriptionTolls = new Map();
                                const processedFareIds = new Set();
                                let totalToll = 0;
                                
                                route.sections.forEach(section => {
                                    if (section.transport?.mode) {
                                        const transportMode = section.transport.mode;
                                        const transportName = section.transport.name;
                                        
                                        if (transportName && (
                                            transportMode === 'ferry' || 
                                            transportMode.toLowerCase().includes('shuttletrain')
                                        )) {
                                            const icon = transportMode === 'ferry' ? '⛴️' : '🛤️';
                                            ferries.set(transportName, {
                                                icon: icon,
                                                value: localStorage.getItem(`ferry_${transportName}`) || ''
                                            });
                                        }
                                    }
                                    if (section.tolls) {
                                        section.tolls.forEach(toll => {
                                            // Pomijamy systemy z listy MANUAL_TOLL_SYSTEMS
                                            if (toll.tollSystem in MANUAL_TOLL_SYSTEMS) {
                                                return;
                                            }

                                            const countryCode = toll.countryCode;
                                            if (!countryTolls.has(countryCode)) {
                                                countryTolls.set(countryCode, 0);
                                            }

                                            if (toll.fares) {
                                                let minFare = Infinity;
                                                toll.fares.forEach(fare => {
                                                    const value = fare.convertedPrice?.value || fare.price?.value || 0;
                                                    
                                                    if (fare.paymentMethods?.includes('passSubscription')) {
                                                        const key = `${toll.countryCode}_${toll.tollSystem}`;
                                                        if (!minPassSubscriptionTolls.has(key) || value < minPassSubscriptionTolls.get(key)) {
                                                            minPassSubscriptionTolls.set(key, value);
                                                        }
                                                    } else if (!processedFareIds.has(fare.id)) {
                                                        processedFareIds.add(fare.id);
                                                        minFare = Math.min(minFare, value);
                                                    }
                                                });
                                                
                                                if (minFare !== Infinity) {
                                                    countryTolls.set(countryCode, countryTolls.get(countryCode) + minFare);
                                                }
                                            }
                                        });
                                    }
                                });

                                for (const [key, value] of minPassSubscriptionTolls.entries()) {
                                    const countryCode = key.split('_')[0];
                                    if (countryTolls.has(countryCode)) {
                                        countryTolls.set(countryCode, countryTolls.get(countryCode) + value);
                                    }
                                }

                                totalToll = Array.from(countryTolls.values()).reduce((a, b) => a + b, 0);

                                let roadTollsHtml = '';
                                if (totalToll > 0) {
                                    const costPerKm = totalToll / (totalDistance / 1000);
                                    roadTollsHtml = `
                                        <div class="route-stat">
                                            <div class="stat-label">${translations.roadCharges}</div>
                                            <div class="stat-value">${totalToll.toFixed(2)} € (${costPerKm.toFixed(2)} €/km)
                                                <button class="toll-details-toggle">▼</button>
                                            </div>
                                            <div class="toll-details" style="display: none;">
                                                <div class="toll-details-content">
                                                    ${Array.from(countryTolls.entries())
                                                        .map(([country, value]) => `
                                                            <div class="country-toll">
                                                                ${country}: ${value.toFixed(2)} EUR
                                                            </div>
                                                        `).join('')}
                                                </div>
                                            </div>
                                        </div>`;
                                } else {
                                    roadTollsHtml = `
                                        <div class="route-stat">
                                            <div class="stat-label">${translations.roadCharges}</div>
                                            <div class="stat-value">${translations.noRoadCharges}</div>
                                        </div>`;
                                }

                                let ferriesHtml = '';
                                if (ferries.size > 0) {
                                    ferriesHtml = Array.from(ferries.entries())
                                        .map(([name, data]) => `
                                            <div class="ferry-item" style="margin-top: 2px;">
                                                ${data.icon} ${name}: 
                                                <input type="number" 
                                                    class="ferry-price" 
                                                    data-ferry-name="${name}"
                                                    value="${localStorage.getItem(`ferry_${name}`) || ''}"
                                                    min="0" 
                                                    max="5000" 
                                                    step="1" 
                                                    style="width: 60px; padding: 2px 5px; border: 1px solid #ddd; border-radius: 3px;"
                                                    placeholder="EUR">
                                            </div>
                                        `).join('');
                                }
                                
                                let manualTollsHtml = '';
                                if (route.sections) {
                                    const manualTollSystems = new Set();
                                    route.sections.forEach(section => {
                                        if (section.tolls) {
                                            section.tolls.forEach(toll => {
                                                // Sprawdź czy system jest na liście manualnych
                                                if (MANUAL_TOLL_SYSTEMS.hasOwnProperty(toll.tollSystem)) {
                                                    const criteria = MANUAL_TOLL_SYSTEMS[toll.tollSystem];
                                                    
                                                    // Jeśli mamy dodatkowe kryteria (np. dla ATMB)
                                                    if (criteria && criteria.checkLocation) {
                                                        // Sprawdź czy punkt poboru istnieje
                                                        const hasLocation = toll.tollCollectionLocations?.some(loc => 
                                                            loc.name === criteria.checkLocation
                                                        );
                                                        if (!hasLocation) return; // Jeśli nie ma wymaganej lokalizacji, pomiń
                                                    }
                                                    
                                                    manualTollSystems.add(toll.tollSystem);
                                                }
                                            });
                                        }
                                    });
                                    
                                // Znajdź ten fragment:
                                if (manualTollSystems.size > 0) {
                                    manualTollsHtml = Array.from(manualTollSystems).map(system => `
                                        <div class="ferry-item" style="margin-top: 2px;">
                                            🛤️ ${MANUAL_TOLL_SYSTEMS[system].displayName}: 
                                            <input type="number" 
                                                class="manual-toll-price" 
                                                data-toll-system="${system}"
                                                value="${localStorage.getItem(`toll_${system}`) || ''}"
                                                min="0" 
                                                max="5000" 
                                                step="1" 
                                                style="width: 60px; padding: 2px 5px; border: 1px solid #ddd; border-radius: 3px;"
                                                placeholder="EUR">
                                        </div>
                                    `).join('');
                                }
                                }

                                tollInfo = roadTollsHtml + ferriesHtml + manualTollsHtml;
                            } else {
                                tollInfo = `<br>${translations.noRoadCharges}`;
                            }

                            // Najpierw sprawdzamy czy trasa zawiera prom lub pociąg
                            const selectedVehicle = vehicles.find(v => v.id === localStorage.getItem('selectedVehicleId')) || vehicles[0];

                            const hasferryOrTrain = route.sections.some(section => 
                                section.transport?.mode === 'ferry' || section.transport?.mode === 'shuttletrain'
                            );

                            // Przygotuj sekcję kosztów
                            let costsSection = '';
                            if (selectedVehicle.simpleCosts) {
                                // Prosty system kosztów
                                const totalDistance = route.sections.reduce((sum, section) => {
                                    // Dodajemy tylko kilometry dla sekcji drogowych (truck)
                                    if (section.transport?.mode === 'truck') {
                                        return sum + section.summary.length;
                                    }
                                    return sum;
                                }, 0) / 1000; // konwersja na km

                                const simpleCosts = totalDistance * selectedVehicle.simpleCostValuePerKM;
                                
                                costsSection = `
                                    <div class="route-stat" style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(0, 0, 0, 0.1);">
                                        <div class="stat-label">${translations.totalCosts}</div>
                                        <div class="stat-value" style="font-weight: 600;">
                                            ${simpleCosts.toFixed(2)} € (${selectedVehicle.simpleCostValuePerKM.toFixed(2)} €/km)
                                        </div>
                                    </div>
                                `;
                            } else {
                                // Oryginalny system kosztów
                                const fuelCosts = calculateFuelCosts(route, selectedVehicle);
                                const fuelCostsHTML = generateFuelCostsHTML(fuelCosts, route, selectedVehicle);
                                const otherCosts = calculateOtherCosts(route, selectedVehicle);
                                const otherCostsHTML = generateOtherCostsHTML(otherCosts, selectedVehicle);
                                
                                // Obliczanie sumy wszystkich kosztów
                                const totalDistance = route.sections.reduce((sum, section) => 
                                    sum + section.summary.length, 0) / 1000; // w km
                                
                                // Pobierz wartości z localStorage dla promów i opłat manualnych
                                let ferryAndManualTotal = 0;
                                
                                // Oblicz sumę dla promów
                                if (route.sections) {
                                    route.sections.forEach(section => {
                                        if (section.transport?.mode === 'ferry' || section.transport?.mode.toLowerCase().includes('shuttletrain')) {
                                            const transportName = section.transport.name;
                                            const savedValue = localStorage.getItem(`ferry_${transportName}`);
                                            if (savedValue && !isNaN(savedValue)) {
                                                ferryAndManualTotal += parseFloat(savedValue);
                                            }
                                        }
                                    });
                                }
                                
                                // Oblicz sumę dla manualnych opłat
                                if (route.sections) {
                                    const manualTollSystems = new Set();
                                    route.sections.forEach(section => {
                                        if (section.tolls) {
                                            section.tolls.forEach(toll => {
                                                if (MANUAL_TOLL_SYSTEMS.hasOwnProperty(toll.tollSystem)) {
                                                    const savedValue = localStorage.getItem(`toll_${toll.tollSystem}`);
                                                    if (savedValue && !isNaN(savedValue)) {
                                                        ferryAndManualTotal += parseFloat(savedValue);
                                                    }
                                                }
                                            });
                                        }
                                    });
                                }

                                const totalToll = calculateTotalTolls(route);
                                const totalCosts = fuelCosts.totalCost + otherCosts.total + totalToll + ferryAndManualTotal;
                                const costPerKm = totalCosts / totalDistance;

                                costsSection = `
                                    <div class="route-stat">
                                        <div class="stat-label">${translations.fuelCosts}</div>
                                        ${fuelCostsHTML}
                                    </div>
                                    <div class="route-stat">
                                        <div class="stat-label">${translations.otherCosts}</div>
                                        ${otherCostsHTML}
                                    </div>
                                    <div class="route-stat" style="margin-top: 16px; padding-top: 16px; border-top: 1px solid rgba(0, 0, 0, 0.1);">
                                        <div class="stat-label">${translations.totalCosts}</div>
                                        <div class="stat-value total-costs-value" style="font-weight: 600;">
                                            ${totalCosts.toFixed(2)} € (${costPerKm.toFixed(2)} €/km)
                                        </div>
                                    </div>
                                `;
                            }

                            document.getElementById('route-info').innerHTML = `
                                <div class="route-info-label">${translations.routeInfo}</div>
                                <div class="route-stats-container">
                                    <div class="route-stat">
                                        <div class="stat-label">${translations.distance}${hasferryOrTrain ? ` (${translations.withoutFerryTrainKm})` : ''}</div>
                                        <div class="stat-value">${(totalDistance / 1000).toFixed(1)} km</div>
                                    </div>
                                    <div class="route-stat">
                                        <div class="stat-label">${translations.time}</div>
                                        <div class="stat-value">${Math.floor(totalTime / 3600)}h ${Math.round((totalTime % 3600) / 60)}min</div>
                                    </div>
                                </div>
                                ${tollInfo}
                                ${costsSection}
                            `;
                                    // Event listenery dla przycisków rozwijania i czasu (dodaj zaraz po document.getElementById('route-info').innerHTML = ...)
                                    function addEventListeners() {
                                        document.querySelectorAll('.toll-details-toggle').forEach(button => {
                                            button.addEventListener('click', function() {
                                                const details = this.closest('.stat-value').querySelector('.toll-details');
                                                const isExpanded = details.style.display !== 'none';
                                                details.style.display = isExpanded ? 'none' : 'block';
                                                this.textContent = isExpanded ? '▼' : '▲';
                                            });
                                        });

                                    // NA TEN KOD:
                                    document.querySelectorAll('.time-adjust').forEach(button => {
                                        button.addEventListener('click', function() {
                                            const workingTimeValue = this.closest('.working-time-value');
                                            const timeText = workingTimeValue.querySelector('span').textContent;
                                            const [days, hours] = timeText.match(/(\d+)/g).map(Number);
                                            let totalHours = days * 24 + hours;

                                            if (this.classList.contains('plus')) {
                                                totalHours += 1;
                                            } else if (this.classList.contains('minus')) {
                                                totalHours = Math.max(0, totalHours - 1);
                                            }

                                            const newDays = Math.floor(totalHours / 24);
                                            const newHours = totalHours % 24;

                                            // Aktualizacja wartości czasu
                                            workingTimeValue.querySelector('span').textContent = 
                                                `${newDays} ${translations.days} ${newHours} ${translations.hours}`;

                                            // Przeliczenie i aktualizacja wszystkich kosztów
                                            const selectedVehicle = vehicles.find(v => v.id === localStorage.getItem('selectedVehicleId')) || vehicles[0];
                                            const otherCosts = calculateOtherCosts(route, selectedVehicle, { days: newDays, hours: newHours });

                                            // Aktualizacja kosztów w sekcji pozostałych kosztów
                                            const otherCostsMain = document.querySelector('.other-costs-main span');
                                            if (otherCostsMain) {
                                                otherCostsMain.textContent = 
                                                    `${otherCosts.total.toFixed(2)} € (${otherCosts.costPerKm.toFixed(2)} €/km)`;
                                            }

                                            // Aktualizacja szczegółów kosztów
                                            const detailsContent = document.querySelector('.other-costs-main .toll-details-content');
                                            if (detailsContent) {
                                                detailsContent.innerHTML = `
                                                    <div class="country-toll">
                                                        ${translations.fixedCosts}: ${otherCosts.fixedCosts.toFixed(2)} €
                                                    </div>
                                                    <div class="country-toll">
                                                        Koszty zmienne (${selectedVehicle.advVariablePerKM.toFixed(2)} €/km): ${otherCosts.variableCosts.toFixed(2)} €
                                                    </div>
                                                `;
                                            }

                                            // Aktualizacja kosztów całkowitych
                                            updateTotalCosts(route, selectedVehicle);
                                        });
                                    });
                                    }

                                    // Wywołaj funkcję po wygenerowaniu HTML
                                    addEventListeners();
                                    setTimeout(() => {
                                        const selectedVehicle = vehicles.find(v => v.id === localStorage.getItem('selectedVehicleId')) || vehicles[0];
                                        updateTotalCosts(route, selectedVehicle);
                                    }, 0);
                            



                            // Dodaj event listenery dla szczegółów opłat
                            const tollDetailsToggle = document.querySelector('.toll-details-toggle');
                            if (tollDetailsToggle) {
                                tollDetailsToggle.addEventListener('click', function() {
                                    const details = document.querySelector('.toll-details');
                                    const isExpanded = details.style.display !== 'none';
                                    details.style.display = isExpanded ? 'none' : 'block';
                                    this.textContent = isExpanded ? '▼' : '▲';
                                });
                            }
                            // Na to:
                            document.querySelectorAll('.ferry-price, .manual-toll-price').forEach(input => {
                                input.addEventListener('input', (e) => {
                                    const value = e.target.value;
                                    if (e.target.classList.contains('ferry-price')) {
                                        const ferryName = e.target.dataset.ferryName;
                                        if (value === '' || (parseFloat(value) >= 0 && parseFloat(value) <= 5000)) {
                                            localStorage.setItem(`ferry_${ferryName}`, value);
                                        }
                                    } else {
                                        const tollSystem = e.target.dataset.tollSystem;
                                        if (value === '' || (parseFloat(value) >= 0 && parseFloat(value) <= 5000)) {
                                            localStorage.setItem(`toll_${tollSystem}`, value);
                                        }
                                    }
                                    updateTotalCosts(route, selectedVehicle);
                                });
                            });
                    }
                    // Dodaj InfoBubbles dla tras alternatywnych
                    if (routes.length > 1) {
                        const mainRoute = routes[currentRouteIndex];
                        routes.forEach((route, index) => {
                            if (index !== currentRouteIndex) {
                                addRouteBubble(mainRoute, route);
                            }
                        });
                    }
                });
                
                // Dostosuj widok mapy aby pokazać wszystkie trasy
                const allCoordinates = [origin, destination, ...viaPoints];
                let minLat = Math.min(...allCoordinates.map(coord => coord.lat));
                let maxLat = Math.max(...allCoordinates.map(coord => coord.lat));
                let minLng = Math.min(...allCoordinates.map(coord => coord.lng));
                let maxLng = Math.max(...allCoordinates.map(coord => coord.lng));

                const latMargin = (maxLat - minLat) * 0.2;
                const lngMargin = (maxLng - minLng) * 0.2;

                minLat -= latMargin;
                maxLat += latMargin;
                minLng -= lngMargin;
                maxLng += lngMargin;

                const fullBoundingBox = new H.geo.Rect(maxLat, minLng, minLat, maxLng);
                map.getViewModel().setLookAtData({
                    bounds: fullBoundingBox
                });
                }

            } catch (error) {
                    // Ignoruj cichutko błędy związane z anulowaniem żądania
                    if (error.name === 'AbortError') {
                        return;
                    }
                    
                    console.error('Route calculation error:', error);
                    document.getElementById('route-info').innerHTML = `
                        <div class="error-message">
                            ${error.message || translations.routeError}
                        </div>
                    `;
                }
        }
		// Initialize application
		const waypointsContainer = document.getElementById('waypoints-container');
		waypointsContainer.appendChild(createWaypointInput());

        function initializeUITranslations() {
            document.getElementById('settings-title').textContent = translations.routeSettings;
            document.getElementById('excluded-areas-text').textContent = translations.excludeCountriesAndAreas;
            document.getElementById('traffic-bans-button').textContent = translations.trafficBans;
            document.querySelector('#traffic-bans-sidebar h3').textContent = translations.truckRestrictions;

            // Dodajemy tłumaczenia dla elementów route-info
            document.querySelectorAll('[data-translation]').forEach(element => {
                const translationKey = element.dataset.translation;
                if (translations[translationKey]) {
                    element.textContent = translations[translationKey];
                }
            });
        }

		// Nasłuchuj zdarzeń input tylko dla dodawania nowych pól
        waypointsContainer.addEventListener('input', (e) => {
            if (e.target.classList.contains('waypoint')) {
                updateRemoveButtons();
                const waypoints = document.querySelectorAll('.waypoint');
                const lastWaypoint = waypoints[waypoints.length - 1];
                
                // Add new field only if last isn't empty and we're under the limit
                if (e.target === lastWaypoint && 
                    e.target.value.trim() !== '' && 
                    waypoints.length < 15) {
                    waypointsContainer.appendChild(createWaypointInput());
                }
            }
        });

        // Funkcja do inicjalizacji przycisków pojazdów
        function initializeVehicleButtons() {
            const container = document.getElementById('vehicle-selection');
            container.innerHTML = '';

            vehicles.forEach(vehicle => {
                const button = document.createElement('button');
                button.innerHTML = `
                    <div class="vehicle-name">${vehicle.name}</div>
                    <div class="vehicle-details">
                        <span>${vehicle.weight/1000}t</span>
                        <span>${vehicle.truckAxles}+${vehicle.trailerAxles} axles</span>
                        <span>EUR${vehicle.euroClass}</span>
                        <span>CO2-${vehicle.co2Class}</span>
                    </div>
                `;
                button.dataset.vehicleId = vehicle.id;
                button.classList.add('vehicle-button');
                button.addEventListener('click', () => selectVehicle(vehicle));
                container.appendChild(button);
            });

            const savedVehicleId = localStorage.getItem('selectedVehicleId') || vehicles[0].id;
            const vehicle = vehicles.find(v => v.id === savedVehicleId);
            if (vehicle) {
                selectVehicle(vehicle);
            }
        }
        // Funkcja do wyboru pojazdu
        function selectVehicle(vehicle) {
            // Aktualizuj wygląd przycisków
            document.querySelectorAll('#vehicle-selection button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.vehicleId === vehicle.id);
            });

            // Zapisz wybór w localStorage
            localStorage.setItem('selectedVehicleId', vehicle.id);

            // Przelicz trasę
            calculateRouteIfPossible();
        }

        // Funkcja do pobrania parametrów aktualnie wybranego pojazdu
        function getVehicleParameters() {
            const vehicleId = localStorage.getItem('selectedVehicleId') || vehicles[0].id;
            const vehicle = vehicles.find(v => v.id === vehicleId);
            
            return {
                weight: vehicle.weight,
                truckAxles: vehicle.truckAxles,
                trailerAxles: vehicle.trailerAxles,
                trailerCount: vehicle.trailerCount,
                euroClass: vehicle.euroClass,
                co2Class: vehicle.co2Class,
                fuelConsumption: vehicle.fuelConsumption,
                costPerKm: vehicle.costPerKm,
                height: vehicle.height,
                width: vehicle.width,
                length: vehicle.length
            };
        }



        ////////////////// FUNKCJE ODPOWIEDZIALNE ZA BUDOWE LINKU + ZMIANĘ PAGE TITLE
        // Function to update URL with current route and settings
        function updateURLParameters() {
            const waypoints = document.querySelectorAll('.waypoint');
            const params = new URLSearchParams();

            // Add only waypoints
            waypoints.forEach((waypoint, index) => {
                const value = waypoint.value.trim();
                if (value) {
                    if (isGPSCoordinates(value)) {
                        const coords = geocodedPoints.get(value);
                        if (coords) {
                            params.append(`wp${index}`, `${coords.lat},${coords.lng}`);
                        }
                    } else {
                        params.append(`wp${index}`, encodeURIComponent(value));
                    }
                }
            });

            // Update URL without reloading the page
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({ path: newURL }, '', newURL);
        }

        function updatePageTitle() {
            const waypoints = document.querySelectorAll('.waypoint');
            const nonEmptyWaypoints = Array.from(waypoints)
                .filter(wp => wp.value.trim() !== '');

            if (nonEmptyWaypoints.length >= 2) {
                const getLocationName = (value) => {
                    const words = value.trim().split(' ');
                    return words.slice(0, 2).join(' ');
                };

                const firstLocation = getLocationName(nonEmptyWaypoints[0].value);
                const lastLocation = getLocationName(nonEmptyWaypoints[nonEmptyWaypoints.length - 1].value);
                document.title = `TN: ${firstLocation} -> ${lastLocation}`;
            } else {
                document.title = 'Transport Nomad';
            }
        }

        // Function to load route from URL parameters
        async function loadRouteFromURL() {
            const params = new URLSearchParams(window.location.search);
            if (params.toString() === '') return;

            // Clear existing waypoints
            const waypointsContainer = document.getElementById('waypoints-container');
            waypointsContainer.innerHTML = '';

            // Load only waypoints
            const waypointParams = Array.from(params.entries())
                .filter(([key]) => key.startsWith('wp'))
                .sort((a, b) => parseInt(a[0].slice(2)) - parseInt(b[0].slice(2)));

            for (const [_, value] of waypointParams) {
                const container = createWaypointInput();
                const input = container.querySelector('.waypoint');
                
                if (value.includes(',')) {
                    const [lat, lng] = value.split(',').map(Number);
                    if (!isNaN(lat) && !isNaN(lng)) {
                        input.value = `${lat}, ${lng}`;
                    }
                } else {
                    input.value = decodeURIComponent(value);
                }
                waypointsContainer.appendChild(container);
            }

            // Add empty waypoint if needed
            const waypoints = document.querySelectorAll('.waypoint');
            if (waypoints.length < 12 && 
                waypoints[waypoints.length - 1]?.value.trim() !== '') {
                waypointsContainer.appendChild(createWaypointInput());
            }
            
            if (waypointParams.length > 0) {
                calculateRouteIfPossible();
            } else {
                updatePageTitle();
            }
        }

        // Modify calculateRouteIfPossible to update URL and title after successful route calculation
        const originalCalculateRouteIfPossible = calculateRouteIfPossible;
        calculateRouteIfPossible = async function() {
            await originalCalculateRouteIfPossible();
            updateURLParameters();
            updatePageTitle();
        };

        // Add URL update on browser navigation
        window.addEventListener('popstate', loadRouteFromURL);
        ////////////////// KONIEC FUNKCJE ODPOWIEDZIALNE ZA BUDOWE LINKU + ZMIANĘ PAGE TITLE

        // Funkcja do resetowania aplikacji
        function restartApp() {
            // Wyczyść kontener punktów trasy
            const waypointsContainer = document.getElementById('waypoints-container');
            waypointsContainer.innerHTML = '';

            // Ukryj wszystkie wskaźniki odległości
            document.querySelectorAll('.distance-indicator').forEach(indicator => indicator.remove());
            
            // Wyczyść mapę
            clearMap();
            
            // Wyczyść całkowicie informacje o trasie
            document.getElementById('route-info').innerHTML = `
                <div class="route-info-label">${translations.routeInfo}</div>
                <div class="route-stats-container">
                    <div class="route-stat">
                        <div class="stat-label">${translations.distance}</div>
                        <div class="stat-value">--</div>
                    </div>
                    <div class="route-stat">
                        <div class="stat-label">${translations.time}</div>
                        <div class="stat-value">--</div>
                    </div>
                </div>
                <div class="route-stat">
                    <div class="stat-label">${translations.roadCharges}</div>
                    <div class="stat-value">--</div>
                </div>
                <div class="route-stat">
                    <div class="stat-label">${translations.fuelCosts}</div>
                    <div class="stat-value">--</div>
                </div>
            `;
            
            // Zresetuj zapisane punkty geocoded
            geocodedPoints.clear();
            
            // Dodaj pojedyncze puste pole
            waypointsContainer.appendChild(createWaypointInput());
            
            // Ustaw focus na nowym polu
            const firstWaypoint = document.querySelector('.waypoint');
            if (firstWaypoint) {
                firstWaypoint.focus();
            }
            
            // Zresetuj tytuł strony
            document.title = 'Transport Nomad';
            
            // Wyczyść parametry URL
            window.history.pushState({}, '', window.location.pathname);
            
            // Zresetuj widok mapy do domyślnego
            map.setCenter({ lat: 50.0, lng: 15.0 });
            map.setZoom(5.5);
        }


        // Zmienne globalne dla zakazów ruchu
        let trafficBansData = null;
        let predefinedAreasData = null;
        let trafficBansPolygons = [];
        let selectedDayElement = null;
        let selectedDate = null;
        let polygonsCache = new Map(); // Buforowanie wielokątów
        let highlightedObjects = [];
        let areaLabels = [];
        let labelVisibility = true; // Flaga kontrolująca widoczność etykiet

        // Funkcja do ładowania danych
        async function loadAllData() {
            try {
                // Pobierz oba pliki równolegle
                const [bansResponse, areasResponse] = await Promise.all([
                    fetch('https://raw.githubusercontent.com/yato94/traffic_restriction/main/bans.json'),
                    fetch('https://raw.githubusercontent.com/yato94/traffic_restriction/main/areas.json')
                ]);
                
                if (!bansResponse.ok || !areasResponse.ok) {
                    throw new Error('Nie udało się pobrać danych');
                }
                
                trafficBansData = await bansResponse.json();
                predefinedAreasData = await areasResponse.json();
                
                return { trafficBansData, predefinedAreasData };
            } catch (error) {
                console.error('Błąd podczas pobierania danych:', error);
                return null;
            }
        }

        // Funkcja do wyświetlania panelu z zakazami
        function toggleTrafficBansPanel() {
            const panel = document.getElementById('traffic-bans-sidebar');
            const button = document.getElementById('traffic-bans-button');
            
            const isBansPanelVisible = panel.classList.contains('visible');
            
            if (!isBansPanelVisible) {
                panel.classList.add('visible');
                button.classList.add('active');
                
                // Załaduj dane o zakazach, jeśli jeszcze nie zostały załadowane
                if (!trafficBansData || !predefinedAreasData) {
                    loadAllData().then(() => {
                        populateDaysList();
                    });
                } else {
                    populateDaysList();
                }
            } else {
                panel.classList.remove('visible');
                button.classList.remove('active');
                
                // Wyczyść wszystkie polygony przy zamknięciu panelu
                clearTrafficBansFromMap();
                clearHighlights();
                clearAreaLabels(); // Dodaj tę linię, żeby czyścić etykiety
                
                // Zresetuj wybór
                if (selectedDayElement) {
                    selectedDayElement.classList.remove('active');
                    selectedDayElement = null;
                }
                selectedDate = null;
            }
        }

        // Zamknięcie panelu zakazów
        // Zamknięcie panelu zakazów
        function closeTrafficBansPanel() {
            const panel = document.getElementById('traffic-bans-sidebar');
            const button = document.getElementById('traffic-bans-button');
            
            panel.classList.remove('visible');
            button.classList.remove('active');
            
            // Wyczyść wszystkie polygony przy zamknięciu panelu
            clearTrafficBansFromMap();
            clearHighlights();
            clearAreaLabels();
            
            // Zresetuj wybór
            if (selectedDayElement) {
                selectedDayElement.classList.remove('active');
                selectedDayElement = null;
            }
            selectedDate = null;
        }

        // Formatowanie daty w postaci "YYYY-MM-DD"
        function formatDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Pobranie nazwy dnia tygodnia po polsku
        function getDayOfWeek(date) {
            const days = ['Niedziela', 'Poniedziałek', 'Wtorek', 'Środa', 'Czwartek', 'Piątek', 'Sobota'];
            return days[date.getDay()];
        }

        // Wypełnij listę dni
        function populateDaysList() {
            if (!trafficBansData || !trafficBansData.dates) return;
            
            const daysList = document.getElementById('bans-days-list');
            daysList.innerHTML = '';
            
            // Utwórz dzisiejszą datę
            const today = new Date();
            const todayFormatted = formatDate(today);
            
            // Posortuj daty
            const sortedDates = [...trafficBansData.dates].sort((a, b) => {
                return new Date(a.date) - new Date(b.date);
            });
            
            // Utwórz kartę dla każdej daty
            sortedDates.forEach((dateData, index) => {
                const date = new Date(dateData.date);
                const isToday = dateData.date === todayFormatted;
                
                const dayCard = document.createElement('div');
                dayCard.className = 'ban-day-card';
                dayCard.dataset.date = dateData.date;
                
                // Utwórz nagłówek karty dnia
                const dayHeader = document.createElement('div');
                dayHeader.className = 'ban-day-header';
                
                // Dodaj informacje o dniu
                dayHeader.innerHTML = `
                    <div>
                        <div class="ban-day-date">
                            ${dateData.date}
                            ${isToday ? '<span class="today-badge">Today</span>' : ''}
                        </div>
                        <div class="ban-day-name">${dateData.dayOfWeek || getDayOfWeek(date)}</div>
                    </div>
                `;
                
                // Utwórz zawartość karty dnia
                const dayContent = document.createElement('div');
                dayContent.className = 'ban-day-content';
                
                // Dodaj zawartość z krajami
                if (dateData.countries && dateData.countries.length > 0) {
                    // Przekaż dodatkowy parametr autoExpandDetails
                    const autoExpandDetails = isToday || (selectedDate === dateData.date);
                    dateData.countries.forEach(country => {
                        const countryElement = createCountryElement(country, autoExpandDetails);
                        dayContent.appendChild(countryElement);
                    });
                } else {
                    dayContent.innerHTML = '<div style="text-align: center; padding: 10px; color: #666;">Brak zakazów na ten dzień</div>';
                }
                
                // Obsługa kliknięcia na nagłówek karty dnia
                dayHeader.addEventListener('click', function() {
                    // Usuń aktywną klasę z poprzedniego elementu
                    if (selectedDayElement) {
                        selectedDayElement.classList.remove('active');
                    }
                    
                    // Dodaj aktywną klasę do klikniętego elementu
                    dayHeader.classList.add('active');
                    selectedDayElement = dayHeader;
                    
                    // Zapamętaj wybraną datę
                    selectedDate = dateData.date;
                    
                    // Wyświetl zakazy na mapie
                    clearTrafficBansFromMap(); // Wyczyść poprzednie
                    displayBansOnMap(dateData);
                    
                    // Najpierw zwiń wszystkie szczegóły krajów dla wszystkich dni
                    document.querySelectorAll('.ban-country-header').forEach(header => {
                        const container = header.closest('.ban-country-item');
                        const areasContainer = container.querySelector('.ban-areas-container');
                        const warningText = container.querySelector('.ban-warning-text');
                        
                        // Ukryj szczegóły
                        if (areasContainer) {
                            areasContainer.style.display = 'none';
                        }
                        if (warningText) {
                            warningText.style.display = 'none';
                        }
                        
                        // Przywróć domyślny wygląd nagłówka
                        header.style.backgroundColor = '';
                    });
                    
                    // Teraz rozwiń szczegóły krajów tylko dla wybranego dnia
                    const allCountryHeaders = dayContent.querySelectorAll('.ban-country-header');
                    allCountryHeaders.forEach(header => {
                        const container = header.closest('.ban-country-item');
                        const areasContainer = container.querySelector('.ban-areas-container');
                        const warningText = container.querySelector('.ban-warning-text');
                        
                        // Pokaż szczegóły
                        if (areasContainer) {
                            areasContainer.style.display = 'block';
                        }
                        if (warningText) {
                            warningText.style.display = 'block';
                        }
                        header.style.backgroundColor = '#f0f7ff';
                    });
                });
                
                // Złóż kartę dnia
                dayCard.appendChild(dayHeader);
                dayCard.appendChild(dayContent);
                
                // Dodaj kartę do listy
                daysList.appendChild(dayCard);
                
                // Automatycznie wybierz dzisiejszą datę przy ładowaniu
                if (isToday) {
                    setTimeout(() => {
                        dayHeader.click();
                        dayCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }, 300);
                }
            });
            
            // Przewiń do dzisiejszej daty
            const todayCard = document.querySelector(`.ban-day-card[data-date="${todayFormatted}"]`);
            if (todayCard) {
                setTimeout(() => {
                    todayCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 100);
            }
        }

        // Zmodyfikowana funkcja createCountryElement
        // Utwórz element dla kraju
        function createCountryElement(country, autoExpandDetails = false) {
            const countryContainer = document.createElement('div');
            
            country.restrictions.forEach((restriction, index) => {
                const countryElement = document.createElement('div');
                countryElement.className = 'ban-country-item';
                
                // Tworzenie nagłówka kraju
                const headerElement = document.createElement('div');
                headerElement.className = 'ban-country-header';
                headerElement.dataset.country = country.code;
                
                // Flaga kraju
                const flagElement = document.createElement('div');
                flagElement.className = 'ban-country-flag';
                flagElement.style.backgroundImage = `url('https://flagcdn.com/w20/${country.code.toLowerCase()}.png')`;
                
                // Nazwa kraju
                const nameElement = document.createElement('div');
                nameElement.className = 'ban-country-name';
                nameElement.textContent = country.name;
                
                // Czas zakazu
                const timeElement = document.createElement('div');
                timeElement.className = 'ban-country-time';
                timeElement.textContent = `${restriction.timeFrom} - ${restriction.timeTo}`;
                
                // Ikona ostrzeżenia (jeśli potrzebna)
                const warningElement = document.createElement('div');
                warningElement.className = 'ban-warning-icon';
                if (restriction.warning) {
                    warningElement.innerHTML = '⚠️';
                }
                
                // Dodaj elementy do nagłówka
                headerElement.appendChild(flagElement);
                headerElement.appendChild(nameElement);
                headerElement.appendChild(timeElement);
                headerElement.appendChild(warningElement);
                
                // Tekst ostrzeżenia (jeśli istnieje)
                let warningTextElement = null;
                if (restriction.warning) {
                    warningTextElement = document.createElement('div');
                    warningTextElement.className = 'ban-warning-text';
                    
                    // Domyślny tekst ostrzeżenia, jeśli nie podano własnego
                    const warningText = restriction.warningText || 
                        "Uwaga! W tym czasie obowiązują szczególne ograniczenia. Mogą występować kontrole lub dodatkowe wymogi.";
                    
                    warningTextElement.textContent = warningText;
                    // Ukryte domyślnie, chyba że autoExpandDetails jest true
                    warningTextElement.style.display = autoExpandDetails ? 'block' : 'none';
                }
                
                // Tworzenie kontenera dla obszarów
                const areasContainer = document.createElement('div');
                areasContainer.className = 'ban-areas-container';
                // Ukryte domyślnie, chyba że autoExpandDetails jest true
                areasContainer.style.display = autoExpandDetails ? 'block' : 'none';
                
                // Filtrujemy obszary, wykluczając typ 'country'
                const filteredAreas = restriction.areas.filter(area => area.type !== 'country');
                
                // Sprawdzamy, czy mamy jakiekolwiek obszary do pokazania po filtrowaniu
                const hasAreasToShow = filteredAreas.length > 0;
                
                // Dodaj obszary, tylko jeśli nie są typu 'country'
                filteredAreas.forEach(area => {
                    const areaData = getAreaData(area.areaId, area.type);
                    if (!areaData) return;
                    
                    const areaElement = document.createElement('div');
                    areaElement.className = 'ban-area-item';
                    areaElement.dataset.areaId = area.areaId;
                    areaElement.dataset.areaType = area.type;
                    areaElement.dataset.country = country.code;
                    
                    let typeText = '';
                    let typeIcon = '';
                    
                    switch (area.type) {
                        case 'region':
                            typeText = 'Region';
                            typeIcon = '🏞️';
                            break;
                        case 'highway':
                            typeText = 'Highway';
                            typeIcon = '🛣️';
                            break;
                    }
                    
                    const iconElement = document.createElement('span');
                    iconElement.className = 'ban-area-icon';
                    iconElement.textContent = typeIcon;
                    
                    const nameElement = document.createElement('span');
                    nameElement.className = 'ban-area-name';
                    nameElement.textContent = areaData.name;
                    
                    const typeElement = document.createElement('span');
                    typeElement.className = 'ban-area-type';
                    typeElement.textContent = `(${typeText})`;
                    
                    areaElement.appendChild(iconElement);
                    areaElement.appendChild(nameElement);
                    areaElement.appendChild(typeElement);
                    
                    // Dodaj obsługę kliknięcia na obszar
                    areaElement.addEventListener('click', function(e) {
                        e.stopPropagation(); // Zapobiegnij propagacji do nagłówka
                        
                        // Dodaj lub usuń klasę podświetlenia
                        const isSelected = this.classList.contains('selected');
                        
                        // Usuń podświetlenie ze wszystkich elementów
                        document.querySelectorAll('.ban-area-item').forEach(item => {
                            item.classList.remove('selected');
                        });
                        
                        if (!isSelected) {
                            // Podświetl ten element
                            this.classList.add('selected');
                            
                            // Podświetl odpowiedni obszar na mapie
                            highlightMapObjects({
                                id: this.dataset.areaId,
                                type: this.dataset.areaType
                            });
                        } else {
                            // Usuń podświetlenie z mapy
                            clearHighlights();
                        }
                    });
                    
                    areasContainer.appendChild(areaElement);
                });
                
                
                // Ustawienie tła nagłówka, jeśli szczegóły są rozwinięte
                if (autoExpandDetails) {
                    headerElement.style.backgroundColor = '#f0f7ff';
                }
                
                // Obsługa kliknięcia na nagłówek kraju
                headerElement.addEventListener('click', function(e) {
                    const isVisible = areasContainer.style.display !== 'none';
                    
                    if (isVisible) {
                        // Chowamy szczegóły
                        areasContainer.style.display = 'none';
                        if (warningTextElement) {
                            warningTextElement.style.display = 'none';
                        }
                        headerElement.style.backgroundColor = '';
                        
                        // Usuń podświetlenie z mapy
                        clearHighlights();
                    } else {
                        // Pokazujemy szczegóły
                        areasContainer.style.display = 'block';
                        if (warningTextElement) {
                            warningTextElement.style.display = 'block';
                        }
                        headerElement.style.backgroundColor = '#f0f7ff';
                        
                        // Podświetl wszystkie obszary z tego kraju na mapie
                        highlightMapObjects({
                            country: this.dataset.country
                        });
                    }
                    
                    // Usuń zaznaczenie ze wszystkich obszarów
                    document.querySelectorAll('.ban-area-item').forEach(item => {
                        item.classList.remove('selected');
                    });
                });
                
                // Złóż elementy
                countryElement.appendChild(headerElement);
                
                // Dodaj tekst ostrzeżenia bezpośrednio po nagłówku (jeśli istnieje)
                if (warningTextElement) {
                    countryElement.appendChild(warningTextElement);
                }
                
                countryElement.appendChild(areasContainer);
                
                countryContainer.appendChild(countryElement);
            });
            
            return countryContainer;
        }

        // Wyświetl zakazy dla wybranego dnia na mapie
        // Wyświetl zakazy dla wybranego dnia na mapie
        function displayBansOnMap(dateData) {
            // Najpierw wyczyść istniejące polygony
            clearTrafficBansFromMap();
            clearHighlights();
            clearAreaLabels();
            
            if (!dateData || !dateData.countries) return;
            
            // Dodaj nowe polygony
            dateData.countries.forEach(country => {
                country.restrictions.forEach(restriction => {
                    restriction.areas.forEach(area => {
                        const areaData = getAreaData(area.areaId, area.type);
                        if (areaData) {
                            addPolygonToMap(areaData.polygons, area.areaId, area.type, restriction.warning, country.code);
                        }
                    });
                });
            });
            
            // Utwórz etykiety dla wszystkich obszarów
            createAreaLabels(dateData);
        }

        // Pobierz dane obszaru na podstawie ID i typu
        function getAreaData(areaId, type) {
            if (!predefinedAreasData) return null;
            
            switch (type) {
                case 'country':
                    return predefinedAreasData.predefinedAreas.countries[areaId];
                case 'region':
                    return predefinedAreasData.predefinedAreas.regions[areaId];
                case 'highway':
                    return predefinedAreasData.predefinedAreas.highways[areaId];
                default:
                    return null;
            }
        }

        // Zmodyfikowana funkcja dodawania obiektów do mapy
        // Zmodyfikowana funkcja dodawania obiektów do mapy
        function addPolygonToMap(polygonCoords, areaId, areaType, isWarning, countryCode) {
            // Kolory dla zakazów
            const colors = {
                normal: {
                    fill: 'rgba(255, 0, 0, 0.3)',
                    stroke: 'rgba(255, 0, 0, 0.7)'
                },
                warning: {
                    fill: 'rgba(255, 165, 0, 0.3)',
                    stroke: 'rgba(255, 165, 0, 0.7)'
                }
            };
            
            // Klucz bufora
            const cacheKey = `${areaId}_${areaType}_${isWarning ? 'warning' : 'normal'}`;
            
            // Sprawdź, czy obiekt jest już w buforze
            if (polygonsCache.has(cacheKey)) {
                const cachedObject = polygonsCache.get(cacheKey);
                
                // Utwórz kopię obiektu z bufora
                let mapObject;
                
                if (areaType === 'highway') {
                    // Dla autostrad tworzymy polyline
                    mapObject = new H.map.Polyline(
                        cachedObject.getGeometry(),
                        {
                            style: {
                                strokeColor: isWarning ? colors.warning.stroke : colors.normal.stroke,
                                lineWidth: 5,
                                lineCap: 'round',
                                lineJoin: 'round'
                            }
                        }
                    );
                } else {
                    // Dla krajów i regionów tworzymy polygon
                    mapObject = new H.map.Polygon(
                        cachedObject.getGeometry(),
                        {
                            style: {
                                fillColor: isWarning ? colors.warning.fill : colors.normal.fill,
                                strokeColor: 'rgba(0, 0, 0, 0.5)',
                                lineWidth: 1
                            }
                        }
                    );
                }
                
                // Skopiuj dane i dodaj informację o kraju
                const data = cachedObject.getData();
                data.country = countryCode; // Dodaj kod kraju
                mapObject.setData(data);
                
                trafficBansPolygons.push(mapObject);
                map.addObject(mapObject);
                return;
            }
            
            // Obsługa dwóch formatów danych
            const processGeometry = (coords) => {
                if (Array.isArray(coords[0]) && typeof coords[0][0] === 'number') {
                    // Pojedynczy zestaw współrzędnych
                    const lineString = new H.geo.LineString();
                    coords.forEach(coord => {
                        lineString.pushLatLngAlt(coord[0], coord[1], 0);
                    });
                    return [lineString];
                } else {
                    // Wiele zestawów współrzędnych
                    return coords.map(coordSet => {
                        const lineString = new H.geo.LineString();
                        coordSet.forEach(coord => {
                            lineString.pushLatLngAlt(coord[0], coord[1], 0);
                        });
                        return lineString;
                    });
                }
            };
            
            const lineStrings = processGeometry(polygonCoords);
            
            lineStrings.forEach(lineString => {
                let mapObject;
                
                if (areaType === 'highway') {
                    // Dla autostrad tworzymy polyline
                    mapObject = new H.map.Polyline(lineString, {
                        style: {
                            strokeColor: isWarning ? colors.warning.stroke : colors.normal.stroke,
                            lineWidth: 5,
                            lineCap: 'round',
                            lineJoin: 'round'
                        }
                    });
                } else {
                    // Dla krajów i regionów tworzymy polygon
                    mapObject = new H.map.Polygon(lineString, {
                        style: {
                            fillColor: isWarning ? colors.warning.fill : colors.normal.fill,
                            strokeColor: 'rgba(0, 0, 0, 0.5)',
                            lineWidth: 1
                        }
                    });
                }
                
                // Dodaj dane do obiektu
                const areaData = getAreaData(areaId, areaType);
                if (areaData) {
                    mapObject.setData({
                        id: areaId,
                        type: areaType,
                        name: areaData.name,
                        warning: isWarning,
                        country: countryCode // Dodaj kod kraju
                    });
                }
                
                // Zapisz w buforze
                polygonsCache.set(cacheKey, mapObject);
                
                trafficBansPolygons.push(mapObject);
                map.addObject(mapObject);
            });
        }

        // Funkcja do podświetlania obiektów na mapie
        function highlightMapObjects(criteria) {
            // Usuń poprzednie podświetlenia
            clearHighlights();
            
            // Znajdź obiekty do podświetlenia
            const objectsToHighlight = trafficBansPolygons.filter(obj => {
                const data = obj.getData();
                if (!data) return false;
                
                if (criteria.country && data.country !== criteria.country) return false;
                if (criteria.id && data.id !== criteria.id) return false;
                if (criteria.type && data.type !== criteria.type) return false;
                
                return true;
            });
            
            // Podświetl znalezione obiekty
            objectsToHighlight.forEach(obj => {
                const data = obj.getData();
                const isHighway = data.type === 'highway';
                
                // Klonujemy obiekt z nowymi stylami
                let highlightedObj;
                
                if (isHighway) {
                    // Dla autostrady tworzymy pogrubioną linię
                    highlightedObj = new H.map.Polyline(
                        obj.getGeometry(),
                        {
                            style: {
                                strokeColor: data.warning ? '#FF8C00' : '#FF0000', // Pomarańczowy dla ostrzeżeń, czerwony dla zwykłych
                                lineWidth: 8, // Grubsza linia
                                lineCap: 'round',
                                lineJoin: 'round',
                                lineJoin: 'round',
                                strokeLinecap: 'round',
                                strokeLinejoin: 'round'
                            },
                            zIndex: 100 // Wyższy zIndex, aby był ponad innymi obiektami
                        }
                    );
                } else {
                    // Dla wielokątów tworzymy obiekt z grubszym obrysem
                    highlightedObj = new H.map.Polygon(
                        obj.getGeometry(),
                        {
                            style: {
                                fillColor: data.warning ? 'rgba(255, 165, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)', // Bardziej nieprzezroczyste
                                strokeColor: data.warning ? '#FF8C00' : '#FF0000',
                                lineWidth: 3, // Grubsza linia
                                lineJoin: 'round',
                                strokeLinecap: 'round',
                                strokeLinejoin: 'round'
                            },
                            zIndex: 100 // Wyższy zIndex
                        }
                    );
                }
                
                // Kopiujemy dane
                highlightedObj.setData(data);
                
                // Dodajemy do mapy i zapisujemy do tablicy podświetleń
                map.addObject(highlightedObj);
                highlightedObjects.push(highlightedObj);
            });
            
            // Jeśli podświetlamy tylko jeden obiekt, przybliż do niego mapę
            if (objectsToHighlight.length === 1 && (criteria.id || criteria.type === 'highway')) {
                const obj = objectsToHighlight[0];
                const bounds = obj.getBoundingBox();
                map.getViewModel().setLookAtData({
                    bounds: bounds,
                    padding: 100 // Dodatkowy margines wokół
                });
            }
        }

        // Funkcja usuwająca podświetlenia
        function clearHighlights() {
            highlightedObjects.forEach(obj => {
                if (map.getObjects().includes(obj)) {
                    map.removeObject(obj);
                }
            });
            highlightedObjects = [];
        }

        // Funkcja do tworzenia etykiet dla obszarów
        function createAreaLabels(dateData) {
            // Usuń istniejące etykiety
            clearAreaLabels();
            
            if (!dateData || !dateData.countries) return;
            
            // Mapa do przechowywania etykiet wg ID obszaru
            const labelsMap = new Map();
            
            // Zbierz informacje o wszystkich obszarach i ich ograniczeniach
            dateData.countries.forEach(country => {
                country.restrictions.forEach(restriction => {
                    restriction.areas.forEach(area => {
                        const areaData = getAreaData(area.areaId, area.type);
                        if (!areaData) return;
                        
                        // Klucz dla tego obszaru
                        const areaKey = `${area.type}_${area.areaId}`;
                        
                        // Jeśli etykieta dla tego obszaru już istnieje, zaktualizuj czasy
                        if (labelsMap.has(areaKey)) {
                            const labelInfo = labelsMap.get(areaKey);
                            if (!labelInfo.times.includes(`${restriction.timeFrom}-${restriction.timeTo}`)) {
                                labelInfo.times.push(`${restriction.timeFrom}-${restriction.timeTo}`);
                            }
                            if (restriction.warning) {
                                labelInfo.hasWarning = true;
                            }
                        } else {
                            // Utwórz nową informację o etykiecie
                            labelsMap.set(areaKey, {
                                areaId: area.areaId,
                                type: area.type,
                                name: areaData.name,
                                country: country.code,
                                countryName: country.name,
                                times: [`${restriction.timeFrom}-${restriction.timeTo}`],
                                polygons: areaData.polygons,
                                hasWarning: restriction.warning
                            });
                        }
                    });
                });
            });
            
            // Utwórz etykiety dla wszystkich obszarów
            labelsMap.forEach(labelInfo => {
                createSingleAreaLabel(labelInfo);
            });
        }

        // Funkcja tworząca pojedynczą etykietę
        function createSingleAreaLabel(labelInfo) {
            try {
                // Dla autostrad i wielokątów używamy różnych metod obliczania środka
                let centerPoint;
                
                if (labelInfo.type === 'highway') {
                    // Dla autostrad bierzemy punkt w środku długości linii
                    const coords = labelInfo.polygons[0]; // Zakładamy, że jest co najmniej jeden zestaw współrzędnych
                    const midPointIndex = Math.floor(coords.length / 2);
                    centerPoint = {
                        lat: coords[midPointIndex][0],
                        lng: coords[midPointIndex][1]
                    };
                } else {
                    // Dla wielokątów obliczamy środek jako średnią wszystkich punktów
                    let sumLat = 0, sumLng = 0, pointCount = 0;
                    
                    labelInfo.polygons.forEach(polygon => {
                        polygon.forEach(point => {
                            sumLat += point[0];
                            sumLng += point[1];
                            pointCount++;
                        });
                    });
                    
                    centerPoint = {
                        lat: sumLat / pointCount,
                        lng: sumLng / pointCount
                    };
                }
                
                // Unikalne czasy jako string
                const timesText = [...new Set(labelInfo.times)].join(', ');
                
                // Tworzenie zawartości HTML dla etykiety
                const labelContent = `
                    <div class="map-label" style="
                        background-color: ${labelInfo.hasWarning ? 'rgba(255, 140, 0, 0.85)' : 'rgba(255, 0, 0, 0.85)'};
                        color: white;
                        padding: 3px 6px;
                        border-radius: 3px;
                        font-size: 11px;
                        font-weight: bold;
                        box-shadow: 0 1px 3px rgba(0,0,0,0.3);
                        pointer-events: none;
                        white-space: nowrap;
                        text-align: center;
                    ">
                        <div>${labelInfo.name}</div>
                        <div style="font-size: 9px; font-weight: normal;">${selectedDate}</div>
                        <div style="font-size: 9px; font-weight: normal;">${timesText}</div>
                    </div>
                `;
                                
                // Tworzenie markera z etykietą
                const labelMarker = new H.map.DomMarker(centerPoint, {
                    icon: new H.map.DomIcon(labelContent),
                    zIndex: 1000 // Wysoki zIndex, aby etykieta była zawsze na wierzchu
                });
                
                // Ustawianie danych dla etykiety
                labelMarker.setData({
                    id: labelInfo.areaId,
                    type: labelInfo.type,
                    country: labelInfo.country
                });
                
                // Dodaj etykietę do mapy i zapisz do tablicy
                map.addObject(labelMarker);
                areaLabels.push(labelMarker);
            } catch (error) {
                console.error('Error creating label:', error, labelInfo);
            }
        }

        // Funkcja usuwająca wszystkie etykiety
        function clearAreaLabels() {
            areaLabels.forEach(label => {
                if (map.getObjects().includes(label)) {
                    map.removeObject(label);
                }
            });
            areaLabels = [];
        }

        // Funkcja przełączająca widoczność etykiet
        function toggleLabelsVisibility() {
            labelVisibility = !labelVisibility;
            
            areaLabels.forEach(label => {
                label.setVisibility(labelVisibility);
            });
        }
        // Usuwanie wszystkich wielokątów z mapy
        function clearTrafficBansFromMap() {
            trafficBansPolygons.forEach(polygon => {
                if (map.getObjects().includes(polygon)) {
                    map.removeObject(polygon);
                }
            });
            trafficBansPolygons = [];
        }

        // Inicjalizacja funkcji dla zakazów ruchu
        function initializeTrafficBans() {
            // Dodanie obsługi kliknięcia na przycisk zakazów
            const trafficBansButton = document.getElementById('traffic-bans-button');
            trafficBansButton.addEventListener('click', toggleTrafficBansPanel);
            
            // Dodanie obsługi przycisku zamknięcia
            const closeButton = document.getElementById('close-traffic-bans-button');
            closeButton.addEventListener('click', closeTrafficBansPanel);

            // Dodanie obsługi przycisku przełączania etykiet
            const toggleLabelsButton = document.getElementById('toggle-labels-button');
            toggleLabelsButton.addEventListener('click', function() {
                toggleLabelsVisibility();
                this.textContent = labelVisibility ? 'Hide labels' : 'Show labels';
            });
        }


        function initializeApplication() {
            // Inicjalizacja przycisków pojazdów
            initializeVehicleButtons();

            // Initialize excluded areas dropdowns
            initializeExcludedList();

            // Inicjalizacja funkcji dla zakazów ruchu
            initializeTrafficBans();

            // Pozostała część funkcji bez zmian...
            const firstWaypoint = document.querySelector('.waypoint');
            if (firstWaypoint) {
                firstWaypoint.focus();
            }
            
            initializeUITranslations();
            loadRouteFromURL();
            updatePageTitle();
            
            const restartButton = document.getElementById('restart-button');
            if (restartButton) {
                restartButton.addEventListener('click', restartApp);
            }
        }

        // Pojedynczy listener DOMContentLoaded
        document.addEventListener('DOMContentLoaded', initializeApplication);

        // Dodaj obsługę skrótu klawiszowego Ctrl+I
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key.toLowerCase() === 'i') {
                e.preventDefault(); // Zapobiegamy domyślnej akcji przeglądarki
                restartApp();
            }
        });
    </script>
</body>
</html
