<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transpot Nomad</title>
    <script src="https://js.api.here.com/v3/3.1/mapsjs-core.js"></script>
    <script src="https://js.api.here.com/v3/3.1/mapsjs-service.js"></script>
    <script src="https://js.api.here.com/v3/3.1/mapsjs-ui.js"></script>
    <script src="https://js.api.here.com/v3/3.1/mapsjs-mapevents.js"></script>
    <link rel="stylesheet" href="https://js.api.here.com/v3/3.1/mapsjs-ui.css"/>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            display: flex;
            height: 100vh;
        }

        #sidebar {
            position: relative;
            width: 300px;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.95);
            border-right: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 16px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.05);
        }


        #map-container {
            flex: 1;
            height: 100%;
        }

        .waypoint-number {
            position: absolute;
            left: -8px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            background: white;
            color: #0066CC;
            border: 1.5px solid #0066CC;
            border-radius: 4px;  /* delikatnie zaokrąglone rogi */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            cursor: grab;
            user-select: none;
            z-index: 10;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .waypoint-number:hover {
            background: #f0f5ff;
            box-shadow: 0 2px 8px rgba(0, 102, 204, 0.15);
        }

        .waypoint-number:active {
            cursor: grabbing;
            background: #e5efff;
            transform: translateY(-50%) scale(0.95);
        }

        /* Dodajemy specjalny styl dla stanu przeciągania */
        .waypoint-container.dragging .waypoint-number {
            background: #0066CC;
            color: white;
            box-shadow: 0 4px 12px rgba(0, 102, 204, 0.25);
        }

        .waypoint-box:hover {
            border-color: #0066CC;
            box-shadow: 0 2px 8px rgba(0, 102, 204, 0.15);
        }

        .waypoint-number:active {
            cursor: grabbing;
        }

        .waypoint-container {
            position: relative;
            padding-left: 18px;
            margin-bottom: 10px;
        }

        .waypoint-container.dragging {
            opacity: 1;
            position: fixed;
            z-index: 1000;
            width: calc(100% - 40px); /* Dostosuj szerokość do kontenera */
            pointer-events: none;
            transform: translateY(var(--y));
        }

        .waypoint-container.shift-up {
            transform: translateY(-20px);
        }

        .waypoint-container.shift-down {
            transform: translateY(20px);
        }


        .waypoint-box {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            background: white;
            position: relative;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }


        .waypoint {
            width: 100%;
            border: none;
            font-size: 14px;
            background: transparent;
            margin-bottom: 2px;
            color: #323130;
        }

        .waypoint:focus {
            outline: none;
        }

        .coordinates-display {
            font-size: 11px;
            color: #605E5C;
            display: block;
            width: 100%;
        }

        .suggestions-container {
            position: absolute;
            top: 100%;
            left: 30px;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .suggestion-item {
            padding: 8px 12px;
            cursor: pointer;
        }

        .suggestion-item:hover {
            background-color: #f0f0f0;
        }

        .suggestion-item.selected {
            background-color: #e6e6e6;
        }

        #route-info {
            margin-top: 16px;
            padding: 16px;
            background-color: white;
            border-radius: 4px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .remove-waypoint {
            position: absolute;
            right: -18px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #ff4444;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            padding: 2px;
            z-index: 1;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .remove-waypoint:hover {
            color: #cc0000;
        }

        .error-message {
            color: #ff4444;
            font-size: 12px;
            margin-top: 4px;
        }

        .route-settings {
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            background-color: rgba(249, 249, 249, 0.9);
            padding: 24px 20px;
            margin: 0 -20px;
        }

        .route-settings .row {
            margin-bottom: 12px;  /* zmniejszony margines między rzędami */
        }

        .route-settings p {
            margin-bottom: 4px;  /* mniejszy odstęp między nagłówkiem a przyciskami */
            font-size: 13px;
            color: #323130;
        }

        .route-settings .button-group {
            display: flex;
            gap: 4px;  /* mniejszy odstęp między przyciskami */
            flex-wrap: wrap;
        }

        .route-settings button {
        padding: 6px 4px; /* zmniejszamy padding poziomy */
        border: 1px solid rgba(0, 0, 0, 0.1);
        background-color: white;
        color: #323130;
        border-radius: 4px;
        cursor: pointer;
        font-size: 12px; /* domyślny rozmiar czcionki */
        transition: all 0.2s ease;
        flex: 1 1 0;
        text-align: center;
        font-weight: 500;
        white-space: nowrap;
        overflow: visible; /* pozwalamy na widoczność całego tekstu */
        }
        .route-settings button:hover {
            background-color: #f3f2f1;
            border-color: rgba(0, 0, 0, 0.15);
        }


        .route-settings button.active {
            background-color: #0066CC;
            color: white;
            border-color: transparent;
            box-shadow: 0 2px 4px rgba(0, 102, 204, 0.25);
        }

        #excluded-areas button.active {
            background-color: #dc3545;
            border-color: #dc3545;
            color: white;
        }

        .select-group {
            display: flex;
            gap: 8px;  /* mniejszy odstęp między selectami */
        }

        .select-container {
            flex: 1;
        }

        .route-settings select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            background-color: white;
            font-size: 13px;
            color: #323130;
            cursor: pointer;
            transition: all 0.2s ease;
            padding: 6px 8px;  /* mniejszy padding */
            font-size: 12px;  /* mniejsza czcionka */
        }

        /* Specjalne style dla przycisków wykluczonych obszarów */
        #excluded-areas.button-group {
            gap: 8px;  /* większy odstęp dla tych konkretnych przycisków */
        }

        #excluded-areas button {
            flex: 0 1 calc(50% - 4px);  /* każdy przycisk zajmuje połowę szerokości */
        }

        .route-settings select:hover {
            border-color: #0066CC;
        }


        .route-settings select:focus {
            outline: none;
            border-color: #0066CC;
            box-shadow: 0 0 0 2px rgba(0, 102, 204, 0.1);
        }
        #restart-button {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 6px 12px;
            background-color: white;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            color: #323130;
            transition: all 0.2s ease;
            z-index: 1;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            font-weight: 500;
        }

        #restart-button:hover {
            background-color: #f3f2f1;
            border-color: rgba(0, 0, 0, 0.15);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        #restart-button:active {
            background-color: #edebe9;
            transform: scale(0.98);
        }

        #map-container {
            flex: 1;
            height: 100%;
            position: relative;  /* dodajemy, żeby przycisk był względem map-container */
        }
        .toll-summary {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toll-details-toggle {
            background: none;
            border: none;
            padding: 0 4px;
            cursor: pointer;
            color: #0066CC;
            font-size: 12px;
        }

        .toll-details {
            margin-top: 8px;
            padding-left: 12px;
            border-left: 2px solid #eee;
        }

        .country-toll {
            margin: 4px 0;
            color: #666;
        }
        .route-bubble {
            position: absolute;
            background: white;
            border: 1px solid #666;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            white-space: nowrap;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .alternative-route {
            cursor: pointer;
        }
        /* InfoBubble styles */
        .H_ib {
            padding: 0 !important;
            margin: 0 !important;
            box-shadow: none !important;
            background: white !important;
            border: 1px solid #666 !important;
            border-radius: 4px !important;
            min-width: 0 !important;
            max-width: none !important;
        }

        .H_ib_body {
            padding: 4px 6px !important;
            margin: 0 !important;
            min-width: 0 !important;
            max-width: none !important;
        }

        .H_ib_content {
            margin: 0 !important;
            padding: 0 !important;
            font-size: 12px !important;
            white-space: nowrap !important;
            color: black !important;
            line-height: 1.5 !important;
            min-width: 0 !important;
            max-width: none !important;
            display: inline !important;
        }

        .H_ib_close {
            display: none !important;
        }
        .H_ib_tail {
            display: none !important;
        }
        
    </style>
</head>
<body>
    <div id="sidebar">
        <div id="waypoints-container"></div>
        <div id="route-info"></div>
        <!-- Panel ustawień trasy - dodaj przed zamknięciem diva "sidebar" -->
        <div id="route-settings" class="route-settings" style="margin-top: auto; padding: 20px;">
            <h3 style="margin-bottom: 15px; font-size: 16px;" id="settings-title"></h3>
            
            <!-- First Row: Default Selection -->
            <div class="row">
                <p id="default-settings-text"></p>
                <div class="button-group" id="default-combination">
                    <button data-weight="40000" data-axles="5+" data-translation="largeVehicle"></button>
                    <button data-weight="18000" data-axles="3" data-translation="mediumVehicle"></button>
                    <button data-weight="7490" data-axles="2" data-translation="smallVehicle"></button>
                </div>
            </div>
        
            <!-- Second Row: Weight Selection -->
            <div class="row">
                <p id="weight-text"></p>
                <div class="button-group" id="weight-selection">
                    <button data-value="7490">3,5 - 7,49</button>
                    <button data-value="11490">7,5 - 11,49</button>
                    <button data-value="18000">12 - 18</button>
                    <button data-value="40000" selected>18 - 40</button>
                </div>
            </div>
        
            <!-- Third Row: Number of Axles -->
            <div class="row">
                <p id="axles-text"></p>
                <div class="button-group" id="axles-selection">
                    <button data-value="2">2</button>
                    <button data-value="3">3</button>
                    <button data-value="4">4</button>
                    <button data-value="5+" selected>5+</button>
                </div>
            </div>
        
            <!-- Fourth Row: EUR and CO2 Class -->
            <div class="row">
                <div class="select-group">
                    <div class="select-container">
                        <p id="euro-class-text"></p>
                        <select id="euro-class">
                            <option value="2">EURO 2</option>
                            <option value="3">EURO 3</option>
                            <option value="4">EURO 4</option>
                            <option value="5">EURO 5</option>
                            <option value="6" selected>EURO 6</option>
                        </select>
                    </div>
                    <div class="select-container">
                        <p id="co2-class-text"></p>
                        <select id="co2-class">
                            <option value="1" selected>CO2 I</option>
                            <option value="2">CO2 II</option>
                            <option value="3">CO2 III</option>
                            <option value="4">CO2 IV</option>
                            <option value="5">CO2 V</option>
                        </select>
                    </div>
                </div>
            </div>
        
            <!-- Fifth Row: Excluded Areas -->
            <div class="row">
                <p id="excluded-areas-text"></p>
                <div class="button-group" id="excluded-areas">
                    <button data-value="CH">CH</button>
                    <button data-value="Fussen">Füssen</button>
                </div>
            </div>
        </div>
    </div>
    <div id="map-container">
        <button id="restart-button">Restart [CTRL+I]</button>
    </div>
	<script>
        let geocodedPoints = new Map();

        function getPreferredLanguage() {
            const supportedLanguages = ['de', 'fr', 'it', 'es', 'pl'];
            let browserLang = navigator.language.slice(0, 2).toLowerCase();
            return supportedLanguages.includes(browserLang) ? browserLang : 'en';
        }

        function getUITranslations(lang) {
            const translations = {
                en: {
                    inputPlaceholder: 'Enter address or GPS coordinates',
                    routeInfo: 'Route information:',
                    distance: 'Distance',
                    time: 'Time',
                    minutes: 'minutes',
                    routeError: 'An error occurred while calculating the route',
                    addressNotFound: 'Address not found',
                    geocodingError: 'Geocoding error',
                    addStartPoint: 'Add start point',
                    addViaPoint: 'Add via point',
                    addEndPoint: 'Add end point',
                    coordinates: 'Coordinates',
                    addStartFirst: 'Add start point first',
                    routeSettings: 'Route Settings',
                    defaultSettings: 'Default Settings',
                    largeVehicle: 'Large Vehicle',
                    mediumVehicle: 'Medium Vehicle',
                    smallVehicle: 'Small Vehicle',
                    vehicleWeight: 'Vehicle Weight (t)',
                    axleCount: 'Number of Axles',
                    euroClass: 'EUR Class',
                    co2Class: 'CO2 Class',
                    excludedAreas: 'Excluded Areas',
                    roadCharges: 'Road Charges',
                    noRoadCharges: 'No Road Charges'
                },
                de: {
                    inputPlaceholder: 'Adresse oder GPS-Koordinaten eingeben',
                    routeInfo: 'Routeninformation:',
                    distance: 'Entfernung',
                    time: 'Zeit',
                    minutes: 'Minuten',
                    routeError: 'Bei der Routenberechnung ist ein Fehler aufgetreten',
                    addressNotFound: 'Adresse nicht gefunden',
                    geocodingError: 'Geokodierungsfehler',
                    addStartPoint: 'Startpunkt hinzufügen',
                    addViaPoint: 'Viapunkt hinzufügen',
                    addEndPoint: 'Endpunkt hinzufügen',
                    coordinates: 'Koordinaten',
                    addStartFirst: 'Fügen Sie zuerst den Startpunkt hinzu',
                    routeSettings: 'Routeneinstellungen',
                    defaultSettings: 'Standardeinstellungen',
                    largeVehicle: 'Großes Fahrzeug',
                    mediumVehicle: 'Mittleres Fahrzeug',
                    smallVehicle: 'Kleines Fahrzeug',
                    vehicleWeight: 'Fahrzeuggewicht (t)',
                    axleCount: 'Anzahl der Achsen',
                    euroClass: 'EUR-Klasse',
                    co2Class: 'CO2-Klasse',
                    excludedAreas: 'Ausgeschlossene Gebiete',
                    roadCharges: 'Straßengebühren',
                    noRoadCharges: 'Keine Straßengebühren'
                },
                fr: {
                    inputPlaceholder: 'Entrez l\'adresse ou les coordonnées GPS',
                    routeInfo: 'Informations sur l\'itinéraire :',
                    distance: 'Distance',
                    time: 'Temps',
                    minutes: 'minutes',
                    routeError: 'Une erreur s\'est produite lors du calcul de l\'itinéraire',
                    addressNotFound: 'Adresse introuvable',
                    geocodingError: 'Erreur de géocodage',
                    addStartPoint: 'Ajouter le point de départ',
                    addViaPoint: 'Ajouter un point intermédiaire',
                    addEndPoint: 'Ajouter le point d\'arrivée',
                    coordinates: 'Coordonnées',
                    addStartFirst: 'Ajoutez d\'abord le point de départ',
                    routeSettings: 'Paramètres d\'itinéraire',
                    defaultSettings: 'Paramètres par défaut',
                    largeVehicle: 'Grand véhicule',
                    mediumVehicle: 'Véhicule moyen',
                    smallVehicle: 'Petit véhicule',
                    vehicleWeight: 'Poids du véhicule (t)',
                    axleCount: 'Nombre d\'essieux',
                    euroClass: 'Classe EUR',
                    co2Class: 'Classe CO2',
                    excludedAreas: 'Zones exclues',
                    roadCharges: 'Péages routiers',
                    noRoadCharges: 'Pas de péages'
                },
                it: {
                    inputPlaceholder: 'Inserisci indirizzo o coordinate GPS',
                    routeInfo: 'Informazioni sul percorso:',
                    distance: 'Distanza',
                    time: 'Tempo',
                    minutes: 'minuti',
                    routeError: 'Si è verificato un errore durante il calcolo del percorso',
                    addressNotFound: 'Indirizzo non trovato',
                    geocodingError: 'Errore di geocodifica',
                    addStartPoint: 'Aggiungi punto di partenza',
                    addViaPoint: 'Aggiungi punto intermedio',
                    addEndPoint: 'Aggiungi punto di arrivo',
                    coordinates: 'Coordinate',
                    addStartFirst: 'Aggiungi prima il punto di partenza',
                    routeSettings: 'Impostazioni percorso',
                    defaultSettings: 'Impostazioni predefinite',
                    largeVehicle: 'Veicolo grande',
                    mediumVehicle: 'Veicolo medio',
                    smallVehicle: 'Veicolo piccolo',
                    vehicleWeight: 'Peso del veicolo (t)',
                    axleCount: 'Numero di assi',
                    euroClass: 'Classe EUR',
                    co2Class: 'Classe CO2',
                    excludedAreas: 'Aree escluse',
                    roadCharges: 'Pedaggi stradali',
                    noRoadCharges: 'Nessun pedaggio'
                },
                es: {
                    inputPlaceholder: 'Introduce la dirección o coordenadas GPS',
                    routeInfo: 'Información de la ruta:',
                    distance: 'Distancia',
                    time: 'Tiempo',
                    minutes: 'minutos',
                    routeError: 'Se produjo un error al calcular la ruta',
                    addressNotFound: 'Dirección no encontrada',
                    geocodingError: 'Error de geocodificación', 
                    addStartPoint: 'Añadir punto de inicio',
                    addViaPoint: 'Añadir punto intermedio',
                    addEndPoint: 'Añadir punto final',
                    coordinates: 'Coordenadas',
                    addStartFirst: 'Añade primero el punto de inicio',
                    routeSettings: 'Configuración de ruta',
                    defaultSettings: 'Configuración predeterminada',
                    largeVehicle: 'Vehículo grande',
                    mediumVehicle: 'Vehículo mediano',
                    smallVehicle: 'Vehículo pequeño',
                    vehicleWeight: 'Peso del vehículo (t)',
                    axleCount: 'Número de ejes',
                    euroClass: 'Clase EUR',
                    co2Class: 'Clase CO2',
                    excludedAreas: 'Áreas excluidas',
                    roadCharges: 'Peajes',
                    noRoadCharges: 'Sin peajes'
                },
                pl: {
                    inputPlaceholder: 'Wpisz adres lub współrzędne GPS',
                    routeInfo: 'Informacje o trasie:',
                    distance: 'Dystans',
                    time: 'Czas jazdy',
                    minutes: 'minut',
                    routeError: 'Wystąpił błąd podczas wyznaczania trasy',
                    addressNotFound: 'Nie znaleziono adresu',
                    geocodingError: 'Błąd geokodowania', 
                    addStartPoint: 'Dodaj punkt startowy',
                    addViaPoint: 'Dodaj punkt pośredni',
                    addEndPoint: 'Dodaj punkt końcowy',
                    coordinates: 'Koordynaty',
                    addStartFirst: 'Najpierw dodaj punkt startowy',
                    routeSettings: 'Ustawienia trasy',
                    defaultSettings: 'Domyślne ustawienia',
                    largeVehicle: 'Duży pojazd',
                    mediumVehicle: 'Średni pojazd',
                    smallVehicle: 'Mały pojazd',
                    vehicleWeight: 'Waga pojazdu (t)',
                    axleCount: 'Liczba osi',
                    euroClass: 'Klasa EUR',
                    co2Class: 'Klasa CO2',
                    excludedAreas: 'Wyłączone obszary',
                    roadCharges: 'Opłaty drogowe',
                    noRoadCharges: 'Brak opłat drogowych'
                }
            };
            return translations[lang] || translations.en;
        }

        const currentLang = getPreferredLanguage();
        const translations = getUITranslations(currentLang);
        const API_KEY = 'yuwY_LTItp881XAaYOHShjcBhdc0sHWuj4TQwGKwjms';

        function isGPSCoordinates(text) {
            const cleanText = text.trim();
            
            const patterns = {
                decimal: /^(-?\d+\.?\d*),\s*(-?\d+\.?\d*)$/,
                dms: /^(-?\d+)°(\d+)'(\d+(\.\d+)?)"([NS])\s*(-?\d+)°(\d+)'(\d+(\.\d+)?)"([EW])$/
            };
            
            const decimalMatch = cleanText.match(patterns.decimal);
            if (decimalMatch) {
                const lat = parseFloat(decimalMatch[1]);
                const lng = parseFloat(decimalMatch[2]);
                return isValidLatLng(lat, lng) ? { lat, lng } : null;
            }
            
            const dmsMatch = cleanText.match(patterns.dms);
            if (dmsMatch) {
                const lat = convertDMSToDecimal(
                    parseFloat(dmsMatch[1]),
                    parseFloat(dmsMatch[2]),
                    parseFloat(dmsMatch[3]),
                    dmsMatch[5]
                );
                const lng = convertDMSToDecimal(
                    parseFloat(dmsMatch[6]),
                    parseFloat(dmsMatch[7]),
                    parseFloat(dmsMatch[8]),
                    dmsMatch[10]
                );
                return isValidLatLng(lat, lng) ? { lat, lng } : null;
            }
            
            return null;
        }

        function isValidLatLng(lat, lng) {
            return lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
        }

        function convertDMSToDecimal(degrees, minutes, seconds, direction) {
            let decimal = degrees + (minutes / 60) + (seconds / 3600);
            if (direction === 'S' || direction === 'W') {
                decimal = -decimal;
            }
            return decimal;
        }

        const platform = new H.service.Platform({
            apikey: API_KEY
        });

        const customTileProvider = new H.map.provider.ImageTileProvider({
            getURL: (x, y, z) => {
                // Determine PPI based on screen resolution
                const screenWidth = window.screen.width * window.devicePixelRatio;
                const ppi = screenWidth >= 2560 ? 200 : 100;
                
                // Select map style based on zoom level
                const mapStyle = z > 9 ? 'logistics.day' : 'explore.day';
                
                // Base URL with dynamic PPI
                let url = `https://maps.hereapi.com/v3/base/mc/${z}/${x}/${y}/png8?xnlp=CL_JSMv3.1.61.1` +
                        `&apikey=${API_KEY}` +
                        `&style=${mapStyle}` +
                        `&size=512` +
                        `&lang=${currentLang}` +
                        `&ppi=${ppi}`;
                
                // Add features for logistics.day style
                if (mapStyle === 'logistics.day') {
                    url += '&features=vehicle_restrictions:active_and_inactive,pois:disabled,congestion_zones:all';
                }
                
                return url;
            }
        });

        const customTileLayer = new H.map.layer.TileLayer(customTileProvider);
        const map = new H.Map(
            document.getElementById('map-container'),
            customTileLayer,
            {
                tileSize: 512,
                pixelRatio: window.devicePixelRatio || 1,
                zoom: 5.5,
                center: { lat: 50.0, lng: 15.0 },
                renderBaseBackground: true, // Dodajemy tło podczas ładowania
            }
        );

        window.addEventListener('resize', () => {
            map.getViewPort().resize();
        });

        const ui = new H.ui.UI(map, {
            zoom: new H.ui.ZoomControl()
        });

        // Pobierz kontrolkę zoom i ustaw jej wyrównanie
        const zoomControl = ui.getControl('zoom');
        if (zoomControl) {
            zoomControl.setAlignment('bottom-right');
        }
        const mapEvents = new H.mapevents.MapEvents(map);
        const behavior = new H.mapevents.Behavior(mapEvents);
        

        // FUNCJE DO MENU KONTEKSTOWEGO (START/VIA/KONIEC)    
        // Functions for handling waypoints from context menu
        function addStartPoint(coordinates) {
            const waypointsContainer = document.getElementById('waypoints-container');
            const waypointContainers = waypointsContainer.querySelectorAll('.waypoint-container');
            
            // Create new waypoint
            const newWaypoint = createWaypointInput();
            const input = newWaypoint.querySelector('.waypoint');
            input.value = `${coordinates.lat.toFixed(6)}, ${coordinates.lng.toFixed(6)}`;

            // Zawsze wstaw nowy punkt jako pierwszy
            if (waypointContainers.length > 0) {
                // Wstaw przed pierwszym istniejącym punktem
                waypointsContainer.insertBefore(newWaypoint, waypointContainers[0]);
            } else {
                // Jeśli nie ma żadnych punktów, po prostu dodaj
                waypointsContainer.appendChild(newWaypoint);
            }

            input.dispatchEvent(new Event('input'));
            updateWaypointNumbers();
        }

        function addViaPoint(coordinates) {
            const waypointsContainer = document.getElementById('waypoints-container');
            const waypointContainers = waypointsContainer.querySelectorAll('.waypoint-container');
            
            if (waypointContainers.length === 0) {
                alert(translations.addStartFirst);
                return;
            }

            // Create new waypoint
            const newWaypoint = createWaypointInput();
            const input = newWaypoint.querySelector('.waypoint');
            input.value = `${coordinates.lat.toFixed(6)}, ${coordinates.lng.toFixed(6)}`;

            // Znajdź wszystkie niepuste punkty
            const nonEmptyContainers = Array.from(waypointContainers).filter(container => 
                container.querySelector('.waypoint').value.trim() !== ''
            );

            if (nonEmptyContainers.length === 1) {
                // Jeśli mamy tylko punkt startowy, dodaj po nim
                const secondContainer = waypointContainers[1];
                waypointsContainer.insertBefore(newWaypoint, secondContainer || null);
            } else if (nonEmptyContainers.length >= 2) {
                // Dodaj przed ostatnim niepustym punktem
                const lastContainer = nonEmptyContainers[nonEmptyContainers.length - 1];
                waypointsContainer.insertBefore(newWaypoint, lastContainer);
            } else {
                waypointsContainer.appendChild(newWaypoint);
            }

            input.dispatchEvent(new Event('input'));
            updateWaypointNumbers();
        }

        function addEndPoint(coordinates) {
            const waypointsContainer = document.getElementById('waypoints-container');
            const waypointContainers = waypointsContainer.querySelectorAll('.waypoint-container');
            
            if (waypointContainers.length === 0) {
                alert(translations.addStartFirst);
                return;
            }

            // Create new waypoint
            const newWaypoint = createWaypointInput();
            const input = newWaypoint.querySelector('.waypoint');
            input.value = `${coordinates.lat.toFixed(6)}, ${coordinates.lng.toFixed(6)}`;

            // Znajdź wszystkie niepuste punkty
            const nonEmptyContainers = Array.from(waypointContainers).filter(container => 
                container.querySelector('.waypoint').value.trim() !== ''
            );

            if (nonEmptyContainers.length > 0) {
                // Zawsze dodaj na końcu, po wszystkich istniejących punktach
                const lastContainer = waypointContainers[waypointContainers.length - 1];
                waypointsContainer.insertBefore(newWaypoint, lastContainer.nextSibling);
            } else {
                waypointsContainer.appendChild(newWaypoint);
            }

            input.dispatchEvent(new Event('input'));
            updateWaypointNumbers();
        }


        // LISTENER NA PRAWY PRZYCISK MYSZY!
        // Add map right click handler
        map.addEventListener('pointerdown', (evt) => {
        // Check if it's right mouse button
        if (evt.currentPointer.button === 2) {
            // Prevent default browser's context menu
            evt.originalEvent.preventDefault();
            
            // Remove any existing menu before creating new one
            document.querySelectorAll('.context-menu').forEach(menu => menu.remove());
            
            const coordinates = map.screenToGeo(
                evt.currentPointer.viewportX,
                evt.currentPointer.viewportY
            );
            
            // Create a temporary div for our custom context menu
            const menuDiv = document.createElement('div');
            menuDiv.className = 'context-menu';
            menuDiv.style.position = 'fixed'; // Zmiana z 'absolute' na 'fixed'
            
            // Pobieramy pozycję kliknięcia względem strony
            const x = evt.originalEvent.pageX;
            const y = evt.originalEvent.pageY;
            
            menuDiv.style.left = x + 'px';
            menuDiv.style.top = y + 'px';
            menuDiv.style.backgroundColor = 'white';
            menuDiv.style.border = '1px solid #ddd';
            menuDiv.style.borderRadius = '4px';
            menuDiv.style.padding = '5px';
            menuDiv.style.zIndex = '1000';
            menuDiv.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';

            // Create menu items
            const menuItems = [
                { text: translations.addStartPoint, action: () => addStartPoint(coordinates) },
                { text: translations.addViaPoint, action: () => addViaPoint(coordinates) },
                { text: translations.addEndPoint, action: () => addEndPoint(coordinates) },
                { text: `${translations.coordinates}: ${coordinates.lat.toFixed(6)}, ${coordinates.lng.toFixed(6)}`, action: null }
            ];
            menuItems.forEach(item => {
                const menuItem = document.createElement('div');
                
                if (item.text.startsWith(translations.coordinates)) {
                    // Specjalna obsługa dla elementu z koordynatami
                    const coordsText = `${coordinates.lat.toFixed(6)}, ${coordinates.lng.toFixed(6)}`;
                    
                    menuItem.innerHTML = `
                        <div style="margin-bottom: 2px">
                            ${translations.coordinates}: 
                            <span class="coords-value" style="cursor: pointer; color: #0066CC;">${coordsText}</span>
                        </div>
                        <div class="copy-feedback" style="display: none; color: #28a745; font-size: 11px;">
                            ✓ Skopiowano
                        </div>
                    `;
                    
                    const wholeItem = menuItem;
                    const coordsSpan = menuItem.querySelector('.coords-value');
                    const feedbackSpan = menuItem.querySelector('.copy-feedback');
                    
                    // Dodaj obsługę kliknięcia na cały element
                    wholeItem.style.cursor = 'pointer';
                    wholeItem.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        
                        try {
                            await navigator.clipboard.writeText(coordsText); // Kopiujemy tylko same koordynaty
                            
                            feedbackSpan.style.display = 'block';
                            
                            setTimeout(() => {
                                feedbackSpan.style.display = 'none';
                            }, 2000);
                        } catch (err) {
                            console.error('Failed to copy coordinates:', err);
                            
                            const textArea = document.createElement('textarea');
                            textArea.value = coordsText;
                            document.body.appendChild(textArea);
                            textArea.select();
                            try {
                                document.execCommand('copy');
                                feedbackSpan.style.display = 'block';
                                setTimeout(() => {
                                    feedbackSpan.style.display = 'none';
                                }, 2000);
                            } catch (err) {
                                console.error('Fallback copy failed:', err);
                            }
                            document.body.removeChild(textArea);
                        }
                    });
                    
                    menuItem.style.padding = '8px 12px';
                    menuItem.style.color = '#666';
                    menuItem.style.fontSize = '12px';
                    
                } else {
                    // Standardowa obsługa dla pozostałych elementów menu
                    menuItem.textContent = item.text;
                    menuItem.style.padding = '8px 12px';
                    menuItem.style.cursor = item.action ? 'pointer' : 'default';
                    menuItem.style.borderBottom = '1px solid #eee';
                    
                    if (item.action) {
                        menuItem.addEventListener('mouseover', () => {
                            menuItem.style.backgroundColor = '#f0f0f0';
                        });
                        menuItem.addEventListener('mouseout', () => {
                            menuItem.style.backgroundColor = 'white';
                        });
                        menuItem.addEventListener('click', () => {
                            item.action();
                            menuDiv.remove();
                        });
                    }
                }
                
                menuDiv.appendChild(menuItem);
            });

            document.getElementById('map-container').appendChild(menuDiv);
            
            // Sprawdzamy, czy menu nie wychodzi poza ekran
            setTimeout(() => {
                const rect = menuDiv.getBoundingClientRect();
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                
                if (rect.right > windowWidth) {
                    menuDiv.style.left = (windowWidth - rect.width) + 'px';
                }
                
                if (rect.bottom > windowHeight) {
                    menuDiv.style.top = (windowHeight - rect.height) + 'px';
                }
            }, 0);
            
            // Remove menu when clicking anywhere else
            const removeMenu = () => {
                menuDiv.remove();
                document.removeEventListener('click', removeMenu);
            };
            
            document.addEventListener('click', removeMenu);
        }
    });

        // Disable the default draggability of the underlying map
        // and enable it only when no marker is being dragged
        let isDragging = false;

        map.addEventListener('dragstart', function(ev) {
            const target = ev.target;
            if (target instanceof H.map.Marker) {
                isDragging = true;
                // Disable the default draggability of the underlying map
                // when starting to drag a marker
                behavior.disable();
            }
        });

        map.addEventListener('drag', function(ev) {
            const target = ev.target;
            if (target instanceof H.map.Marker && isDragging) {
                const pointer = ev.currentPointer;
                target.setGeometry(map.screenToGeo(pointer.viewportX, pointer.viewportY));
            }
        });

        map.addEventListener('dragend', function(ev) {
            const target = ev.target;
            if (target instanceof H.map.Marker && isDragging) {
                isDragging = false;
                behavior.enable();
                
                // Pobierz nową pozycję markera
                const newPosition = target.getGeometry();
                const markerId = target.getData().id;
                
                // Zaktualizuj koordynaty dla odpowiedniego punktu
                const waypoints = document.querySelectorAll('.waypoint');
                const waypointInput = waypoints[markerId - 1];
                
                if (waypointInput) {
                    // Wykonaj reverse geocoding dla nowej pozycji
                    fetch(
                        `https://revgeocode.search.hereapi.com/v1/revgeocode` +
                        `?at=${newPosition.lat},${newPosition.lng}` +
                        `&limit=1` +
                        `&lang=${currentLang}` +
                        `&apiKey=${API_KEY}`
                    )
                    .then(response => response.json())
                    .then(data => {
                        if (data.items && data.items.length > 0) {
                            const address = data.items[0].title;
                            
                            // Zaktualizuj pole adresu
                            waypointInput.value = address;
                            
                            // Zaktualizuj wyświetlane koordynaty
                            const coordsStr = `${newPosition.lat.toFixed(6)}, ${newPosition.lng.toFixed(6)}`;
                            const box = waypointInput.parentElement;
                            const coordsDisplay = box.querySelector('.coordinates-display');
                            if (coordsDisplay) {
                                coordsDisplay.textContent = coordsStr;
                            }
                            
                            // Zaktualizuj geocodedPoints
                            geocodedPoints.set(address, {
                                lat: newPosition.lat,
                                lng: newPosition.lng,
                                address: address
                            });
                            
                            // Przelicz trasę
                            calculateRouteIfPossible();
                        }
                    })
                    .catch(error => {
                        console.error('Reverse geocoding error:', error);
                    });
                }
            }
        });

        // Prevent the default draggability of the underlying map
        // when starting to drag a marker
        map.addEventListener('pointerdown', function(ev) {
            if (ev.target instanceof H.map.Marker) {
                behavior.disable();
            }
        }, false);

        // Re-enable the default draggability of the underlying map
        // after dragging is finished
        map.addEventListener('pointerup', function(ev) {
            if (ev.target instanceof H.map.Marker) {
                behavior.enable();
            }
        }, false);

        let currentRouteIndex = 0; // indeks aktualnie wybranej trasy
        let routeLines = [];
        let markers = [];
        let debounceTimer;
		
        async function geocodeAddress(address) {
            const gpsCoords = isGPSCoordinates(address);
            
            if (gpsCoords) {
                try {
                    const response = await fetch(
                        `https://revgeocode.search.hereapi.com/v1/revgeocode` +
                        `?at=${gpsCoords.lat},${gpsCoords.lng}` +
                        `&limit=1` +
                        `&lang=${currentLang}` +
                        `&apiKey=${API_KEY}`
                    );
                    
                    if (!response.ok) {
                        throw new Error(translations.geocodingError);
                    }
                    
                    const data = await response.json();
                    
                    if (data.items && data.items.length > 0) {
                        const addressInfo = data.items[0].address;
                        
                        // Tworzymy część adresu z ulicą i numerem
                        let streetPart = '';
                        if (addressInfo.street) {
                            streetPart = addressInfo.street;
                            if (addressInfo.houseNumber) {
                                streetPart += ' ' + addressInfo.houseNumber;
                            }
                        }
                        
                        const formattedAddress = [
                            addressInfo.postalCode,
                            addressInfo.city,
                            addressInfo.countryCode,
                            streetPart
                        ].filter(Boolean).join(', ');

                        return {
                            lat: gpsCoords.lat,
                            lng: gpsCoords.lng,
                            address: formattedAddress
                        };
                    } else {
                        throw new Error(translations.addressNotFound);
                    }
                } catch (error) {
                    console.error('Reverse geocoding error:', error);
                    return { lat: gpsCoords.lat, lng: gpsCoords.lng };
                }
            } else {
                return new Promise((resolve, reject) => {
                    const service = platform.getSearchService();
                    service.geocode({
                        q: address,
                        limit: 1
                    }, (result) => {
                        if (result.items && result.items.length > 0) {
                            const addressInfo = result.items[0].address;
                            
                            // Tworzymy część adresu z ulicą i numerem
                            let streetPart = '';
                            if (addressInfo.street) {
                                streetPart = addressInfo.street;
                                if (addressInfo.houseNumber) {
                                    streetPart += ' ' + addressInfo.houseNumber;
                                }
                            }
                            
                            const formattedAddress = [
                                addressInfo.postalCode,
                                addressInfo.city,
                                addressInfo.countryCode,
                                streetPart
                            ].filter(Boolean).join(', ');

                            resolve({
                                lat: result.items[0].position.lat,
                                lng: result.items[0].position.lng,
                                address: formattedAddress
                            });
                        } else {
                            reject(new Error(translations.addressNotFound));
                        }
                    }, (error) => {
                        console.error('Geocoding error:', error);
                        reject(new Error(translations.geocodingError));
                    });
                });
            }
        }

        function updateWaypointNumbers() {
            const containers = document.querySelectorAll('.waypoint-container');
            containers.forEach((container, index) => {
                const numberDiv = container.querySelector('.waypoint-number');
                if (numberDiv) {
                    numberDiv.textContent = (index + 1).toString();
                }
            });
        }

        function addMarker(position, number) {
            const svgMarkup = '<svg width="48" height="48" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">' +
                '<circle cx="12" cy="21" r="2.5" fill="white" stroke="black" stroke-width="1"/>' + // dodana biała kropka na dole
                '<path fill="#0066CC" d="M12 2.5c-3.8 0-7 3.2-7 7.1 0 5.4 7 11.9 7 11.9s7-6.5 7-11.9c0-3.9-3.2-7.1-7-7.1z" />' +
                '<circle cx="12" cy="9" r="4" fill="#FFFFFF"/>' +
                '<text x="12" y="11" font-size="6" font-family="Arial" font-weight="bold" text-anchor="middle" fill="#0066CC">' + 
                number + '</text>' +
                '</svg>';

            const icon = new H.map.Icon(svgMarkup, {
                anchor: { x: 24, y: 48 }
            });
            
            const marker = new H.map.Marker(position, {
                icon: icon,
                volatility: true,
                draggable: true,
                data: { id: number }
            });

            marker.draggable = true;
            
            markers.push(marker);
            map.addObject(marker);
            return marker;
        }


        let routeBubbles = [];
        function clearMap() {
            try {
                // Clear existing InfoBubbles
                routeBubbles.forEach(bubble => {
                    if (bubble && bubble.close) {
                        bubble.close();
                    }
                });
                routeBubbles = [];
                
                // Rest of your existing clearMap code...
                routeLines.forEach(line => {
                    if (line && typeof line.dispose === 'function') {
                        line.dispose();
                    }
                    if (line && map.getObjects().includes(line)) {
                        map.removeObject(line);
                    }
                });
                routeLines = [];
                
                markers.forEach(marker => {
                    if (marker && typeof marker.dispose === 'function') {
                        marker.dispose();
                    }
                    if (marker && map.getObjects().includes(marker)) {
                        map.removeObject(marker);
                    }
                });
                markers = [];
                
                const routeInfo = document.getElementById('route-info');
                if (routeInfo) {
                    routeInfo.innerHTML = '';
                }
            } catch (error) {
                console.error('Error clearing map:', error);
            }
        }

        // Drag & Drop handlers
        // Zmienne globalne dla obsługi przeciągania
        let draggedElement = null;
        let initialY = 0;
        let currentY = 0;
        let offsetY = 0;

        // Główne funkcje obsługi przeciągania
        function handleDragStart(e) {
            if (!e.target.classList.contains('waypoint-number')) {
                return;
            }
            e.preventDefault();
            
            draggedElement = this.parentElement;
            const rect = draggedElement.getBoundingClientRect();
            initialY = e.clientY;
            offsetY = e.clientY - rect.top;
            
            draggedElement.style.setProperty('--y', '0px');
            draggedElement.classList.add('dragging');
            draggedElement.style.width = `${rect.width}px`;
            draggedElement.style.left = `${rect.left}px`;
            draggedElement.originalIndex = Array.from(draggedElement.parentNode.children).indexOf(draggedElement);
            
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', handleDragEnd);
        }

        function handleDrag(e) {
            if (!draggedElement) return;
            e.preventDefault();
            
            currentY = e.clientY;
            const deltaY = currentY - initialY;
            draggedElement.style.setProperty('--y', `${deltaY}px`);
            
            const containers = Array.from(document.querySelectorAll('.waypoint-container:not(.dragging)'));
            const draggedRect = draggedElement.getBoundingClientRect();
            const draggedIndex = draggedElement.originalIndex;
            
            containers.forEach(container => {
                const rect = container.getBoundingClientRect();
                const containerIndex = Array.from(container.parentNode.children).indexOf(container);
                
                container.classList.remove('shift-up', 'shift-down');
                
                if (draggedRect.top + draggedRect.height / 2 < rect.top + rect.height / 2) {
                    // Jeśli przeciągamy nad element, to powinien on przesunąć się w dół
                    // Niezależnie od tego czy jest pierwszy czy nie
                    if (containerIndex > draggedIndex) {
                        container.classList.add('shift-down');
                    }
                } else {
                    // Przy przesuwaniu w górę, tylko elementy nie będące pierwszym mogą się przesunąć wyżej
                    if (containerIndex < draggedIndex && containerIndex !== 0) {
                        container.classList.add('shift-up');
                    }
                }

                // Specjalna obsługa dla pierwszego elementu
                if (containerIndex === 0 && draggedRect.top < rect.top) {
                    container.classList.add('shift-down');
                }
            });
        }
        function handleDragEnd(e) {
            if (!draggedElement) return;
            
            document.removeEventListener('mousemove', handleDrag);
            document.removeEventListener('mouseup', handleDragEnd);
            
            const containers = document.querySelectorAll('.waypoint-container');
            containers.forEach(container => {
                container.classList.remove('shift-up', 'shift-down');
            });
            
            const draggedRect = draggedElement.getBoundingClientRect();
            const targetContainer = Array.from(containers).find(container => {
                if (container === draggedElement) return false;
                const rect = container.getBoundingClientRect();
                return draggedRect.top + draggedRect.height / 2 < rect.top + rect.height / 2;
            });
            
            if (targetContainer) {
                targetContainer.parentNode.insertBefore(draggedElement, targetContainer);
            } else {
                const lastContainer = containers[containers.length - 1];
                lastContainer.parentNode.insertBefore(draggedElement, lastContainer.nextSibling);
            }
            
            draggedElement.classList.remove('dragging');
            draggedElement.style.removeProperty('--y');
            draggedElement.style.removeProperty('width');
            draggedElement.style.removeProperty('left');
            
            // Sprawdź czy ostatnie pole jest puste
            const allWaypoints = document.querySelectorAll('.waypoint');
            const lastWaypoint = allWaypoints[allWaypoints.length - 1];
            
            if (lastWaypoint && lastWaypoint.value.trim() !== '' && allWaypoints.length < 15) {
                const waypointsContainer = document.getElementById('waypoints-container');
                waypointsContainer.appendChild(createWaypointInput());
            }
            
            updateWaypointNumbers();
            updateRemoveButtons();
            calculateRouteIfPossible();
            
            draggedElement = null;
        }

        // Zmiana w event listenerach
        document.addEventListener('mousemove', handleDrag);
        document.addEventListener('mouseup', handleDragEnd);



        function updateRemoveButtons() {
            const containers = document.querySelectorAll('.waypoint-container');
            
            containers.forEach((container, index) => {
                // Usuń istniejący przycisk usuwania (jeśli istnieje)
                const existingButton = container.querySelector('.remove-waypoint');
                if (existingButton) {
                    existingButton.remove();
                }
                
                // Sprawdź czy to ostatnie puste pole
                const isLastEmpty = index === containers.length - 1 && 
                                container.querySelector('.waypoint').value.trim() === '';
                
                // Sprawdź czy to jedyne pole
                const isOnlyField = containers.length === 1;
                
                // Dodaj przycisk usuwania jeśli:
                // - nie jest to jedyne pole AND
                // - nie jest to ostatnie puste pole
                if (!isOnlyField && !isLastEmpty) {
                    const removeButton = document.createElement('button');
                    removeButton.className = 'remove-waypoint';
                    removeButton.textContent = '×';
                    removeButton.onclick = () => {
                        const input = container.querySelector('.waypoint');
                        if (input && input.value) {
                            geocodedPoints.delete(input.value.trim());
                        }
                        container.remove();
                        updateWaypointNumbers();
                        updateRemoveButtons();
                        clearMap();
                        setTimeout(() => {
                            calculateRouteIfPossible();
                        }, 0);
                    };
                    container.appendChild(removeButton);
                }
            });
        }

        function createWaypointInput() {
            const container = document.createElement('div');
            container.className = 'waypoint-container';
            
            const numberDiv = document.createElement('div');
            numberDiv.className = 'waypoint-number';
            numberDiv.addEventListener('mousedown', handleDragStart);
            container.appendChild(numberDiv);
            
            const box = document.createElement('div');
            box.className = 'waypoint-box';
            
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'waypoint';
            input.placeholder = translations.inputPlaceholder;

            const suggestionsContainer = document.createElement('div');
            suggestionsContainer.className = 'suggestions-container';
            
            // Sprawdź aktualną liczbę kontenerów
            const waypointsContainer = document.getElementById('waypoints-container');
            const existingContainers = waypointsContainer.querySelectorAll('.waypoint-container');
            const isFirstContainer = existingContainers.length === 0;
            const willBeLastContainer = container === existingContainers[existingContainers.length - 1];

            // Dodaj przycisk usuwania dla wszystkich pól oprócz pierwszego i ostatniego pustego
            if (!isFirstContainer && !willBeLastContainer) {
                const removeButton = document.createElement('button');
                removeButton.className = 'remove-waypoint';
                removeButton.textContent = '×';
                removeButton.onclick = () => {
                    const input = container.querySelector('.waypoint');
                    if (input && input.value) {
                        geocodedPoints.delete(input.value.trim());
                    }
                    
                    clearMap();
                    container.remove();
                    updateWaypointNumbers();
                    
                    setTimeout(() => {
                        calculateRouteIfPossible();
                    }, 0);
                };
                container.appendChild(removeButton);
            }
            
            box.appendChild(input);
            container.appendChild(box);
            container.appendChild(suggestionsContainer);
            
            initializeAutocomplete(input, suggestionsContainer);
            updateWaypointNumbers();
            updateRemoveButtons();
            return container;
        }
        function initializeAutocomplete(input, suggestionsContainer) {
            let searchTimeout;
            let selectedIndex = -1;
            let suggestions = [];

            input.addEventListener('input', () => {
                clearTimeout(searchTimeout);
                const query = input.value.trim();
                
                const gpsCoords = isGPSCoordinates(query);
                
                if (gpsCoords) {
                    suggestionsContainer.style.display = 'none';
                    selectedIndex = -1;
                    calculateRouteIfPossible();
                    return;
                }
                
                if (query.length >= 3) {
                    searchTimeout = setTimeout(async () => {
                        try {
                            const response = await fetch(
                                `https://autocomplete.search.hereapi.com/v1/autocomplete` +
                                `?apiKey=${API_KEY}` +
                                `&q=${encodeURIComponent(query)}` +
                                `&in=countryCode:AND,ALB,AUT,BIH,BEL,BGR,BLR,CHE,CYP,CZE,DEU,DNK,EST,ESP,FIN,FRO,FRA,GBR,GIB,GRC,HRV,HUN,IRL,IMN,ISL,ITA,LIE,LTU,LUX,LVA,MCO,MDA,MNE,MKD,MLT,NLD,NOR,POL,PRT,ROU,SRB,RUS,SWE,SVN,SVK,SMR,TUR,UKR,VAT,KOS` +
                                `&limit=5` +
                                `&lang=${currentLang}`
                            );
                            
                            const data = await response.json();
                            suggestionsContainer.innerHTML = '';
                            suggestions = data.items || [];

                            if (suggestions.length > 0) {
                                selectedIndex = 0;
                                
                                suggestions.forEach((item, index) => {
                                    const div = document.createElement('div');
                                    div.className = 'suggestion-item';
                                    if (index === 0) {
                                        div.classList.add('selected');
                                    }
                                    div.textContent = item.title;
                                    
                                    div.addEventListener('click', () => {
                                        selectSuggestion(item, input);
                                    });
                                    
                                    suggestionsContainer.appendChild(div);
                                });
                                suggestionsContainer.style.display = 'block';
                            } else {
                                suggestionsContainer.style.display = 'none';
                                selectedIndex = -1;
                            }
                        } catch (error) {
                            console.error('Autosuggest error:', error);
                            suggestionsContainer.style.display = 'none';
                            selectedIndex = -1;
                        }
                    }, 300);
                } else {
                    suggestionsContainer.style.display = 'none';
                    selectedIndex = -1;
                }
            });

            input.addEventListener('keydown', (e) => {
                const query = input.value.trim();
                const gpsCoords = isGPSCoordinates(query);
                const suggestionItems = suggestionsContainer.querySelectorAll('.suggestion-item');
                
                switch (e.key) {
                    case 'ArrowDown':
                        e.preventDefault();
                        if (!gpsCoords && selectedIndex < suggestionItems.length - 1) {
                            selectedIndex++;
                            updateSelection(suggestionItems);
                        }
                        break;
                        
                    case 'ArrowUp':
                        e.preventDefault();
                        if (!gpsCoords && selectedIndex > 0) {
                            selectedIndex--;
                            updateSelection(suggestionItems);
                        }
                        break;
                        
                    case 'Enter':
                        e.preventDefault();
                        if (gpsCoords) {
                            handleGPSEntry(input);
                        } else if (suggestionsContainer.style.display === 'block' && selectedIndex >= 0 && suggestions[selectedIndex]) {
                            selectSuggestion(suggestions[selectedIndex], input);
                        }
                        break;
                        
                    case 'Escape':
                        suggestionsContainer.style.display = 'none';
                        selectedIndex = -1;
                        break;
                }
            });

            function updateSelection(items) {
                items.forEach((item, index) => {
                    item.classList.toggle('selected', index === selectedIndex);
                });
            }

            function handleGPSEntry(input) {
                const waypoints = document.querySelectorAll('.waypoint');
                const currentIndex = Array.from(waypoints).indexOf(input);
                const lastWaypoint = waypoints[waypoints.length - 1];
                
                // Dodaj warunek sprawdzający limit
                if (input === lastWaypoint && waypoints.length < 15) {
                    const waypointsContainer = document.getElementById('waypoints-container');
                    waypointsContainer.appendChild(createWaypointInput());
                }
                
                setTimeout(() => {
                    const updatedWaypoints = document.querySelectorAll('.waypoint');
                    const nextInput = updatedWaypoints[currentIndex + 1];
                    if (nextInput) {
                        nextInput.focus();
                    }
                }, 50);

                calculateRouteIfPossible();
            }

            function selectSuggestion(suggestion, input) {
                input.value = suggestion.title;
                suggestionsContainer.style.display = 'none';
                
                const waypoints = document.querySelectorAll('.waypoint');
                const currentIndex = Array.from(waypoints).indexOf(input);
                const lastWaypoint = waypoints[waypoints.length - 1];
                
                // Dodaj warunek sprawdzający limit
                if (input === lastWaypoint && waypoints.length < 15) {
                    const waypointsContainer = document.getElementById('waypoints-container');
                    waypointsContainer.appendChild(createWaypointInput());
                }
                
                setTimeout(() => {
                    const updatedWaypoints = document.querySelectorAll('.waypoint');
                    const nextInput = updatedWaypoints[currentIndex + 1];
                    if (nextInput) {
                        nextInput.focus();
                    }
                }, 50);

                calculateRouteIfPossible();
            }

            input.addEventListener('focus', () => {
                if (input.value.trim().length >= 3) {
                    const event = new Event('input');
                    input.dispatchEvent(event);
                }
            });
            
            document.addEventListener('click', (e) => {
                if (!input.contains(e.target) && !suggestionsContainer.contains(e.target)) {
                    suggestionsContainer.style.display = 'none';
                    selectedIndex = -1;
                }
            });
        }

        let allRoutes = [];
        let currentRouteCalculation = null;

        async function calculateRouteIfPossible() {
            try {

                // Anuluj poprzednie przeliczanie trasy
                if (currentRouteCalculation) {
                    currentRouteCalculation.abort();
                }
                
                // Utwórz nowy kontroler dla tego przeliczenia
                currentRouteCalculation = new AbortController();
                const signal = currentRouteCalculation.signal;    


                const waypointInputs = Array.from(document.querySelectorAll('.waypoint'))
                    .map(input => ({
                        element: input.parentElement,
                        value: input.value.trim()
                    }))
                    .filter(wp => wp.value !== '');

                clearMap();

                // Handle single waypoint case
                if (waypointInputs.length === 1) {
                    const result = await geocodeAddress(waypointInputs[0].value);
                    addMarker({ lat: result.lat, lng: result.lng }, 1);
                    
                    const box = waypointInputs[0].element;
                    const container = box.closest('.waypoint-container');
                    const input = box.querySelector('.waypoint');
                    
                    if (result.address) {
                        input.value = result.address;
                        geocodedPoints.set(input.value.trim(), result);
                    }
                    
                    const oldCoordsDisplay = box.querySelector('.coordinates-display');
                    if (oldCoordsDisplay) {
                        oldCoordsDisplay.remove();
                    }
                    
                    const coordsDisplay = document.createElement('div');
                    coordsDisplay.className = 'coordinates-display';
                    coordsDisplay.textContent = `${result.lat.toFixed(6)}, ${result.lng.toFixed(6)}`;
                    box.appendChild(coordsDisplay);

                    map.setCenter({ lat: result.lat, lng: result.lng });
                    map.setZoom(7);
                    return;
                }

                if (waypointInputs.length < 2) {
                    return;
                }

                const geoResults = await Promise.all(
                    waypointInputs.map(async wp => {
                        if (geocodedPoints.has(wp.value)) {
                            return geocodedPoints.get(wp.value);
                        }
                        const result = await geocodeAddress(wp.value);
                        geocodedPoints.set(wp.value, result);
                        return result;
                    })
                );

                geoResults.forEach((result, index) => {
                    addMarker({ lat: result.lat, lng: result.lng }, index + 1);
                    
                    const box = waypointInputs[index].element;
                    const container = box.closest('.waypoint-container');
                    const input = box.querySelector('.waypoint');
                    
                    if (result.address) {
                        input.value = result.address;
                        geocodedPoints.set(input.value.trim(), result);
                    }
                    
                    const oldCoordsDisplay = box.querySelector('.coordinates-display');
                    if (oldCoordsDisplay) {
                        oldCoordsDisplay.remove();
                    }
                    
                    const coordsDisplay = document.createElement('div');
                    coordsDisplay.className = 'coordinates-display';
                    coordsDisplay.textContent = `${result.lat.toFixed(6)}, ${result.lng.toFixed(6)}`;
                    box.appendChild(coordsDisplay);
                    
                    const numberDiv = container.querySelector('.waypoint-number');
                    numberDiv.textContent = (index + 1).toString();
                });

                const origin = { lat: geoResults[0].lat, lng: geoResults[0].lng };
                const destination = { 
                    lat: geoResults[geoResults.length - 1].lat, 
                    lng: geoResults[geoResults.length - 1].lng 
                };
                const viaPoints = geoResults.slice(1, -1).map(result => ({
                    lat: result.lat,
                    lng: result.lng
                }));

                // Get vehicle parameters
                const weightBtn = document.querySelector('#weight-selection button.active');
                const axlesBtn = document.querySelector('#axles-selection button.active');
                const weight = weightBtn ? parseInt(weightBtn.dataset.value) : 3500;
                const axleCount = axlesBtn ? parseInt(axlesBtn.dataset.value) : 2;
                const euroClass = document.querySelector('#euro-class').value;
                const co2Class = document.querySelector('#co2-class').value;

                // Adjusted vehicle configuration based on axle count
                const trailerCount = axleCount <= 2 ? 0 : 1;
                const trailerAxleCount = axleCount <= 2 ? 0 : axleCount - 2; // Subtract truck axles
                const tiresCount = axleCount <= 2 ? 4 : (axleCount * 2); // 2 tires per axle

                // Check excluded areas
                const excludedAreas = [];
                const excludedButtons = document.querySelectorAll('#excluded-areas button.active');
                
                excludedButtons.forEach(button => {
                    if (button.dataset.value === 'CH') {
                        excludedAreas.push('CHE'); // Country code for Switzerland
                    } else if (button.dataset.value === 'Fussen') {
                        excludedAreas.push({
                            type: 'bbox',
                            west: 10.503569952001044,
                            south: 47.40623942387259,
                            east: 10.88272284357322,
                            north: 47.648267570933086
                        });
                    }
                });

                // Construct route URL with exclusions
                let routeUrl = `https://router.hereapi.com/v8/routes` +
                    `?xnlp=CL_JSMv3.1.61.1` +
                    `&apiKey=${API_KEY}` +
                    `&transportMode=truck` +
                    `&routingMode=fast` +
                    `&units=metric` +
                    `&lang=${currentLang}` +
                    `&currency=EUR` +
                    `&alternatives=1` +
                    `&spans=tollSystems,truckAttributes,countryCode,length,routeNumbers,notices` +
                    `&return=polyline,tolls,summary,travelSummary,passthrough,routeHandle,incidents,actions,potentialTimeDependentViolations`;

                // Add vehicle parameters
                routeUrl += `&vehicle[height]=400` +
                    `&vehicle[width]=255` +
                    `&vehicle[length]=1650` +
                    `&vehicle[currentWeight]=${weight}` +
                    `&vehicle[grossWeight]=${weight}` +
                    `&vehicle[axleCount]=${axleCount}` +
                    `&vehicle[tiresCount]=${tiresCount}` +
                    `&vehicle[engineType]=internalCombustion` +
                    `&vehicle[weightPerAxle]=10000` +
                    `&vehicle[heightAboveFirstAxle]=400`;

                // Add trailer parameters only if there is a trailer
                if (trailerCount > 0) {
                    routeUrl += `&vehicle[trailerCount]=${trailerCount}` +
                            `&vehicle[trailerAxleCount]=${trailerAxleCount}`;
                }

                // Add excluded areas
                excludedAreas.forEach(area => {
                    if (typeof area === 'string') {
                        routeUrl += `&exclude[countries]=${area}`;
                    } else if (area.type === 'bbox') {
                        routeUrl += `&avoid[areas]=bbox:${area.west},${area.south},${area.east},${area.north}`;
                    }
                });

                // Add waypoints
                routeUrl += `&origin=${origin.lat},${origin.lng}` +
                    `&destination=${destination.lat},${destination.lng}`;

                if (viaPoints.length > 0) {
                    routeUrl += viaPoints.map(point =>
                        `&via=${point.lat},${point.lng};snapRadius=3000`
                    ).join('');
                }

                // Add toll parameters
                routeUrl += `&departureTime=any` +
                    `&tolls[emissionType]=euro${euroClass};co2class=${co2Class}` +
                    `&tolls[summaries]=total`;

                const response = await fetch(routeUrl, { signal });
                if (!response.ok) {
                    throw new Error(`${translations.routeError}: ${response.status}`);
                }

                const result = await response.json();
                function addRouteBubble(mainRoute, alternativeRoute) {
                    // Zbierz punkty z trasy głównej
                    const mainPoints = [];
                    mainRoute.sections.forEach(section => {
                        const lineString = H.geo.LineString.fromFlexiblePolyline(section.polyline);
                        const latLngArray = lineString.getLatLngAltArray();
                        for (let i = 0; i < latLngArray.length; i += 3) {
                            mainPoints.push({
                                lat: latLngArray[i],
                                lng: latLngArray[i + 1]
                            });
                        }
                    });

                    // Zbierz punkty z trasy alternatywnej
                    const altPoints = [];
                    alternativeRoute.sections.forEach(section => {
                        const lineString = H.geo.LineString.fromFlexiblePolyline(section.polyline);
                        const latLngArray = lineString.getLatLngAltArray();
                        for (let i = 0; i < latLngArray.length; i += 3) {
                            altPoints.push({
                                lat: latLngArray[i],
                                lng: latLngArray[i + 1]
                            });
                        }
                    });

                    // Znajdź punkt największego odchylenia
                    let maxDeviation = 0;
                    let deviationPoint = altPoints[Math.floor(altPoints.length / 2)]; // domyślnie środek trasy alternatywnej

                    // Sprawdzamy co 10-ty punkt dla optymalizacji
                    for (let i = 0; i < altPoints.length; i += 10) {
                        const altPoint = altPoints[i];
                        let minDistance = Infinity;

                        // Sprawdzamy co 10-ty punkt trasy głównej
                        for (let j = 0; j < mainPoints.length; j += 10) {
                            const mainPoint = mainPoints[j];
                            const latDiff = altPoint.lat - mainPoint.lat;
                            const lngDiff = altPoint.lng - mainPoint.lng;
                            const distance = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);
                            
                            if (distance < minDistance) {
                                minDistance = distance;
                            }
                        }

                        if (minDistance > maxDeviation) {
                            maxDeviation = minDistance;
                            deviationPoint = altPoint;
                        }
                    }

                    // Oblicz różnice
                    const mainDistance = mainRoute.sections.reduce((sum, section) => sum + section.summary.length, 0);
                    const altDistance = alternativeRoute.sections.reduce((sum, section) => sum + section.summary.length, 0);
                    const mainTolls = calculateTotalTolls(mainRoute);
                    const altTolls = calculateTotalTolls(alternativeRoute);
                    
                    const distanceDiff = ((altDistance - mainDistance) / 1000);
                    const tollsDiff = (altTolls - mainTolls);
                    
                    // Sprawdź czy różnice przekraczają progi
                    const DISTANCE_THRESHOLD = 0.1; // 100m
                    const TOLL_THRESHOLD = 0.1; // 0.1 EUR
                    

                    if (Math.abs(distanceDiff) > DISTANCE_THRESHOLD || Math.abs(tollsDiff) > TOLL_THRESHOLD) {
                        const bubbleId = 'route-switch-' + Math.random().toString(36).substr(2, 9);

                        const bubbleContent = `
                            <div id="${bubbleId}" style="cursor: pointer;">
                                <div style="color: ${distanceDiff > 0 ? '#ff4444' : '#44aa44'}">${distanceDiff > 0 ? '+' : ''}${distanceDiff.toFixed(1)} km</div>
                                <div style="color: ${tollsDiff > 0 ? '#ff4444' : '#44aa44'}">${tollsDiff > 0 ? '+' : ''}${tollsDiff.toFixed(2)} €</div>
                            </div>
                        `;
                        
                        const bubble = new H.ui.InfoBubble(deviationPoint, {
                            content: bubbleContent,
                            hideCloseButton: true,
                            autoClose: false
                        });
                        
                        bubble.open();
                        ui.addBubble(bubble);
                        routeBubbles.push(bubble);

                        setTimeout(() => {
                            const element = document.getElementById(bubbleId);
                            if (element) {
                                element.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                    const alternativeIndex = allRoutes.findIndex(route => route === alternativeRoute);
                                    if (alternativeIndex !== -1) {
                                        currentRouteIndex = alternativeIndex;
                                        displayRoutes(allRoutes, alternativeIndex);
                                    }
                                });
                            }
                        }, 100);
                    }
                }

                function calculateTotalTolls(route) {
                    let total = 0;
                    if (!route.sections) return total;
                    
                    route.sections.forEach(section => {
                        if (section.tolls) {
                            section.tolls.forEach(toll => {
                                if (toll.fares) {
                                    const processedFareIds = new Set();
                                    const passSubscriptionTolls = new Map();
                                    
                                    toll.fares.forEach(fare => {
                                        const value = fare.convertedPrice?.value || fare.price?.value || 0;
                                        
                                        if (fare.paymentMethods?.includes('passSubscription')) {
                                            const key = `${toll.countryCode}_${toll.tollSystem}`;
                                            if (!passSubscriptionTolls.has(key) || value < passSubscriptionTolls.get(key)) {
                                                passSubscriptionTolls.set(key, value);
                                            }
                                        } else if (!processedFareIds.has(fare.id)) {
                                            processedFareIds.add(fare.id);
                                            total += value;
                                        }
                                    });
                                    
                                    // Dodaj najniższe opłaty za pass subscription
                                    passSubscriptionTolls.forEach(value => {
                                        total += value;
                                    });
                                }
                            });
                        }
                    });
                    return total;
                }



                
                if (result.routes && result.routes.length > 0) {
                    allRoutes = result.routes; // Zapisujemy wszystkie trasy
                    displayRoutes(allRoutes, currentRouteIndex);
                }

                function displayRoutes(routes, activeIndex) {
                    clearMap();
                    
                    // Oblicz metryki głównej trasy do porównania
                    const mainRoute = routes[activeIndex];
                    const mainDistance = mainRoute.sections.reduce((sum, section) => sum + section.summary.length, 0);
                    const mainTolls = calculateTotalTolls(mainRoute);

                    // Przetwórz każdą trasę (główną i alternatywne)
                    routes.forEach((route, routeIndex) => {
                        const sections = route.sections;
                        const isAlternative = routeIndex !== activeIndex;
                        
                        sections.forEach(section => {
                            const lineString = H.geo.LineString.fromFlexiblePolyline(section.polyline);
                            
                            const polyline = new H.map.Polyline(lineString, {
                                style: {
                                    strokeColor: isAlternative ? '#808080' : '#1F51FF',
                                    lineWidth: isAlternative ? 5 : 6.5,
                                    opacity: isAlternative ? 0.7 : 1,
                                    lineCap: 'round',
                                    lineJoin: 'round'
                                }
                            });

                            polyline.setZIndex(isAlternative ? 1 : 2);
                            map.addObject(polyline);
                            routeLines.push(polyline);

                            if (isAlternative) {
                                polyline.addEventListener('tap', () => {
                                    currentRouteIndex = routeIndex;
                                    displayRoutes(allRoutes, routeIndex);
                                });
                            }

                            map.addObject(polyline);
                            routeLines.push(polyline);

                            // Dodanie drag handle tylko dla aktywnej trasy
                            if (!isAlternative) {
                                // Dodaj marker-uchwyt (początkowo ukryty)
                                const svgMarkup = '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">' +
                                    '<circle cx="12" cy="12" r="11" fill="white" fill-opacity="0.8" stroke="#0066CC" stroke-width="2"/>' +
                                    '<circle cx="12" cy="12" r="6" fill="#0066CC" fill-opacity="0.3"/>' +
                                    '</svg>';
                                
                                const dragHandle = new H.map.Marker({ lat: 0, lng: 0 }, {
                                    icon: new H.map.Icon(svgMarkup, {
                                        anchor: { x: 12, y: 12 }
                                    }),
                                    visibility: false,
                                    volatility: true
                                });

                                dragHandle.draggable = true;
                                map.addObject(dragHandle);
                                routeLines.push(dragHandle);

                                // Obsługa ruchu myszy nad polyline
                                let isDragging = false;

                                polyline.addEventListener('pointermove', (evt) => {
                                    if (isDragging) return;
                                    
                                    const pointer = evt.currentPointer;
                                    const coordinates = lineString.getLatLngAltArray();
                                    let closestPoint = null;
                                    let minDistance = Infinity;

                                    // Znajdź najbliższy punkt na linii
                                    for(let i = 0; i < coordinates.length - 2; i += 3) {
                                        const point = map.geoToScreen({ 
                                            lat: coordinates[i], 
                                            lng: coordinates[i + 1] 
                                        });
                                        const distance = Math.hypot(point.x - pointer.viewportX, point.y - pointer.viewportY);
                                        
                                        if (distance < minDistance) {
                                            minDistance = distance;
                                            closestPoint = { lat: coordinates[i], lng: coordinates[i + 1] };
                                        }
                                    }

                                    if (minDistance < 50) {
                                        dragHandle.setGeometry(closestPoint);
                                        dragHandle.setVisibility(true);
                                        map.getViewPort().element.style.cursor = 'grab';
                                    } else {
                                        dragHandle.setVisibility(false);
                                        map.getViewPort().element.style.cursor = 'default';
                                    }
                                });

                                // Obsługa przeciągania
                                dragHandle.addEventListener('pointerdown', (evt) => {
                                    evt.stopPropagation();
                                    isDragging = true;
                                    currentDragHandle = evt.target;
                                    behavior.disable();
                                    map.getViewPort().element.style.cursor = 'grabbing';
                                    
                                    const handlePointerMove = (e) => {
                                        if (!isDragging) return;
                                        const rect = map.getViewPort().element.getBoundingClientRect();
                                        const pointer = {
                                            viewportX: e.clientX - rect.left,
                                            viewportY: e.clientY - rect.top
                                        };
                                        currentDragHandle.setGeometry(map.screenToGeo(pointer.viewportX, pointer.viewportY));
                                    };

                                    const handlePointerUp = (e) => {
                                        if (!isDragging) return;
                                        
                                        const position = currentDragHandle.getGeometry();
                                        currentDragHandle.setVisibility(false);
                                        isDragging = false;
                                        behavior.enable();
                                        map.getViewPort().element.style.cursor = 'default';
                                        
                                        const waypoints = [];
                                        document.querySelectorAll('.waypoint').forEach((input, index) => {
                                            if (input.value.trim() !== '') {
                                                const coords = geocodedPoints.get(input.value.trim());
                                                if (coords) {
                                                    waypoints.push({
                                                        coords: coords,
                                                        index: index
                                                    });
                                                }
                                            }
                                        });

                                        let minDistance = Infinity;
                                        let insertIndex = 0;
                                        
                                        for (let i = 0; i < waypoints.length - 1; i++) {
                                            const startPoint = waypoints[i].coords;
                                            const endPoint = waypoints[i + 1].coords;
                                            const distanceToStart = position.distance(startPoint);
                                            const distanceToEnd = position.distance(endPoint);
                                            const avgDistance = (distanceToStart + distanceToEnd) / 2;
                                            
                                            if (avgDistance < minDistance) {
                                                minDistance = avgDistance;
                                                insertIndex = i;
                                            }
                                        }
                                        
                                        const waypointContainers = document.querySelectorAll('.waypoint-container');
                                        const newWaypoint = createWaypointInput();
                                        const input = newWaypoint.querySelector('.waypoint');
                                        input.value = `${position.lat.toFixed(6)}, ${position.lng.toFixed(6)}`;
                                        
                                        const targetContainer = waypointContainers[insertIndex + 1];
                                        if (targetContainer) {
                                            waypointContainers[0].parentNode.insertBefore(newWaypoint, targetContainer);
                                        } else {
                                            waypointContainers[0].parentNode.appendChild(newWaypoint);
                                        }
                                        
                                        input.dispatchEvent(new Event('input'));
                                        updateWaypointNumbers();
                                        calculateRouteIfPossible();
                                        
                                        currentDragHandle = null;
                                        document.removeEventListener('pointermove', handlePointerMove);
                                        document.removeEventListener('pointerup', handlePointerUp);
                                    };

                                    document.addEventListener('pointermove', handlePointerMove);
                                    document.addEventListener('pointerup', handlePointerUp);
                                });

                                polyline.addEventListener('pointerleave', () => {
                                    if (!isDragging) {
                                        dragHandle.setVisibility(false);
                                        map.getViewPort().element.style.cursor = 'default';
                                    }
                                });
                            }
                        });

                        // Dodaj markery tylko dla aktualnej trasy
                        if (routeIndex === currentRouteIndex) {
                            geoResults.forEach((result, index) => {
                                addMarker({ lat: result.lat, lng: result.lng }, index + 1);
                            });

                            // Oblicz i wyświetl informacje o trasie
                            const totalDistance = route.sections.reduce((sum, section) => sum + section.summary.length, 0);
                            const distanceInKm = totalDistance / 1000;
                            const timeInHours = distanceInKm / 73;
                            const totalTime = timeInHours * 3600;

                            // Pobieranie informacji o opłatach
                            let tollInfo = '';
                            if (route.sections) {
                                const countryTolls = new Map();
                                const ferries = new Map();
                                const minPassSubscriptionTolls = new Map();
                                const processedFareIds = new Set();
                                let totalToll = 0;
                                
                                route.sections.forEach(section => {
                                    if (section.transport?.mode) {
                                        const transportMode = section.transport.mode;
                                        const transportName = section.transport.name;
                                        
                                        if (transportName && (
                                            transportMode === 'ferry' || 
                                            transportMode.toLowerCase().includes('shuttletrain')
                                        )) {
                                            const icon = transportMode === 'ferry' ? '⛴️' : '🛤️';
                                            ferries.set(transportName, {
                                                icon: icon,
                                                value: localStorage.getItem(`ferry_${transportName}`) || ''
                                            });
                                        }
                                    }

                                    if (section.tolls) {
                                        section.tolls.forEach(toll => {
                                            const countryCode = toll.countryCode;
                                            if (!countryTolls.has(countryCode)) {
                                                countryTolls.set(countryCode, 0);
                                            }

                                            if (toll.fares) {
                                                let minFare = Infinity;
                                                toll.fares.forEach(fare => {
                                                    const value = fare.convertedPrice?.value || fare.price?.value || 0;
                                                    
                                                    if (fare.paymentMethods?.includes('passSubscription')) {
                                                        const key = `${toll.countryCode}_${toll.tollSystem}`;
                                                        if (!minPassSubscriptionTolls.has(key) || value < minPassSubscriptionTolls.get(key)) {
                                                            minPassSubscriptionTolls.set(key, value);
                                                        }
                                                    } else if (!processedFareIds.has(fare.id)) {
                                                        processedFareIds.add(fare.id);
                                                        minFare = Math.min(minFare, value);
                                                    }
                                                });
                                                
                                                if (minFare !== Infinity) {
                                                    countryTolls.set(countryCode, countryTolls.get(countryCode) + minFare);
                                                }
                                            }
                                        });
                                    }
                                });

                                for (const [key, value] of minPassSubscriptionTolls.entries()) {
                                    const countryCode = key.split('_')[0];
                                    if (countryTolls.has(countryCode)) {
                                        countryTolls.set(countryCode, countryTolls.get(countryCode) + value);
                                    }
                                }

                                totalToll = Array.from(countryTolls.values()).reduce((a, b) => a + b, 0);

                                let roadTollsHtml = '';
                                if (totalToll > 0) {
                                    roadTollsHtml = `
                                        <div class="toll-summary">
                                            <span>Opłaty drogowe: ${totalToll.toFixed(2)} €</span>
                                            <button class="toll-details-toggle">▼</button>
                                        </div>
                                        <div class="toll-details" style="display: none;">
                                            <div class="toll-details-content">
                                                ${Array.from(countryTolls.entries())
                                                    .map(([country, value]) => `
                                                        <div class="country-toll">
                                                            ${country}: ${value.toFixed(2)} EUR
                                                        </div>
                                                    `).join('')}
                                            </div>
                                        </div>`;
                                } else {
                                    roadTollsHtml = `<br>${translations.noRoadCharges}`;
                                }

                                let ferriesHtml = '';
                                if (ferries.size > 0) {
                                    ferriesHtml = Array.from(ferries.entries())
                                        .map(([name, data]) => `
                                            <div class="ferry-item" style="margin-top: 2px;">
                                                ${data.icon} ${name}: 
                                                <input type="number" 
                                                    class="ferry-price" 
                                                    data-ferry-name="${name}"
                                                    value="${data.value}"
                                                    min="0" 
                                                    max="5000" 
                                                    step="1" 
                                                    style="width: 60px; padding: 2px 5px; border: 1px solid #ddd; border-radius: 3px;"
                                                    placeholder="EUR">
                                            </div>
                                        `).join('');
                                }

                                tollInfo = roadTollsHtml + ferriesHtml;
                            } else {
                                tollInfo = `<br>${translations.noRoadCharges}`;
                            }

                            document.getElementById('route-info').innerHTML = `
                                <strong>${translations.routeInfo}</strong><br>
                                ${translations.distance}: ${(totalDistance / 1000).toFixed(1)} km<br>
                                ${translations.time}: ${Math.floor(totalTime / 3600)}h ${Math.round((totalTime % 3600) / 60)}min
                                ${tollInfo}
                            `;

                            // Dodaj event listenery dla szczegółów opłat
                            const tollDetailsToggle = document.querySelector('.toll-details-toggle');
                            if (tollDetailsToggle) {
                                tollDetailsToggle.addEventListener('click', function() {
                                    const details = document.querySelector('.toll-details');
                                    const isExpanded = details.style.display !== 'none';
                                    details.style.display = isExpanded ? 'none' : 'block';
                                    this.textContent = isExpanded ? '▼' : '▲';
                                });
                            }

                            // Dodaj event listenery dla cen promów
                            document.querySelectorAll('.ferry-price').forEach(input => {
                                input.addEventListener('input', (e) => {
                                    const value = e.target.value;
                                    const ferryName = e.target.dataset.ferryName;
                                    if (value === '' || (parseFloat(value) >= 0 && parseFloat(value) <= 5000)) {
                                        localStorage.setItem(`ferry_${ferryName}`, value);
                                }
                            });
                        });
                    }
                    // Dodaj InfoBubbles dla tras alternatywnych
                    if (routes.length > 1) {
                        const mainRoute = routes[currentRouteIndex];
                        routes.forEach((route, index) => {
                            if (index !== currentRouteIndex) {
                                addRouteBubble(mainRoute, route);
                            }
                        });
                    }
                });
                
                // Dostosuj widok mapy aby pokazać wszystkie trasy
                const allCoordinates = [origin, destination, ...viaPoints];
                let minLat = Math.min(...allCoordinates.map(coord => coord.lat));
                let maxLat = Math.max(...allCoordinates.map(coord => coord.lat));
                let minLng = Math.min(...allCoordinates.map(coord => coord.lng));
                let maxLng = Math.max(...allCoordinates.map(coord => coord.lng));

                const latMargin = (maxLat - minLat) * 0.2;
                const lngMargin = (maxLng - minLng) * 0.2;

                minLat -= latMargin;
                maxLat += latMargin;
                minLng -= lngMargin;
                maxLng += lngMargin;

                const fullBoundingBox = new H.geo.Rect(maxLat, minLng, minLat, maxLng);
                map.getViewModel().setLookAtData({
                    bounds: fullBoundingBox
                });
                }

            } catch (error) {
                    // Ignoruj cichutko błędy związane z anulowaniem żądania
                    if (error.name === 'AbortError') {
                        return;
                    }
                    
                    console.error('Route calculation error:', error);
                    document.getElementById('route-info').innerHTML = `
                        <div class="error-message">
                            ${error.message || translations.routeError}
                        </div>
                    `;
                }
        }
		// Initialize application
		const waypointsContainer = document.getElementById('waypoints-container');
		waypointsContainer.appendChild(createWaypointInput());

        function initializeUITranslations() {
            document.getElementById('settings-title').textContent = translations.routeSettings;
            document.getElementById('default-settings-text').textContent = translations.defaultSettings;
            document.getElementById('weight-text').textContent = translations.vehicleWeight;
            document.getElementById('axles-text').textContent = translations.axleCount;
            document.getElementById('euro-class-text').textContent = translations.euroClass;
            document.getElementById('co2-class-text').textContent = translations.co2Class;
            document.getElementById('excluded-areas-text').textContent = translations.excludedAreas;

            // Set text for default combination buttons
            document.querySelectorAll('#default-combination button').forEach(button => {
                const translationKey = button.dataset.translation;
                if (translationKey) {
                    button.textContent = translations[translationKey];
                }
            });
        }

		// Nasłuchuj zdarzeń input tylko dla dodawania nowych pól
        waypointsContainer.addEventListener('input', (e) => {
            if (e.target.classList.contains('waypoint')) {
                updateRemoveButtons();
                const waypoints = document.querySelectorAll('.waypoint');
                const lastWaypoint = waypoints[waypoints.length - 1];
                
                // Add new field only if last isn't empty and we're under the limit
                if (e.target === lastWaypoint && 
                    e.target.value.trim() !== '' && 
                    waypoints.length < 15) {
                    waypointsContainer.appendChild(createWaypointInput());
                }
            }
        });

		// Automatyczny focus na pierwszym polu po załadowaniu strony
        document.addEventListener('DOMContentLoaded', () => {
            const firstWaypoint = document.querySelector('.waypoint');
            if (firstWaypoint) {
                firstWaypoint.focus();
            }
            loadSettings();
            initializeUITranslations(); // Dodaj to wywołanie
        });



        // Inicjalizacja lokalnego storage
        const STORAGE_KEY = 'routeSettings';

        // Funkcja do zapisywania ustawień
        function saveSettings() {
            const settings = {
                weight: document.querySelector('#weight-selection button.active')?.dataset.value,
                axles: document.querySelector('#axles-selection button.active')?.dataset.value,
                euroClass: document.querySelector('#euro-class')?.value,
                co2Class: document.querySelector('#co2-class')?.value,
                excludedAreas: Array.from(document.querySelectorAll('#excluded-areas button.active'))
                    .map(btn => btn.dataset.value),
                defaultCombination: document.querySelector('#default-combination button.active')?.dataset.value
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
        }

        // Funkcja do wczytywania ustawień
        function loadSettings() {
            try {
                const settings = JSON.parse(localStorage.getItem(STORAGE_KEY));
                
                if (settings) {
                    // Wczytaj zapisane ustawienia
                    if (settings.weight) {
                        document.querySelector(`#weight-selection button[data-value="${settings.weight}"]`)?.classList.add('active');
                    }
                    if (settings.axles) {
                        document.querySelector(`#axles-selection button[data-value="${settings.axles}"]`)?.classList.add('active');
                    }
                    if (settings.euroClass) {
                        document.querySelector('#euro-class').value = settings.euroClass;
                    }
                    if (settings.co2Class) {
                        document.querySelector('#co2-class').value = settings.co2Class;
                    }
                    if (settings.excludedAreas) {
                        settings.excludedAreas.forEach(area => {
                            document.querySelector(`#excluded-areas button[data-value="${area}"]`)?.classList.add('active');
                        });
                    }
                } else {
                    // Ustaw wartości domyślne dla nowego użytkownika
                    const defaultSettings = {
                        weight: '40000',  // 18-40t
                        axles: '5+',     // 5+ osi
                        euroClass: '6',   // EURO 6
                        co2Class: '1',    // CO2 I
                    };

                    // Ustawienie domyślnej kombinacji (Duży pojazd)
                    const largeVehicleBtn = document.querySelector('#default-combination button[data-weight="40000"][data-axles="5+"]');
                    if (largeVehicleBtn) {
                        largeVehicleBtn.classList.add('active');
                    }

                    // Ustawienie wagi
                    const weightBtn = document.querySelector(`#weight-selection button[data-value="${defaultSettings.weight}"]`);
                    if (weightBtn) {
                        weightBtn.classList.add('active');
                    }

                    // Ustawienie liczby osi
                    const axlesBtn = document.querySelector(`#axles-selection button[data-value="${defaultSettings.axles}"]`);
                    if (axlesBtn) {
                        axlesBtn.classList.add('active');
                    }

                    // Ustawienie klasy EURO
                    const euroSelect = document.querySelector('#euro-class');
                    if (euroSelect) {
                        euroSelect.value = defaultSettings.euroClass;
                    }

                    // Ustawienie klasy CO2
                    const co2Select = document.querySelector('#co2-class');
                    if (co2Select) {
                        co2Select.value = defaultSettings.co2Class;
                    }

                    // Zapisz domyślne ustawienia w localStorage
                    saveSettings();
                }

                // Sprawdź czy jest pasująca kombinacja domyślna
                checkDefaultCombination();
            } catch (error) {
                console.error('Error loading settings:', error);
            }
        }

        // Funkcja do sprawdzania i zaznaczania domyślnej kombinacji
        function checkDefaultCombination() {
            const activeWeight = document.querySelector('#weight-selection button.active')?.dataset.value;
            const activeAxles = document.querySelector('#axles-selection button.active')?.dataset.value;

            const defaultButtons = document.querySelectorAll('#default-combination button');
            defaultButtons.forEach(button => {
                button.classList.remove('active');
                if (button.dataset.weight === activeWeight && button.dataset.axles === activeAxles) {
                    button.classList.add('active');
                }
            });
        }

        // Event listenery dla przycisków domyślnych kombinacji
        document.querySelectorAll('#default-combination button').forEach(button => {
            button.addEventListener('click', () => {
                document.querySelectorAll('#default-combination button').forEach(btn => 
                    btn.classList.remove('active'));
                button.classList.add('active');

                const weight = button.dataset.weight;
                const axles = button.dataset.axles;

                document.querySelectorAll('#weight-selection button').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.value === weight);
                });

                document.querySelectorAll('#axles-selection button').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.value === axles);
                });

                saveSettings();
                if (typeof calculateRouteIfPossible === 'function') {
                    calculateRouteIfPossible();
                }
            });
        });

        // Event listenery dla wagi i osi
        ['weight-selection', 'axles-selection'].forEach(id => {
            document.querySelectorAll(`#${id} button`).forEach(button => {
                button.addEventListener('click', () => {
                    document.querySelectorAll(`#${id} button`).forEach(btn => 
                        btn.classList.remove('active'));
                    button.classList.add('active');
                    
                    checkDefaultCombination();
                    saveSettings();
                    if (typeof calculateRouteIfPossible === 'function') {
                        calculateRouteIfPossible();
                    }
                });
            });
        });

        // Event listenery dla selectów
        ['euro-class', 'co2-class'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                saveSettings();
                if (typeof calculateRouteIfPossible === 'function') {
                    calculateRouteIfPossible();
                }
            });
        });

        // Event listenery dla wyłączonych obszarów
        document.querySelectorAll('#excluded-areas button').forEach(button => {
            button.addEventListener('click', () => {
                button.classList.toggle('active');
                saveSettings();
                if (typeof calculateRouteIfPossible === 'function') {
                    calculateRouteIfPossible();
                }
            });
        });

        // Wczytaj ustawienia przy starcie
        document.addEventListener('DOMContentLoaded', loadSettings);


        function getVehicleParameters() {
            const weightBtn = document.querySelector('#weight-selection button.active');
            const axlesBtn = document.querySelector('#axles-selection button.active');
            
            return {
                weight: weightBtn ? parseInt(weightBtn.dataset.value) : 3500, // wartość w kg
                axleCount: axlesBtn ? parseInt(axlesBtn.dataset.value) : 2,
                height: 400,  // 4m w centymetrach
                width: 255,   // 2.55m w centymetrach
                length: 1650  // 16.5m w centymetrach
            };
        }

        ////////////////// FUNKCJE ODPOWIEDZIALNE ZA BUDOWE LINKU + ZMIANĘ PAGE TITLE
        // Function to update URL with current route and settings
        function updateURLParameters() {
            const waypoints = document.querySelectorAll('.waypoint');
            const params = new URLSearchParams();

            // Add waypoints
            waypoints.forEach((waypoint, index) => {
                const value = waypoint.value.trim();
                if (value) {
                    if (isGPSCoordinates(value)) {
                        const coords = geocodedPoints.get(value);
                        if (coords) {
                            params.append(`wp${index}`, `${coords.lat},${coords.lng}`);
                        }
                    } else {
                        // For addresses, store the actual address text
                        params.append(`wp${index}`, encodeURIComponent(value));
                    }
                }
            });

            // Add vehicle settings
            const weightBtn = document.querySelector('#weight-selection button.active');
            const axlesBtn = document.querySelector('#axles-selection button.active');
            params.append('weight', weightBtn?.dataset.value || '40000');
            params.append('axles', axlesBtn?.dataset.value || '5+');
            params.append('euro', document.querySelector('#euro-class').value);
            params.append('co2', document.querySelector('#co2-class').value);

            // Add excluded areas
            const excludedAreas = Array.from(document.querySelectorAll('#excluded-areas button.active'))
                .map(btn => btn.dataset.value);
            if (excludedAreas.length > 0) {
                params.append('excluded', excludedAreas.join(','));
            }

            // Update URL without reloading the page
            const newURL = `${window.location.pathname}?${params.toString()}`;
            window.history.pushState({ path: newURL }, '', newURL);
        }

        function updatePageTitle() {
            const waypoints = document.querySelectorAll('.waypoint');
            const nonEmptyWaypoints = Array.from(waypoints)
                .filter(wp => wp.value.trim() !== '');

            if (nonEmptyWaypoints.length >= 2) {
                const getLocationName = (value) => {
                    const words = value.trim().split(' ');
                    return words.slice(0, 2).join(' ');
                };

                const firstLocation = getLocationName(nonEmptyWaypoints[0].value);
                const lastLocation = getLocationName(nonEmptyWaypoints[nonEmptyWaypoints.length - 1].value);
                document.title = `TN: ${firstLocation} -> ${lastLocation}`;
            } else {
                document.title = 'Transport Nomad';
            }
        }

        // Function to load route from URL parameters
        async function loadRouteFromURL() {
            const params = new URLSearchParams(window.location.search);
            if (params.toString() === '') return;

            // Clear existing waypoints
            const waypointsContainer = document.getElementById('waypoints-container');
            waypointsContainer.innerHTML = '';

            // Load waypoints
            const waypointParams = Array.from(params.entries())
                .filter(([key]) => key.startsWith('wp'))
                .sort((a, b) => parseInt(a[0].slice(2)) - parseInt(b[0].slice(2)));

            for (const [_, value] of waypointParams) {
                const container = createWaypointInput();
                const input = container.querySelector('.waypoint');
                
                if (value.includes(',')) {
                    const [lat, lng] = value.split(',').map(Number);
                    if (!isNaN(lat) && !isNaN(lng)) {
                        input.value = `${lat}, ${lng}`;
                    }
                } else {
                    input.value = decodeURIComponent(value);
                }
                waypointsContainer.appendChild(container);
            }

            // Load settings
            if (params.has('weight')) {
                const weightBtn = document.querySelector(`#weight-selection button[data-value="${params.get('weight')}"]`);
                if (weightBtn) {
                    document.querySelectorAll('#weight-selection button').forEach(btn => btn.classList.remove('active'));
                    weightBtn.classList.add('active');
                }
            }

            if (params.has('axles')) {
                const axlesBtn = document.querySelector(`#axles-selection button[data-value="${params.get('axles')}"]`);
                if (axlesBtn) {
                    document.querySelectorAll('#axles-selection button').forEach(btn => btn.classList.remove('active'));
                    axlesBtn.classList.add('active');
                }
            }

            if (params.has('euro')) {
                document.querySelector('#euro-class').value = params.get('euro');
            }

            if (params.has('co2')) {
                document.querySelector('#co2-class').value = params.get('co2');
            }

            if (params.has('excluded')) {
                const excludedAreas = params.get('excluded').split(',');
                document.querySelectorAll('#excluded-areas button').forEach(btn => {
                    btn.classList.toggle('active', excludedAreas.includes(btn.dataset.value));
                });
            }

            checkDefaultCombination();
            // Sprawdź czy istnieją jakieś pola i czy ostatnie nie jest puste
            const waypoints = document.querySelectorAll('.waypoint');
            const lastWaypoint = waypoints[waypoints.length - 1];
            
            if (waypoints.length < 12 && lastWaypoint && lastWaypoint.value.trim() !== '') {
                waypointsContainer.appendChild(createWaypointInput());
            }
            
            if (waypointParams.length > 0) {
                calculateRouteIfPossible();
            } else {
                updatePageTitle();
            }
        }

        // Modify calculateRouteIfPossible to update URL and title after successful route calculation
        const originalCalculateRouteIfPossible = calculateRouteIfPossible;
        calculateRouteIfPossible = async function() {
            await originalCalculateRouteIfPossible();
            updateURLParameters();
            updatePageTitle();
        };

        // Add initial event listeners
        document.addEventListener('DOMContentLoaded', () => {
            loadRouteFromURL();
            updatePageTitle();
        });

        // Add URL update on browser navigation
        window.addEventListener('popstate', loadRouteFromURL);
        ////////////////// KONIEC FUNKCJE ODPOWIEDZIALNE ZA BUDOWE LINKU + ZMIANĘ PAGE TITLE

        // Funkcja do resetowania aplikacji
        function restartApp() {
            // Wyczyść kontener punktów trasy
            const waypointsContainer = document.getElementById('waypoints-container');
            waypointsContainer.innerHTML = '';
            
            // Wyczyść mapę
            clearMap();
            
            // Wyczyść informacje o trasie
            const routeInfo = document.getElementById('route-info');
            if (routeInfo) {
                routeInfo.innerHTML = '';
            }
            
            // Zresetuj zapisane punkty geocoded
            geocodedPoints.clear();
            
            // Dodaj pojedyncze puste pole
            waypointsContainer.appendChild(createWaypointInput());
            
            // Ustaw focus na nowym polu
            const firstWaypoint = document.querySelector('.waypoint');
            if (firstWaypoint) {
                firstWaypoint.focus();
            }
            
            // Zresetuj tytuł strony
            document.title = 'Transport Nomad';
            
            // Wyczyść parametry URL
            window.history.pushState({}, '', window.location.pathname);
            
            // Zresetuj widok mapy do domyślnego
            map.setCenter({ lat: 50.0, lng: 15.0 });
            map.setZoom(5.5);
        }

        // Dodaj nasłuchiwanie na przycisk reset przy starcie aplikacji
        document.addEventListener('DOMContentLoaded', () => {
            // [poprzedni kod DOMContentLoaded]
            
            // Dodaj obsługę przycisku reset
            document.getElementById('restart-button').addEventListener('click', restartApp);
        });
        // Add initial event listeners
        document.addEventListener('DOMContentLoaded', () => {
            loadRouteFromURL();
            updatePageTitle();
            
            // Dodaj obsługę przycisku reset
            document.getElementById('restart-button').addEventListener('click', restartApp);
        });

        // Dodaj obsługę skrótu klawiszowego Ctrl+I
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key.toLowerCase() === 'i') {
                e.preventDefault(); // Zapobiegamy domyślnej akcji przeglądarki
                restartApp();
            }
        });
    </script>
</body>
</html
